{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///jsnes.min.js","webpack:///webpack/bootstrap 4ad2b6d0fe0a02932a24","webpack:///./src/utils.js","webpack:///./src/controller.js","webpack:///./src/tile.js","webpack:///./src/index.js","webpack:///./src/nes.js","webpack:///./src/cpu.js","webpack:///./src/ppu.js","webpack:///./src/papu.js","webpack:///./src/gg.js","webpack:///./src/rom.js","webpack:///./src/mappers.js"],"names":["root","factory","exports","module","define","amd","self","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","copyArrayElements","src","srcPos","dest","destPos","length","copyArray","Array","fromJSON","obj","state","JSON_PROPERTIES","toJSON","Controller","BUTTON_A","BUTTON_B","BUTTON_SELECT","BUTTON_START","BUTTON_UP","BUTTON_DOWN","BUTTON_LEFT","BUTTON_RIGHT","buttonDown","key","buttonUp","Tile","pix","fbIndex","tIndex","x","y","w","h","incX","incY","palIndex","tpri","initialized","opaque","setBuffer","scanline","setScanline","sline","b1","b2","render","buffer","srcx1","srcy1","srcx2","srcy2","dx","dy","palAdd","palette","flipHorizontal","flipVertical","pri","priTable","isTransparent","NES","CPU","PPU","PAPU","GameGenie","ROM","opts","onFrame","onAudioSample","onStatusUpdate","preferredFrameRate","emulateSound","sampleRate","frameTime","ui","writeFrame","updateStatus","cpu","ppu","papu","gameGenie","mmap","controllers","1","2","frame","bind","zapperMove","zapperFireDown","zapperFireUp","fpsFrameCount","romData","reset","lastFpsTime","startFrame","cycles","FRAMELOOP","cyclesToHalt","emulate","clockFrameCounter","curX","spr0HitX","f_spVisibility","spr0HitY","setStatusFlag","STATUS_SPRITE0HIT","requestEndFrame","nmiCounter","startVBlank","endScanline","controller","button","zapperX","zapperY","zapperFired","getFPS","now","Date","fps","reloadROM","loadROM","data","rom","load","createMapper","setMirroring","getMirroringType","setFramerate","rate","setSampleRate","utils","nes","mem","REG_ACC","REG_X","REG_Y","REG_SP","REG_PC","REG_PC_NEW","REG_STATUS","F_CARRY","F_DECIMAL","F_INTERRUPT","F_INTERRUPT_NEW","F_OVERFLOW","F_SIGN","F_ZERO","F_NOTUSED","F_NOTUSED_NEW","F_BRK","F_BRK_NEW","opdata","crash","irqRequested","irqType","IRQ_NORMAL","IRQ_NMI","IRQ_RESET","j","k","setStatus","OpData","temp","add","doIrq","doNonMaskableInterrupt","doResetInterrupt","opinf","loadFromCartridge","cycleCount","cycleAdd","addrMode","opaddr","addr","load16bit","write","push","pull","stackWrap","stop","crashMessage","toString","value","enabled","applyCodes","val","requestIrq","type","pageCrossed","addr1","addr2","haltCycles","status","getStatus","st","setOp","INS_ADC","ADDR_IMM","ADDR_ZP","ADDR_ZPX","ADDR_ABS","ADDR_ABSX","ADDR_ABSY","ADDR_PREIDXIND","ADDR_POSTIDXIND","INS_AND","INS_ASL","ADDR_ACC","INS_BCC","ADDR_REL","INS_BCS","INS_BEQ","INS_BIT","INS_BMI","INS_BNE","INS_BPL","INS_BRK","ADDR_IMP","INS_BVC","INS_BVS","INS_CLC","INS_CLD","INS_CLI","INS_CLV","INS_CMP","INS_CPX","INS_CPY","INS_DEC","INS_DEX","INS_DEY","INS_EOR","INS_INC","INS_INX","INS_INY","INS_JMP","ADDR_INDABS","INS_JSR","INS_LDA","INS_LDX","ADDR_ZPY","INS_LDY","INS_LSR","INS_NOP","INS_ORA","INS_PHA","INS_PHP","INS_PLA","INS_PLP","INS_ROL","INS_ROR","INS_RTI","INS_RTS","INS_SBC","INS_SEC","INS_SED","INS_SEI","INS_STA","INS_STX","INS_STY","INS_TAX","INS_TAY","INS_TSX","INS_TXA","INS_TXS","INS_TYA","cycTable","instname","addrDesc","INS_DUMMY","inst","op","size","vramMem","spriteMem","vramAddress","vramTmpAddress","vramBufferedReadValue","firstWrite","sramAddress","currentMirroring","nmiOk","dummyCycleToggle","validTileData","scanlineAlreadyRendered","f_nmiOnVblank","f_spriteSize","f_bgPatternTable","f_spPatternTable","f_addrInc","f_nTblAddress","f_color","f_bgVisibility","f_spClipping","f_bgClipping","f_dispType","cntFV","cntV","cntH","cntVT","cntHT","regFV","regV","regH","regVT","regHT","regFH","regS","curNt","attrib","bgbuffer","pixrendered","scantile","lastRenderedScanline","sprX","sprY","sprTile","sprCol","vertFlip","horiFlip","bgPriority","hitSpr0","sprPalette","imgPalette","ptTile","ntable1","nameTable","vramMirrorTable","palTable","showSpr0Hit","clipToTvSize","STATUS_VRAMWRITE","STATUS_SLSPRITECOUNT","STATUS_VBLANK","NameTable","PaletteTable","loadNTSCPalette","updateControlReg1","updateControlReg2","mirroring","triggerRendering","defineMirrorRegion","HORIZONTAL_MIRRORING","VERTICAL_MIRRORING","SINGLESCREEN_MIRRORING","SINGLESCREEN_MIRRORING2","fromStart","toStart","renderFramePartially","endFrame","renderBgScanline","checkSprite0","clockIrqCounter","regsToAddress","cntsToAddress","bgColor","setEmphasis","updatePalettes","flag","readStatusRegister","tmp","writeSRAMAddress","address","sramLoad","sramWrite","spriteRamWriteUpdate","scrollWrite","writeVRAMAddress","latchAccess","vramLoad","mirroredLoad","cntsFromAddress","regsFromAddress","vramWrite","mirroredWrite","writeMem","sramDMA","baseAddress","incTileCounter","count","Error","startScan","scanCount","renderSpritesPartially","si","ei","destIndex","scan","baseTile","t","tpix","att","col","tscanoffset","targetBuffer","tile","getTileIndex","getAttrib","sx","startscan","scancount","bgPri","top","toffset","bufferIndex","tIndexAdd","patternWrite","nameTableWrite","attribTableWrite","getEntry","tileIndex","Math","floor","leftOver","index","writeAttrib","doNMI","isPixelWhite","width","height","tx","ty","basex","basey","sqy","sqx","curTable","emphTable","currentEmph","makeTables","loadPALPalette","r","g","b","rFactor","gFactor","bFactor","emph","getRed","getGreen","getBlue","getRgb","yiq","rgb","loadDefaultPalette","square1","ChannelSquare","square2","triangle","ChannelTriangle","noise","ChannelNoise","dmc","ChannelDM","frameIrqCounter","frameIrqCounterMax","initCounter","channelEnableValue","lengthLookup","dmcFreqLookup","noiseWavelengthLookup","square_table","tnd_table","frameIrqEnabled","frameIrqActive","frameClockNow","startedPlaying","recordOutput","initingHardware","masterFrameCounter","derivedFrameCounter","countSequence","sampleTimer","sampleTimerMax","sampleCount","triValue","smpSquare1","smpSquare2","smpTriangle","smpDmc","accCount","prevSampleL","prevSampleR","smpAccumL","smpAccumR","dacRange","dcValue","masterVolume","stereoPosLSquare1","stereoPosLSquare2","stereoPosLTriangle","stereoPosLNoise","stereoPosLDMC","stereoPosRSquare1","stereoPosRSquare2","stereoPosRTriangle","stereoPosRNoise","stereoPosRDMC","extraCycles","maxSample","minSample","panning","setPanning","initLengthLookup","initDmcFrequencyLookup","initNoiseWavelengthLookup","initDACtables","writeReg","updateChannelEnable","resetCounter","readReg","getLengthStatus","getIrqStatus","irqGenerated","frameCounterTick","setEnabled","nCycles","maxCycles","isEnabled","shiftCounter","dmaFrequency","clockDmc","progTimerMax","progTimerCount","linearCounter","lengthCounter","triangleCounter","sampleValue","squareCounter","updateSampleValue","acc_c","accValue","shiftReg","randomMode","randomBit","accSample","sample","sampleCondition","clockLengthCounter","clockSweep","clockEnvDecay","clockLinearCounter","sq_index","tnd_index","smpNoise","sampleValueL","sampleValueR","smpDiffL","smpDiffR","getLengthMax","getDmcFrequency","getNoiseWaveLength","pos","updateStereoPos","setMasterVolume","ival","max_sqr","max_tnd","MODE_NORMAL","MODE_LOOP","MODE_IRQ","hasSample","playMode","dmaCounter","deltaCounter","playStartAddress","playAddress","playLength","playLengthCounter","reg4012","reg4013","dacLsb","endOfSample","nextSample","envDecayDisable","envDecayLoopEnable","lengthCounterEnable","envReset","shiftNow","envDecayRate","envDecayCounter","envVolume","dutyLookup","impLookup","sqr1","sweepActive","sweepCarry","updateSweepPeriod","sweepCounter","sweepCounterMax","sweepMode","sweepShiftAmount","dutyMode","sweepResult","vol","addrAdd","lcHalt","lcControl","lcLoadValue","updateSampleCondition","clockProgrammableTimer","clockTriangleGenerator","toDigit","letter","LETTER_VALUES","indexOf","toLetter","digit","substr","toHex","substring","GG","patches","addCode","code","decode","addPatch","undefined","decodeHex","digits","toUpperCase","split","map","wantskey","encodeHex","match","parseInt","encode","join","Mappers","mapperName","FOURSCREEN_MIRRORING","SINGLESCREEN_MIRRORING3","SINGLESCREEN_MIRRORING4","CHRROM_MIRRORING","header","vrom","vromTile","romCount","vromCount","batteryRam","trainer","fourScreen","mapperType","valid","v","charCodeAt","foundError","offset","getMapperName","mapperSupported","joy1StrobeState","joy2StrobeState","joypadLastWrite","regWrite","writelow","regLoad","joy1Read","joy2Read","ret","loadPRGROM","loadCHRROM","loadBatteryRam","loadRomBank","loadVromBank","ram","bank","load32kRomBank","load8kVromBank","bank4kStart","load1kVromBank","bank1k","bank4k","bankoffset","baseIndex","load2kVromBank","bank2k","load8kRomBank","bank8k","bank16k","apply","regBuffer","regBufferCounter","oneScreenMirroring","prgSwitchingArea","prgSwitchingSize","vromSwitchingSize","romSelectionReg0","romSelectionReg1","romBankSelect","arguments","getRegNumber","setReg","reg","baseBank","switchLowHighPrgRom","oldSetting","switch16to32","switch32to16","CMD_SEL_2_1K_VROM_0000","CMD_SEL_2_1K_VROM_0800","CMD_SEL_1K_VROM_1000","CMD_SEL_1K_VROM_1400","CMD_SEL_1K_VROM_1800","CMD_SEL_1K_VROM_1C00","CMD_SEL_ROM_PAGE1","CMD_SEL_ROM_PAGE2","command","prgAddressSelect","chrAddressSelect","pageNumber","irqCounter","irqLatchValue","irqEnable","prgAddressChanged","executeCommand","cmd","arg","prg_size","chr_size","sram_we_a","sram_we_b","graphic_mode","nametable_mode","nametable_type","fill_chr","fill_pal","SetBank_SRAM","SetBank_CPU","chr_mode","chr_page","SetBank_PPU","split_control","split_scroll","split_page","irq_line","ClearIRQ","irq_enable","mult_a","mult_b","exWrite","irq_status","prgbank1","prgbank2","console","log"],"mappings":"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SACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,SACArS,MAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UACArS,KAAAqS,SAAA,UAEArS,KAAAsS,SAAA,GAAApQ,OACA,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,wBAIA0J,GAAArK,WACAwM,QAAA,EACAS,QAAA,EACAC,QAAA,EAEAE,QAAA,EACAE,QAAA,EACAC,QAAA,EACAC,QAAA,EACAC,QAAA,EACAC,QAAA,EACAC,QAAA,EACAC,QAAA,GACAE,QAAA,GACAC,QAAA,GAEAC,QAAA,GACAC,QAAA,GACAC,QAAA,GACAC,QAAA,GACAC,QAAA,GACAC,QAA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","file":"jsnes.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"jsnes\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"jsnes\"] = factory();\n\telse\n\t\troot[\"jsnes\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"jsnes\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"jsnes\"] = factory();\n\telse\n\t\troot[\"jsnes\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 3);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = {\n  copyArrayElements: function(src, srcPos, dest, destPos, length) {\n    for (var i = 0; i < length; ++i) {\n      dest[destPos + i] = src[srcPos + i];\n    }\n  },\n\n  copyArray: function(src) {\n    var dest = new Array(src.length);\n    for (var i = 0; i < src.length; i++) {\n      dest[i] = src[i];\n    }\n    return dest;\n  },\n\n  fromJSON: function(obj, state) {\n    for (var i = 0; i < obj.JSON_PROPERTIES.length; i++) {\n      obj[obj.JSON_PROPERTIES[i]] = state[obj.JSON_PROPERTIES[i]];\n    }\n  },\n\n  toJSON: function(obj) {\n    var state = {};\n    for (var i = 0; i < obj.JSON_PROPERTIES.length; i++) {\n      state[obj.JSON_PROPERTIES[i]] = obj[obj.JSON_PROPERTIES[i]];\n    }\n    return state;\n  }\n};\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nvar Controller = function() {\n  this.state = new Array(8);\n  for (var i = 0; i < this.state.length; i++) {\n    this.state[i] = 0x40;\n  }\n};\n\nController.BUTTON_A = 0;\nController.BUTTON_B = 1;\nController.BUTTON_SELECT = 2;\nController.BUTTON_START = 3;\nController.BUTTON_UP = 4;\nController.BUTTON_DOWN = 5;\nController.BUTTON_LEFT = 6;\nController.BUTTON_RIGHT = 7;\n\nController.prototype = {\n  buttonDown: function(key) {\n    this.state[key] = 0x41;\n  },\n\n  buttonUp: function(key) {\n    this.state[key] = 0x40;\n  }\n};\n\nmodule.exports = Controller;\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nvar Tile = function() {\n  // Tile data:\n  this.pix = new Array(64);\n\n  this.fbIndex = null;\n  this.tIndex = null;\n  this.x = null;\n  this.y = null;\n  this.w = null;\n  this.h = null;\n  this.incX = null;\n  this.incY = null;\n  this.palIndex = null;\n  this.tpri = null;\n  this.c = null;\n  this.initialized = false;\n  this.opaque = new Array(8);\n};\n\nTile.prototype = {\n  setBuffer: function(scanline) {\n    for (this.y = 0; this.y < 8; this.y++) {\n      this.setScanline(this.y, scanline[this.y], scanline[this.y + 8]);\n    }\n  },\n\n  setScanline: function(sline, b1, b2) {\n    this.initialized = true;\n    this.tIndex = sline << 3;\n    for (this.x = 0; this.x < 8; this.x++) {\n      this.pix[this.tIndex + this.x] =\n        ((b1 >> (7 - this.x)) & 1) + (((b2 >> (7 - this.x)) & 1) << 1);\n      if (this.pix[this.tIndex + this.x] === 0) {\n        this.opaque[sline] = false;\n      }\n    }\n  },\n\n  render: function(\n    buffer,\n    srcx1,\n    srcy1,\n    srcx2,\n    srcy2,\n    dx,\n    dy,\n    palAdd,\n    palette,\n    flipHorizontal,\n    flipVertical,\n    pri,\n    priTable\n  ) {\n    if (dx < -7 || dx >= 256 || dy < -7 || dy >= 240) {\n      return;\n    }\n\n    this.w = srcx2 - srcx1;\n    this.h = srcy2 - srcy1;\n\n    if (dx < 0) {\n      srcx1 -= dx;\n    }\n    if (dx + srcx2 >= 256) {\n      srcx2 = 256 - dx;\n    }\n\n    if (dy < 0) {\n      srcy1 -= dy;\n    }\n    if (dy + srcy2 >= 240) {\n      srcy2 = 240 - dy;\n    }\n\n    if (!flipHorizontal && !flipVertical) {\n      this.fbIndex = (dy << 8) + dx;\n      this.tIndex = 0;\n      for (this.y = 0; this.y < 8; this.y++) {\n        for (this.x = 0; this.x < 8; this.x++) {\n          if (\n            this.x >= srcx1 &&\n            this.x < srcx2 &&\n            this.y >= srcy1 &&\n            this.y < srcy2\n          ) {\n            this.palIndex = this.pix[this.tIndex];\n            this.tpri = priTable[this.fbIndex];\n            if (this.palIndex !== 0 && pri <= (this.tpri & 0xff)) {\n              //console.log(\"Rendering upright tile to buffer\");\n              buffer[this.fbIndex] = palette[this.palIndex + palAdd];\n              this.tpri = (this.tpri & 0xf00) | pri;\n              priTable[this.fbIndex] = this.tpri;\n            }\n          }\n          this.fbIndex++;\n          this.tIndex++;\n        }\n        this.fbIndex -= 8;\n        this.fbIndex += 256;\n      }\n    } else if (flipHorizontal && !flipVertical) {\n      this.fbIndex = (dy << 8) + dx;\n      this.tIndex = 7;\n      for (this.y = 0; this.y < 8; this.y++) {\n        for (this.x = 0; this.x < 8; this.x++) {\n          if (\n            this.x >= srcx1 &&\n            this.x < srcx2 &&\n            this.y >= srcy1 &&\n            this.y < srcy2\n          ) {\n            this.palIndex = this.pix[this.tIndex];\n            this.tpri = priTable[this.fbIndex];\n            if (this.palIndex !== 0 && pri <= (this.tpri & 0xff)) {\n              buffer[this.fbIndex] = palette[this.palIndex + palAdd];\n              this.tpri = (this.tpri & 0xf00) | pri;\n              priTable[this.fbIndex] = this.tpri;\n            }\n          }\n          this.fbIndex++;\n          this.tIndex--;\n        }\n        this.fbIndex -= 8;\n        this.fbIndex += 256;\n        this.tIndex += 16;\n      }\n    } else if (flipVertical && !flipHorizontal) {\n      this.fbIndex = (dy << 8) + dx;\n      this.tIndex = 56;\n      for (this.y = 0; this.y < 8; this.y++) {\n        for (this.x = 0; this.x < 8; this.x++) {\n          if (\n            this.x >= srcx1 &&\n            this.x < srcx2 &&\n            this.y >= srcy1 &&\n            this.y < srcy2\n          ) {\n            this.palIndex = this.pix[this.tIndex];\n            this.tpri = priTable[this.fbIndex];\n            if (this.palIndex !== 0 && pri <= (this.tpri & 0xff)) {\n              buffer[this.fbIndex] = palette[this.palIndex + palAdd];\n              this.tpri = (this.tpri & 0xf00) | pri;\n              priTable[this.fbIndex] = this.tpri;\n            }\n          }\n          this.fbIndex++;\n          this.tIndex++;\n        }\n        this.fbIndex -= 8;\n        this.fbIndex += 256;\n        this.tIndex -= 16;\n      }\n    } else {\n      this.fbIndex = (dy << 8) + dx;\n      this.tIndex = 63;\n      for (this.y = 0; this.y < 8; this.y++) {\n        for (this.x = 0; this.x < 8; this.x++) {\n          if (\n            this.x >= srcx1 &&\n            this.x < srcx2 &&\n            this.y >= srcy1 &&\n            this.y < srcy2\n          ) {\n            this.palIndex = this.pix[this.tIndex];\n            this.tpri = priTable[this.fbIndex];\n            if (this.palIndex !== 0 && pri <= (this.tpri & 0xff)) {\n              buffer[this.fbIndex] = palette[this.palIndex + palAdd];\n              this.tpri = (this.tpri & 0xf00) | pri;\n              priTable[this.fbIndex] = this.tpri;\n            }\n          }\n          this.fbIndex++;\n          this.tIndex--;\n        }\n        this.fbIndex -= 8;\n        this.fbIndex += 256;\n      }\n    }\n  },\n\n  isTransparent: function(x, y) {\n    return this.pix[(y << 3) + x] === 0;\n  },\n\n  toJSON: function() {\n    return {\n      opaque: this.opaque,\n      pix: this.pix\n    };\n  },\n\n  fromJSON: function(s) {\n    this.opaque = s.opaque;\n    this.pix = s.pix;\n  }\n};\n\nmodule.exports = Tile;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = {\n  Controller: __webpack_require__(1),\n  NES: __webpack_require__(4),\n};\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar CPU = __webpack_require__(5);\nvar Controller = __webpack_require__(1);\nvar PPU = __webpack_require__(6);\nvar PAPU = __webpack_require__(7);\nvar GameGenie = __webpack_require__(8);\nvar ROM = __webpack_require__(9);\n\nvar NES = function(opts) {\n  this.opts = {\n    onFrame: function() {},\n    onAudioSample: null,\n    onStatusUpdate: function() {},\n\n    // FIXME: not actually used except for in PAPU\n    preferredFrameRate: 60,\n\n    emulateSound: true,\n    sampleRate: 44100 // Sound sample rate in hz\n  };\n  if (typeof opts !== \"undefined\") {\n    var key;\n    for (key in this.opts) {\n      if (typeof opts[key] !== \"undefined\") {\n        this.opts[key] = opts[key];\n      }\n    }\n  }\n\n  this.frameTime = 1000 / this.opts.preferredFrameRate;\n\n  this.ui = {\n    writeFrame: this.opts.onFrame,\n    updateStatus: this.opts.onStatusUpdate\n  };\n  this.cpu = new CPU(this);\n  this.ppu = new PPU(this);\n  this.papu = new PAPU(this);\n  this.gameGenie = new GameGenie();\n  this.mmap = null; // set in loadROM()\n  this.controllers = {\n    1: new Controller(),\n    2: new Controller(),\n  };\n\n  this.ui.updateStatus(\"Ready to load a ROM.\");\n\n  this.frame = this.frame.bind(this);\n  this.buttonDown = this.buttonDown.bind(this);\n  this.buttonUp = this.buttonUp.bind(this);\n  this.zapperMove = this.zapperMove.bind(this);\n  this.zapperFireDown = this.zapperFireDown.bind(this);\n  this.zapperFireUp = this.zapperFireUp.bind(this);\n};\n\nNES.prototype = {\n  fpsFrameCount: 0,\n  romData: null,\n\n  // Resets the system\n  reset: function() {\n    if (this.mmap !== null) {\n      this.mmap.reset();\n    }\n\n    this.cpu.reset();\n    this.ppu.reset();\n    this.papu.reset();\n\n    this.lastFpsTime = null;\n    this.fpsFrameCount = 0;\n  },\n\n  frame: function() {\n    this.ppu.startFrame();\n    var cycles = 0;\n    var emulateSound = this.opts.emulateSound;\n    var cpu = this.cpu;\n    var ppu = this.ppu;\n    var papu = this.papu;\n    FRAMELOOP: for (;;) {\n      if (cpu.cyclesToHalt === 0) {\n        // Execute a CPU instruction\n        cycles = cpu.emulate();\n        if (emulateSound) {\n          papu.clockFrameCounter(cycles);\n        }\n        cycles *= 3;\n      } else {\n        if (cpu.cyclesToHalt > 8) {\n          cycles = 24;\n          if (emulateSound) {\n            papu.clockFrameCounter(8);\n          }\n          cpu.cyclesToHalt -= 8;\n        } else {\n          cycles = cpu.cyclesToHalt * 3;\n          if (emulateSound) {\n            papu.clockFrameCounter(cpu.cyclesToHalt);\n          }\n          cpu.cyclesToHalt = 0;\n        }\n      }\n\n      for (; cycles > 0; cycles--) {\n        if (\n          ppu.curX === ppu.spr0HitX &&\n          ppu.f_spVisibility === 1 &&\n          ppu.scanline - 21 === ppu.spr0HitY\n        ) {\n          // Set sprite 0 hit flag:\n          ppu.setStatusFlag(ppu.STATUS_SPRITE0HIT, true);\n        }\n\n        if (ppu.requestEndFrame) {\n          ppu.nmiCounter--;\n          if (ppu.nmiCounter === 0) {\n            ppu.requestEndFrame = false;\n            ppu.startVBlank();\n            break FRAMELOOP;\n          }\n        }\n\n        ppu.curX++;\n        if (ppu.curX === 341) {\n          ppu.curX = 0;\n          ppu.endScanline();\n        }\n      }\n    }\n    this.fpsFrameCount++;\n  },\n\n  buttonDown: function(controller, button) {\n    this.controllers[controller].buttonDown(button);\n  },\n\n  buttonUp: function(controller, button) {\n    this.controllers[controller].buttonUp(button);\n  },\n\n  zapperMove: function(x, y) {\n    if (!this.mmap) return;\n    this.mmap.zapperX = x;\n    this.mmap.zapperY = y;\n  },\n\n  zapperFireDown: function() {\n    if (!this.mmap) return;\n    this.mmap.zapperFired = true;\n  },\n\n  zapperFireUp: function() {\n    if (!this.mmap) return;\n    this.mmap.zapperFired = false;\n  },\n\n  getFPS: function() {\n    var now = +new Date();\n    var fps = null;\n    if (this.lastFpsTime) {\n      fps = this.fpsFrameCount / ((now - this.lastFpsTime) / 1000);\n    }\n    this.fpsFrameCount = 0;\n    this.lastFpsTime = now;\n    return fps;\n  },\n\n  reloadROM: function() {\n    if (this.romData !== null) {\n      this.loadROM(this.romData);\n    }\n  },\n\n  // Loads a ROM file into the CPU and PPU.\n  // The ROM file is validated first.\n  loadROM: function(data) {\n    // Load ROM file:\n    this.rom = new ROM(this);\n    this.rom.load(data);\n\n    this.reset();\n    this.mmap = this.rom.createMapper();\n    this.mmap.loadROM();\n    this.ppu.setMirroring(this.rom.getMirroringType());\n    this.romData = data;\n  },\n\n  setFramerate: function(rate) {\n    this.opts.preferredFrameRate = rate;\n    this.frameTime = 1000 / rate;\n    this.papu.setSampleRate(this.opts.sampleRate, false);\n  },\n\n  toJSON: function() {\n    return {\n      romData: this.romData,\n      cpu: this.cpu.toJSON(),\n      mmap: this.mmap.toJSON(),\n      ppu: this.ppu.toJSON()\n    };\n  },\n\n  fromJSON: function(s) {\n    this.loadROM(s.romData);\n    this.cpu.fromJSON(s.cpu);\n    this.mmap.fromJSON(s.mmap);\n    this.ppu.fromJSON(s.ppu);\n  }\n};\n\nmodule.exports = NES;\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar utils = __webpack_require__(0);\n\nvar CPU = function(nes) {\n  this.nes = nes;\n\n  // Keep Chrome happy\n  this.mem = null;\n  this.REG_ACC = null;\n  this.REG_X = null;\n  this.REG_Y = null;\n  this.REG_SP = null;\n  this.REG_PC = null;\n  this.REG_PC_NEW = null;\n  this.REG_STATUS = null;\n  this.F_CARRY = null;\n  this.F_DECIMAL = null;\n  this.F_INTERRUPT = null;\n  this.F_INTERRUPT_NEW = null;\n  this.F_OVERFLOW = null;\n  this.F_SIGN = null;\n  this.F_ZERO = null;\n  this.F_NOTUSED = null;\n  this.F_NOTUSED_NEW = null;\n  this.F_BRK = null;\n  this.F_BRK_NEW = null;\n  this.opdata = null;\n  this.cyclesToHalt = null;\n  this.crash = null;\n  this.irqRequested = null;\n  this.irqType = null;\n\n  this.reset();\n};\n\nCPU.prototype = {\n  // IRQ Types\n  IRQ_NORMAL: 0,\n  IRQ_NMI: 1,\n  IRQ_RESET: 2,\n\n  reset: function() {\n    // Main memory\n    this.mem = new Array(0x10000);\n\n    for (var i = 0; i < 0x2000; i++) {\n      this.mem[i] = 0xff;\n    }\n    for (var p = 0; p < 4; p++) {\n      var j = p * 0x800;\n      this.mem[j + 0x008] = 0xf7;\n      this.mem[j + 0x009] = 0xef;\n      this.mem[j + 0x00a] = 0xdf;\n      this.mem[j + 0x00f] = 0xbf;\n    }\n    for (var k = 0x2001; k < this.mem.length; k++) {\n      this.mem[k] = 0;\n    }\n\n    // CPU Registers:\n    this.REG_ACC = 0;\n    this.REG_X = 0;\n    this.REG_Y = 0;\n    // Reset Stack pointer:\n    this.REG_SP = 0x01ff;\n    // Reset Program counter:\n    this.REG_PC = 0x8000 - 1;\n    this.REG_PC_NEW = 0x8000 - 1;\n    // Reset Status register:\n    this.REG_STATUS = 0x28;\n\n    this.setStatus(0x28);\n\n    // Set flags:\n    this.F_CARRY = 0;\n    this.F_DECIMAL = 0;\n    this.F_INTERRUPT = 1;\n    this.F_INTERRUPT_NEW = 1;\n    this.F_OVERFLOW = 0;\n    this.F_SIGN = 0;\n    this.F_ZERO = 1;\n\n    this.F_NOTUSED = 1;\n    this.F_NOTUSED_NEW = 1;\n    this.F_BRK = 1;\n    this.F_BRK_NEW = 1;\n\n    this.opdata = new OpData().opdata;\n    this.cyclesToHalt = 0;\n\n    // Reset crash flag:\n    this.crash = false;\n\n    // Interrupt notification:\n    this.irqRequested = false;\n    this.irqType = null;\n  },\n\n  // Emulates a single CPU instruction, returns the number of cycles\n  emulate: function() {\n    var temp;\n    var add;\n\n    // Check interrupts:\n    if (this.irqRequested) {\n      temp =\n        this.F_CARRY |\n        ((this.F_ZERO === 0 ? 1 : 0) << 1) |\n        (this.F_INTERRUPT << 2) |\n        (this.F_DECIMAL << 3) |\n        (this.F_BRK << 4) |\n        (this.F_NOTUSED << 5) |\n        (this.F_OVERFLOW << 6) |\n        (this.F_SIGN << 7);\n\n      this.REG_PC_NEW = this.REG_PC;\n      this.F_INTERRUPT_NEW = this.F_INTERRUPT;\n      switch (this.irqType) {\n        case 0: {\n          // Normal IRQ:\n          if (this.F_INTERRUPT !== 0) {\n            // console.log(\"Interrupt was masked.\");\n            break;\n          }\n          this.doIrq(temp);\n          // console.log(\"Did normal IRQ. I=\"+this.F_INTERRUPT);\n          break;\n        }\n        case 1: {\n          // NMI:\n          this.doNonMaskableInterrupt(temp);\n          break;\n        }\n        case 2: {\n          // Reset:\n          this.doResetInterrupt();\n          break;\n        }\n      }\n\n      this.REG_PC = this.REG_PC_NEW;\n      this.F_INTERRUPT = this.F_INTERRUPT_NEW;\n      this.F_BRK = this.F_BRK_NEW;\n      this.irqRequested = false;\n    }\n\n    var opinf = this.opdata[this.loadFromCartridge(this.REG_PC + 1)];\n    var cycleCount = opinf >> 24;\n    var cycleAdd = 0;\n\n    // Find address mode:\n    var addrMode = (opinf >> 8) & 0xff;\n\n    // Increment PC by number of op bytes:\n    var opaddr = this.REG_PC;\n    this.REG_PC += (opinf >> 16) & 0xff;\n\n    var addr = 0;\n    switch (addrMode) {\n      case 0: {\n        // Zero Page mode. Use the address given after the opcode,\n        // but without high byte.\n        addr = this.load(opaddr + 2);\n        break;\n      }\n      case 1: {\n        // Relative mode.\n        addr = this.load(opaddr + 2);\n        if (addr < 0x80) {\n          addr += this.REG_PC;\n        } else {\n          addr += this.REG_PC - 256;\n        }\n        break;\n      }\n      case 2: {\n        // Ignore. Address is implied in instruction.\n        break;\n      }\n      case 3: {\n        // Absolute mode. Use the two bytes following the opcode as\n        // an address.\n        addr = this.load16bit(opaddr + 2);\n        break;\n      }\n      case 4: {\n        // Accumulator mode. The address is in the accumulator\n        // register.\n        addr = this.REG_ACC;\n        break;\n      }\n      case 5: {\n        // Immediate mode. The value is given after the opcode.\n        addr = this.REG_PC;\n        break;\n      }\n      case 6: {\n        // Zero Page Indexed mode, X as index. Use the address given\n        // after the opcode, then add the\n        // X register to it to get the final address.\n        addr = (this.load(opaddr + 2) + this.REG_X) & 0xff;\n        break;\n      }\n      case 7: {\n        // Zero Page Indexed mode, Y as index. Use the address given\n        // after the opcode, then add the\n        // Y register to it to get the final address.\n        addr = (this.load(opaddr + 2) + this.REG_Y) & 0xff;\n        break;\n      }\n      case 8: {\n        // Absolute Indexed Mode, X as index. Same as zero page\n        // indexed, but with the high byte.\n        addr = this.load16bit(opaddr + 2);\n        if ((addr & 0xff00) !== ((addr + this.REG_X) & 0xff00)) {\n          cycleAdd = 1;\n        }\n        addr += this.REG_X;\n        break;\n      }\n      case 9: {\n        // Absolute Indexed Mode, Y as index. Same as zero page\n        // indexed, but with the high byte.\n        addr = this.load16bit(opaddr + 2);\n        if ((addr & 0xff00) !== ((addr + this.REG_Y) & 0xff00)) {\n          cycleAdd = 1;\n        }\n        addr += this.REG_Y;\n        break;\n      }\n      case 10: {\n        // Pre-indexed Indirect mode. Find the 16-bit address\n        // starting at the given location plus\n        // the current X register. The value is the contents of that\n        // address.\n        addr = this.load(opaddr + 2);\n        if ((addr & 0xff00) !== ((addr + this.REG_X) & 0xff00)) {\n          cycleAdd = 1;\n        }\n        addr += this.REG_X;\n        addr &= 0xff;\n        addr = this.load16bit(addr);\n        break;\n      }\n      case 11: {\n        // Post-indexed Indirect mode. Find the 16-bit address\n        // contained in the given location\n        // (and the one following). Add to that address the contents\n        // of the Y register. Fetch the value\n        // stored at that adress.\n        addr = this.load16bit(this.load(opaddr + 2));\n        if ((addr & 0xff00) !== ((addr + this.REG_Y) & 0xff00)) {\n          cycleAdd = 1;\n        }\n        addr += this.REG_Y;\n        break;\n      }\n      case 12: {\n        // Indirect Absolute mode. Find the 16-bit address contained\n        // at the given location.\n        addr = this.load16bit(opaddr + 2); // Find op\n        if (addr < 0x1fff) {\n          addr =\n            this.mem[addr] +\n            (this.mem[(addr & 0xff00) | (((addr & 0xff) + 1) & 0xff)] << 8); // Read from address given in op\n        } else {\n          addr =\n            this.loadFromCartridge(addr) +\n            (this.loadFromCartridge(\n              (addr & 0xff00) | (((addr & 0xff) + 1) & 0xff)\n            ) <<\n              8);\n        }\n        break;\n      }\n    }\n    // Wrap around for addresses above 0xFFFF:\n    addr &= 0xffff;\n\n    // ----------------------------------------------------------------------------------------------------\n    // Decode & execute instruction:\n    // ----------------------------------------------------------------------------------------------------\n\n    // This should be compiled to a jump table.\n    switch (opinf & 0xff) {\n      case 0: {\n        // *******\n        // * ADC *\n        // *******\n\n        // Add with carry.\n        temp = this.REG_ACC + this.load(addr) + this.F_CARRY;\n\n        if (\n          ((this.REG_ACC ^ this.load(addr)) & 0x80) === 0 &&\n          ((this.REG_ACC ^ temp) & 0x80) !== 0\n        ) {\n          this.F_OVERFLOW = 1;\n        } else {\n          this.F_OVERFLOW = 0;\n        }\n        this.F_CARRY = temp > 255 ? 1 : 0;\n        this.F_SIGN = (temp >> 7) & 1;\n        this.F_ZERO = temp & 0xff;\n        this.REG_ACC = temp & 255;\n        cycleCount += cycleAdd;\n        break;\n      }\n      case 1: {\n        // *******\n        // * AND *\n        // *******\n\n        // AND memory with accumulator.\n        this.REG_ACC = this.REG_ACC & this.load(addr);\n        this.F_SIGN = (this.REG_ACC >> 7) & 1;\n        this.F_ZERO = this.REG_ACC;\n        //this.REG_ACC = temp;\n        if (addrMode !== 11) cycleCount += cycleAdd; // PostIdxInd = 11\n        break;\n      }\n      case 2: {\n        // *******\n        // * ASL *\n        // *******\n\n        // Shift left one bit\n        if (addrMode === 4) {\n          // ADDR_ACC = 4\n\n          this.F_CARRY = (this.REG_ACC >> 7) & 1;\n          this.REG_ACC = (this.REG_ACC << 1) & 255;\n          this.F_SIGN = (this.REG_ACC >> 7) & 1;\n          this.F_ZERO = this.REG_ACC;\n        } else {\n          temp = this.load(addr);\n          this.F_CARRY = (temp >> 7) & 1;\n          temp = (temp << 1) & 255;\n          this.F_SIGN = (temp >> 7) & 1;\n          this.F_ZERO = temp;\n          this.write(addr, temp);\n        }\n        break;\n      }\n      case 3: {\n        // *******\n        // * BCC *\n        // *******\n\n        // Branch on carry clear\n        if (this.F_CARRY === 0) {\n          cycleCount += (opaddr & 0xff00) !== (addr & 0xff00) ? 2 : 1;\n          this.REG_PC = addr;\n        }\n        break;\n      }\n      case 4: {\n        // *******\n        // * BCS *\n        // *******\n\n        // Branch on carry set\n        if (this.F_CARRY === 1) {\n          cycleCount += (opaddr & 0xff00) !== (addr & 0xff00) ? 2 : 1;\n          this.REG_PC = addr;\n        }\n        break;\n      }\n      case 5: {\n        // *******\n        // * BEQ *\n        // *******\n\n        // Branch on zero\n        if (this.F_ZERO === 0) {\n          cycleCount += (opaddr & 0xff00) !== (addr & 0xff00) ? 2 : 1;\n          this.REG_PC = addr;\n        }\n        break;\n      }\n      case 6: {\n        // *******\n        // * BIT *\n        // *******\n\n        temp = this.load(addr);\n        this.F_SIGN = (temp >> 7) & 1;\n        this.F_OVERFLOW = (temp >> 6) & 1;\n        temp &= this.REG_ACC;\n        this.F_ZERO = temp;\n        break;\n      }\n      case 7: {\n        // *******\n        // * BMI *\n        // *******\n\n        // Branch on negative result\n        if (this.F_SIGN === 1) {\n          cycleCount++;\n          this.REG_PC = addr;\n        }\n        break;\n      }\n      case 8: {\n        // *******\n        // * BNE *\n        // *******\n\n        // Branch on not zero\n        if (this.F_ZERO !== 0) {\n          cycleCount += (opaddr & 0xff00) !== (addr & 0xff00) ? 2 : 1;\n          this.REG_PC = addr;\n        }\n        break;\n      }\n      case 9: {\n        // *******\n        // * BPL *\n        // *******\n\n        // Branch on positive result\n        if (this.F_SIGN === 0) {\n          cycleCount += (opaddr & 0xff00) !== (addr & 0xff00) ? 2 : 1;\n          this.REG_PC = addr;\n        }\n        break;\n      }\n      case 10: {\n        // *******\n        // * BRK *\n        // *******\n\n        this.REG_PC += 2;\n        this.push((this.REG_PC >> 8) & 255);\n        this.push(this.REG_PC & 255);\n        this.F_BRK = 1;\n\n        this.push(\n          this.F_CARRY |\n            ((this.F_ZERO === 0 ? 1 : 0) << 1) |\n            (this.F_INTERRUPT << 2) |\n            (this.F_DECIMAL << 3) |\n            (this.F_BRK << 4) |\n            (this.F_NOTUSED << 5) |\n            (this.F_OVERFLOW << 6) |\n            (this.F_SIGN << 7)\n        );\n\n        this.F_INTERRUPT = 1;\n        //this.REG_PC = load(0xFFFE) | (load(0xFFFF) << 8);\n        this.REG_PC = this.load16bit(0xfffe);\n        this.REG_PC--;\n        break;\n      }\n      case 11: {\n        // *******\n        // * BVC *\n        // *******\n\n        // Branch on overflow clear\n        if (this.F_OVERFLOW === 0) {\n          cycleCount += (opaddr & 0xff00) !== (addr & 0xff00) ? 2 : 1;\n          this.REG_PC = addr;\n        }\n        break;\n      }\n      case 12: {\n        // *******\n        // * BVS *\n        // *******\n\n        // Branch on overflow set\n        if (this.F_OVERFLOW === 1) {\n          cycleCount += (opaddr & 0xff00) !== (addr & 0xff00) ? 2 : 1;\n          this.REG_PC = addr;\n        }\n        break;\n      }\n      case 13: {\n        // *******\n        // * CLC *\n        // *******\n\n        // Clear carry flag\n        this.F_CARRY = 0;\n        break;\n      }\n      case 14: {\n        // *******\n        // * CLD *\n        // *******\n\n        // Clear decimal flag\n        this.F_DECIMAL = 0;\n        break;\n      }\n      case 15: {\n        // *******\n        // * CLI *\n        // *******\n\n        // Clear interrupt flag\n        this.F_INTERRUPT = 0;\n        break;\n      }\n      case 16: {\n        // *******\n        // * CLV *\n        // *******\n\n        // Clear overflow flag\n        this.F_OVERFLOW = 0;\n        break;\n      }\n      case 17: {\n        // *******\n        // * CMP *\n        // *******\n\n        // Compare memory and accumulator:\n        temp = this.REG_ACC - this.load(addr);\n        this.F_CARRY = temp >= 0 ? 1 : 0;\n        this.F_SIGN = (temp >> 7) & 1;\n        this.F_ZERO = temp & 0xff;\n        cycleCount += cycleAdd;\n        break;\n      }\n      case 18: {\n        // *******\n        // * CPX *\n        // *******\n\n        // Compare memory and index X:\n        temp = this.REG_X - this.load(addr);\n        this.F_CARRY = temp >= 0 ? 1 : 0;\n        this.F_SIGN = (temp >> 7) & 1;\n        this.F_ZERO = temp & 0xff;\n        break;\n      }\n      case 19: {\n        // *******\n        // * CPY *\n        // *******\n\n        // Compare memory and index Y:\n        temp = this.REG_Y - this.load(addr);\n        this.F_CARRY = temp >= 0 ? 1 : 0;\n        this.F_SIGN = (temp >> 7) & 1;\n        this.F_ZERO = temp & 0xff;\n        break;\n      }\n      case 20: {\n        // *******\n        // * DEC *\n        // *******\n\n        // Decrement memory by one:\n        temp = (this.load(addr) - 1) & 0xff;\n        this.F_SIGN = (temp >> 7) & 1;\n        this.F_ZERO = temp;\n        this.write(addr, temp);\n        break;\n      }\n      case 21: {\n        // *******\n        // * DEX *\n        // *******\n\n        // Decrement index X by one:\n        this.REG_X = (this.REG_X - 1) & 0xff;\n        this.F_SIGN = (this.REG_X >> 7) & 1;\n        this.F_ZERO = this.REG_X;\n        break;\n      }\n      case 22: {\n        // *******\n        // * DEY *\n        // *******\n\n        // Decrement index Y by one:\n        this.REG_Y = (this.REG_Y - 1) & 0xff;\n        this.F_SIGN = (this.REG_Y >> 7) & 1;\n        this.F_ZERO = this.REG_Y;\n        break;\n      }\n      case 23: {\n        // *******\n        // * EOR *\n        // *******\n\n        // XOR Memory with accumulator, store in accumulator:\n        this.REG_ACC = (this.load(addr) ^ this.REG_ACC) & 0xff;\n        this.F_SIGN = (this.REG_ACC >> 7) & 1;\n        this.F_ZERO = this.REG_ACC;\n        cycleCount += cycleAdd;\n        break;\n      }\n      case 24: {\n        // *******\n        // * INC *\n        // *******\n\n        // Increment memory by one:\n        temp = (this.load(addr) + 1) & 0xff;\n        this.F_SIGN = (temp >> 7) & 1;\n        this.F_ZERO = temp;\n        this.write(addr, temp & 0xff);\n        break;\n      }\n      case 25: {\n        // *******\n        // * INX *\n        // *******\n\n        // Increment index X by one:\n        this.REG_X = (this.REG_X + 1) & 0xff;\n        this.F_SIGN = (this.REG_X >> 7) & 1;\n        this.F_ZERO = this.REG_X;\n        break;\n      }\n      case 26: {\n        // *******\n        // * INY *\n        // *******\n\n        // Increment index Y by one:\n        this.REG_Y++;\n        this.REG_Y &= 0xff;\n        this.F_SIGN = (this.REG_Y >> 7) & 1;\n        this.F_ZERO = this.REG_Y;\n        break;\n      }\n      case 27: {\n        // *******\n        // * JMP *\n        // *******\n\n        // Jump to new location:\n        this.REG_PC = addr - 1;\n        break;\n      }\n      case 28: {\n        // *******\n        // * JSR *\n        // *******\n\n        // Jump to new location, saving return address.\n        // Push return address on stack:\n        this.push((this.REG_PC >> 8) & 255);\n        this.push(this.REG_PC & 255);\n        this.REG_PC = addr - 1;\n        break;\n      }\n      case 29: {\n        // *******\n        // * LDA *\n        // *******\n\n        // Load accumulator with memory:\n        this.REG_ACC = this.load(addr);\n        this.F_SIGN = (this.REG_ACC >> 7) & 1;\n        this.F_ZERO = this.REG_ACC;\n        cycleCount += cycleAdd;\n        break;\n      }\n      case 30: {\n        // *******\n        // * LDX *\n        // *******\n\n        // Load index X with memory:\n        this.REG_X = this.load(addr);\n        this.F_SIGN = (this.REG_X >> 7) & 1;\n        this.F_ZERO = this.REG_X;\n        cycleCount += cycleAdd;\n        break;\n      }\n      case 31: {\n        // *******\n        // * LDY *\n        // *******\n\n        // Load index Y with memory:\n        this.REG_Y = this.load(addr);\n        this.F_SIGN = (this.REG_Y >> 7) & 1;\n        this.F_ZERO = this.REG_Y;\n        cycleCount += cycleAdd;\n        break;\n      }\n      case 32: {\n        // *******\n        // * LSR *\n        // *******\n\n        // Shift right one bit:\n        if (addrMode === 4) {\n          // ADDR_ACC\n\n          temp = this.REG_ACC & 0xff;\n          this.F_CARRY = temp & 1;\n          temp >>= 1;\n          this.REG_ACC = temp;\n        } else {\n          temp = this.load(addr) & 0xff;\n          this.F_CARRY = temp & 1;\n          temp >>= 1;\n          this.write(addr, temp);\n        }\n        this.F_SIGN = 0;\n        this.F_ZERO = temp;\n        break;\n      }\n      case 33: {\n        // *******\n        // * NOP *\n        // *******\n\n        // No OPeration.\n        // Ignore.\n        break;\n      }\n      case 34: {\n        // *******\n        // * ORA *\n        // *******\n\n        // OR memory with accumulator, store in accumulator.\n        temp = (this.load(addr) | this.REG_ACC) & 255;\n        this.F_SIGN = (temp >> 7) & 1;\n        this.F_ZERO = temp;\n        this.REG_ACC = temp;\n        if (addrMode !== 11) cycleCount += cycleAdd; // PostIdxInd = 11\n        break;\n      }\n      case 35: {\n        // *******\n        // * PHA *\n        // *******\n\n        // Push accumulator on stack\n        this.push(this.REG_ACC);\n        break;\n      }\n      case 36: {\n        // *******\n        // * PHP *\n        // *******\n\n        // Push processor status on stack\n        this.F_BRK = 1;\n        this.push(\n          this.F_CARRY |\n            ((this.F_ZERO === 0 ? 1 : 0) << 1) |\n            (this.F_INTERRUPT << 2) |\n            (this.F_DECIMAL << 3) |\n            (this.F_BRK << 4) |\n            (this.F_NOTUSED << 5) |\n            (this.F_OVERFLOW << 6) |\n            (this.F_SIGN << 7)\n        );\n        break;\n      }\n      case 37: {\n        // *******\n        // * PLA *\n        // *******\n\n        // Pull accumulator from stack\n        this.REG_ACC = this.pull();\n        this.F_SIGN = (this.REG_ACC >> 7) & 1;\n        this.F_ZERO = this.REG_ACC;\n        break;\n      }\n      case 38: {\n        // *******\n        // * PLP *\n        // *******\n\n        // Pull processor status from stack\n        temp = this.pull();\n        this.F_CARRY = temp & 1;\n        this.F_ZERO = ((temp >> 1) & 1) === 1 ? 0 : 1;\n        this.F_INTERRUPT = (temp >> 2) & 1;\n        this.F_DECIMAL = (temp >> 3) & 1;\n        this.F_BRK = (temp >> 4) & 1;\n        this.F_NOTUSED = (temp >> 5) & 1;\n        this.F_OVERFLOW = (temp >> 6) & 1;\n        this.F_SIGN = (temp >> 7) & 1;\n\n        this.F_NOTUSED = 1;\n        break;\n      }\n      case 39: {\n        // *******\n        // * ROL *\n        // *******\n\n        // Rotate one bit left\n        if (addrMode === 4) {\n          // ADDR_ACC = 4\n\n          temp = this.REG_ACC;\n          add = this.F_CARRY;\n          this.F_CARRY = (temp >> 7) & 1;\n          temp = ((temp << 1) & 0xff) + add;\n          this.REG_ACC = temp;\n        } else {\n          temp = this.load(addr);\n          add = this.F_CARRY;\n          this.F_CARRY = (temp >> 7) & 1;\n          temp = ((temp << 1) & 0xff) + add;\n          this.write(addr, temp);\n        }\n        this.F_SIGN = (temp >> 7) & 1;\n        this.F_ZERO = temp;\n        break;\n      }\n      case 40: {\n        // *******\n        // * ROR *\n        // *******\n\n        // Rotate one bit right\n        if (addrMode === 4) {\n          // ADDR_ACC = 4\n\n          add = this.F_CARRY << 7;\n          this.F_CARRY = this.REG_ACC & 1;\n          temp = (this.REG_ACC >> 1) + add;\n          this.REG_ACC = temp;\n        } else {\n          temp = this.load(addr);\n          add = this.F_CARRY << 7;\n          this.F_CARRY = temp & 1;\n          temp = (temp >> 1) + add;\n          this.write(addr, temp);\n        }\n        this.F_SIGN = (temp >> 7) & 1;\n        this.F_ZERO = temp;\n        break;\n      }\n      case 41: {\n        // *******\n        // * RTI *\n        // *******\n\n        // Return from interrupt. Pull status and PC from stack.\n\n        temp = this.pull();\n        this.F_CARRY = temp & 1;\n        this.F_ZERO = ((temp >> 1) & 1) === 0 ? 1 : 0;\n        this.F_INTERRUPT = (temp >> 2) & 1;\n        this.F_DECIMAL = (temp >> 3) & 1;\n        this.F_BRK = (temp >> 4) & 1;\n        this.F_NOTUSED = (temp >> 5) & 1;\n        this.F_OVERFLOW = (temp >> 6) & 1;\n        this.F_SIGN = (temp >> 7) & 1;\n\n        this.REG_PC = this.pull();\n        this.REG_PC += this.pull() << 8;\n        if (this.REG_PC === 0xffff) {\n          return;\n        }\n        this.REG_PC--;\n        this.F_NOTUSED = 1;\n        break;\n      }\n      case 42: {\n        // *******\n        // * RTS *\n        // *******\n\n        // Return from subroutine. Pull PC from stack.\n\n        this.REG_PC = this.pull();\n        this.REG_PC += this.pull() << 8;\n\n        if (this.REG_PC === 0xffff) {\n          return; // return from NSF play routine:\n        }\n        break;\n      }\n      case 43: {\n        // *******\n        // * SBC *\n        // *******\n\n        temp = this.REG_ACC - this.load(addr) - (1 - this.F_CARRY);\n        this.F_SIGN = (temp >> 7) & 1;\n        this.F_ZERO = temp & 0xff;\n        if (\n          ((this.REG_ACC ^ temp) & 0x80) !== 0 &&\n          ((this.REG_ACC ^ this.load(addr)) & 0x80) !== 0\n        ) {\n          this.F_OVERFLOW = 1;\n        } else {\n          this.F_OVERFLOW = 0;\n        }\n        this.F_CARRY = temp < 0 ? 0 : 1;\n        this.REG_ACC = temp & 0xff;\n        if (addrMode !== 11) cycleCount += cycleAdd; // PostIdxInd = 11\n        break;\n      }\n      case 44: {\n        // *******\n        // * SEC *\n        // *******\n\n        // Set carry flag\n        this.F_CARRY = 1;\n        break;\n      }\n      case 45: {\n        // *******\n        // * SED *\n        // *******\n\n        // Set decimal mode\n        this.F_DECIMAL = 1;\n        break;\n      }\n      case 46: {\n        // *******\n        // * SEI *\n        // *******\n\n        // Set interrupt disable status\n        this.F_INTERRUPT = 1;\n        break;\n      }\n      case 47: {\n        // *******\n        // * STA *\n        // *******\n\n        // Store accumulator in memory\n        this.write(addr, this.REG_ACC);\n        break;\n      }\n      case 48: {\n        // *******\n        // * STX *\n        // *******\n\n        // Store index X in memory\n        this.write(addr, this.REG_X);\n        break;\n      }\n      case 49: {\n        // *******\n        // * STY *\n        // *******\n\n        // Store index Y in memory:\n        this.write(addr, this.REG_Y);\n        break;\n      }\n      case 50: {\n        // *******\n        // * TAX *\n        // *******\n\n        // Transfer accumulator to index X:\n        this.REG_X = this.REG_ACC;\n        this.F_SIGN = (this.REG_ACC >> 7) & 1;\n        this.F_ZERO = this.REG_ACC;\n        break;\n      }\n      case 51: {\n        // *******\n        // * TAY *\n        // *******\n\n        // Transfer accumulator to index Y:\n        this.REG_Y = this.REG_ACC;\n        this.F_SIGN = (this.REG_ACC >> 7) & 1;\n        this.F_ZERO = this.REG_ACC;\n        break;\n      }\n      case 52: {\n        // *******\n        // * TSX *\n        // *******\n\n        // Transfer stack pointer to index X:\n        this.REG_X = this.REG_SP - 0x0100;\n        this.F_SIGN = (this.REG_SP >> 7) & 1;\n        this.F_ZERO = this.REG_X;\n        break;\n      }\n      case 53: {\n        // *******\n        // * TXA *\n        // *******\n\n        // Transfer index X to accumulator:\n        this.REG_ACC = this.REG_X;\n        this.F_SIGN = (this.REG_X >> 7) & 1;\n        this.F_ZERO = this.REG_X;\n        break;\n      }\n      case 54: {\n        // *******\n        // * TXS *\n        // *******\n\n        // Transfer index X to stack pointer:\n        this.REG_SP = this.REG_X + 0x0100;\n        this.stackWrap();\n        break;\n      }\n      case 55: {\n        // *******\n        // * TYA *\n        // *******\n\n        // Transfer index Y to accumulator:\n        this.REG_ACC = this.REG_Y;\n        this.F_SIGN = (this.REG_Y >> 7) & 1;\n        this.F_ZERO = this.REG_Y;\n        break;\n      }\n      default: {\n        // *******\n        // * ??? *\n        // *******\n\n        this.nes.stop();\n        this.nes.crashMessage =\n          \"Game crashed, invalid opcode at address $\" + opaddr.toString(16);\n        break;\n      }\n    } // end of switch\n\n    return cycleCount;\n  },\n\n  loadFromCartridge: function(addr) {\n    var value = this.nes.mmap.load(addr);\n\n    if (this.nes.gameGenie.enabled) {\n      value = this.nes.gameGenie.applyCodes(addr, value);\n    }\n\n    return value;\n  },\n\n  load: function(addr) {\n    if (addr < 0x2000) {\n      return this.mem[addr & 0x7ff];\n    } else {\n      return this.loadFromCartridge(addr);\n    }\n  },\n\n  load16bit: function(addr) {\n    if (addr < 0x1fff) {\n      return this.mem[addr & 0x7ff] | (this.mem[(addr + 1) & 0x7ff] << 8);\n    } else {\n      return this.loadFromCartridge(addr) | (this.loadFromCartridge(addr + 1) << 8);\n    }\n  },\n\n  write: function(addr, val) {\n    if (addr < 0x2000) {\n      this.mem[addr & 0x7ff] = val;\n    } else {\n      this.nes.mmap.write(addr, val);\n    }\n  },\n\n  requestIrq: function(type) {\n    if (this.irqRequested) {\n      if (type === this.IRQ_NORMAL) {\n        return;\n      }\n      // console.log(\"too fast irqs. type=\"+type);\n    }\n    this.irqRequested = true;\n    this.irqType = type;\n  },\n\n  push: function(value) {\n    this.nes.mmap.write(this.REG_SP, value);\n    this.REG_SP--;\n    this.REG_SP = 0x0100 | (this.REG_SP & 0xff);\n  },\n\n  stackWrap: function() {\n    this.REG_SP = 0x0100 | (this.REG_SP & 0xff);\n  },\n\n  pull: function() {\n    this.REG_SP++;\n    this.REG_SP = 0x0100 | (this.REG_SP & 0xff);\n    return this.nes.mmap.load(this.REG_SP);\n  },\n\n  pageCrossed: function(addr1, addr2) {\n    return (addr1 & 0xff00) !== (addr2 & 0xff00);\n  },\n\n  haltCycles: function(cycles) {\n    this.cyclesToHalt += cycles;\n  },\n\n  doNonMaskableInterrupt: function(status) {\n    if ((this.nes.mmap.load(0x2000) & 128) !== 0) {\n      // Check whether VBlank Interrupts are enabled\n\n      this.REG_PC_NEW++;\n      this.push((this.REG_PC_NEW >> 8) & 0xff);\n      this.push(this.REG_PC_NEW & 0xff);\n      //this.F_INTERRUPT_NEW = 1;\n      this.push(status);\n\n      this.REG_PC_NEW =\n        this.loadFromCartridge(0xfffa) | (this.loadFromCartridge(0xfffb) << 8);\n      this.REG_PC_NEW--;\n    }\n  },\n\n  doResetInterrupt: function() {\n    this.REG_PC_NEW =\n      this.loadFromCartridge(0xfffc) | (this.loadFromCartridge(0xfffd) << 8);\n    this.REG_PC_NEW--;\n  },\n\n  doIrq: function(status) {\n    this.REG_PC_NEW++;\n    this.push((this.REG_PC_NEW >> 8) & 0xff);\n    this.push(this.REG_PC_NEW & 0xff);\n    this.push(status);\n    this.F_INTERRUPT_NEW = 1;\n    this.F_BRK_NEW = 0;\n\n    this.REG_PC_NEW =\n      this.loadFromCartridge(0xfffe) | (this.loadFromCartridge(0xffff) << 8);\n    this.REG_PC_NEW--;\n  },\n\n  getStatus: function() {\n    return (\n      this.F_CARRY |\n      (this.F_ZERO << 1) |\n      (this.F_INTERRUPT << 2) |\n      (this.F_DECIMAL << 3) |\n      (this.F_BRK << 4) |\n      (this.F_NOTUSED << 5) |\n      (this.F_OVERFLOW << 6) |\n      (this.F_SIGN << 7)\n    );\n  },\n\n  setStatus: function(st) {\n    this.F_CARRY = st & 1;\n    this.F_ZERO = (st >> 1) & 1;\n    this.F_INTERRUPT = (st >> 2) & 1;\n    this.F_DECIMAL = (st >> 3) & 1;\n    this.F_BRK = (st >> 4) & 1;\n    this.F_NOTUSED = (st >> 5) & 1;\n    this.F_OVERFLOW = (st >> 6) & 1;\n    this.F_SIGN = (st >> 7) & 1;\n  },\n\n  JSON_PROPERTIES: [\n    \"mem\",\n    \"cyclesToHalt\",\n    \"irqRequested\",\n    \"irqType\",\n    // Registers\n    \"REG_ACC\",\n    \"REG_X\",\n    \"REG_Y\",\n    \"REG_SP\",\n    \"REG_PC\",\n    \"REG_PC_NEW\",\n    \"REG_STATUS\",\n    // Status\n    \"F_CARRY\",\n    \"F_DECIMAL\",\n    \"F_INTERRUPT\",\n    \"F_INTERRUPT_NEW\",\n    \"F_OVERFLOW\",\n    \"F_SIGN\",\n    \"F_ZERO\",\n    \"F_NOTUSED\",\n    \"F_NOTUSED_NEW\",\n    \"F_BRK\",\n    \"F_BRK_NEW\"\n  ],\n\n  toJSON: function() {\n    return utils.toJSON(this);\n  },\n\n  fromJSON: function(s) {\n    utils.fromJSON(this, s);\n  }\n};\n\n// Generates and provides an array of details about instructions\nvar OpData = function() {\n  this.opdata = new Array(256);\n\n  // Set all to invalid instruction (to detect crashes):\n  for (var i = 0; i < 256; i++) this.opdata[i] = 0xff;\n\n  // Now fill in all valid opcodes:\n\n  // ADC:\n  this.setOp(this.INS_ADC, 0x69, this.ADDR_IMM, 2, 2);\n  this.setOp(this.INS_ADC, 0x65, this.ADDR_ZP, 2, 3);\n  this.setOp(this.INS_ADC, 0x75, this.ADDR_ZPX, 2, 4);\n  this.setOp(this.INS_ADC, 0x6d, this.ADDR_ABS, 3, 4);\n  this.setOp(this.INS_ADC, 0x7d, this.ADDR_ABSX, 3, 4);\n  this.setOp(this.INS_ADC, 0x79, this.ADDR_ABSY, 3, 4);\n  this.setOp(this.INS_ADC, 0x61, this.ADDR_PREIDXIND, 2, 6);\n  this.setOp(this.INS_ADC, 0x71, this.ADDR_POSTIDXIND, 2, 5);\n\n  // AND:\n  this.setOp(this.INS_AND, 0x29, this.ADDR_IMM, 2, 2);\n  this.setOp(this.INS_AND, 0x25, this.ADDR_ZP, 2, 3);\n  this.setOp(this.INS_AND, 0x35, this.ADDR_ZPX, 2, 4);\n  this.setOp(this.INS_AND, 0x2d, this.ADDR_ABS, 3, 4);\n  this.setOp(this.INS_AND, 0x3d, this.ADDR_ABSX, 3, 4);\n  this.setOp(this.INS_AND, 0x39, this.ADDR_ABSY, 3, 4);\n  this.setOp(this.INS_AND, 0x21, this.ADDR_PREIDXIND, 2, 6);\n  this.setOp(this.INS_AND, 0x31, this.ADDR_POSTIDXIND, 2, 5);\n\n  // ASL:\n  this.setOp(this.INS_ASL, 0x0a, this.ADDR_ACC, 1, 2);\n  this.setOp(this.INS_ASL, 0x06, this.ADDR_ZP, 2, 5);\n  this.setOp(this.INS_ASL, 0x16, this.ADDR_ZPX, 2, 6);\n  this.setOp(this.INS_ASL, 0x0e, this.ADDR_ABS, 3, 6);\n  this.setOp(this.INS_ASL, 0x1e, this.ADDR_ABSX, 3, 7);\n\n  // BCC:\n  this.setOp(this.INS_BCC, 0x90, this.ADDR_REL, 2, 2);\n\n  // BCS:\n  this.setOp(this.INS_BCS, 0xb0, this.ADDR_REL, 2, 2);\n\n  // BEQ:\n  this.setOp(this.INS_BEQ, 0xf0, this.ADDR_REL, 2, 2);\n\n  // BIT:\n  this.setOp(this.INS_BIT, 0x24, this.ADDR_ZP, 2, 3);\n  this.setOp(this.INS_BIT, 0x2c, this.ADDR_ABS, 3, 4);\n\n  // BMI:\n  this.setOp(this.INS_BMI, 0x30, this.ADDR_REL, 2, 2);\n\n  // BNE:\n  this.setOp(this.INS_BNE, 0xd0, this.ADDR_REL, 2, 2);\n\n  // BPL:\n  this.setOp(this.INS_BPL, 0x10, this.ADDR_REL, 2, 2);\n\n  // BRK:\n  this.setOp(this.INS_BRK, 0x00, this.ADDR_IMP, 1, 7);\n\n  // BVC:\n  this.setOp(this.INS_BVC, 0x50, this.ADDR_REL, 2, 2);\n\n  // BVS:\n  this.setOp(this.INS_BVS, 0x70, this.ADDR_REL, 2, 2);\n\n  // CLC:\n  this.setOp(this.INS_CLC, 0x18, this.ADDR_IMP, 1, 2);\n\n  // CLD:\n  this.setOp(this.INS_CLD, 0xd8, this.ADDR_IMP, 1, 2);\n\n  // CLI:\n  this.setOp(this.INS_CLI, 0x58, this.ADDR_IMP, 1, 2);\n\n  // CLV:\n  this.setOp(this.INS_CLV, 0xb8, this.ADDR_IMP, 1, 2);\n\n  // CMP:\n  this.setOp(this.INS_CMP, 0xc9, this.ADDR_IMM, 2, 2);\n  this.setOp(this.INS_CMP, 0xc5, this.ADDR_ZP, 2, 3);\n  this.setOp(this.INS_CMP, 0xd5, this.ADDR_ZPX, 2, 4);\n  this.setOp(this.INS_CMP, 0xcd, this.ADDR_ABS, 3, 4);\n  this.setOp(this.INS_CMP, 0xdd, this.ADDR_ABSX, 3, 4);\n  this.setOp(this.INS_CMP, 0xd9, this.ADDR_ABSY, 3, 4);\n  this.setOp(this.INS_CMP, 0xc1, this.ADDR_PREIDXIND, 2, 6);\n  this.setOp(this.INS_CMP, 0xd1, this.ADDR_POSTIDXIND, 2, 5);\n\n  // CPX:\n  this.setOp(this.INS_CPX, 0xe0, this.ADDR_IMM, 2, 2);\n  this.setOp(this.INS_CPX, 0xe4, this.ADDR_ZP, 2, 3);\n  this.setOp(this.INS_CPX, 0xec, this.ADDR_ABS, 3, 4);\n\n  // CPY:\n  this.setOp(this.INS_CPY, 0xc0, this.ADDR_IMM, 2, 2);\n  this.setOp(this.INS_CPY, 0xc4, this.ADDR_ZP, 2, 3);\n  this.setOp(this.INS_CPY, 0xcc, this.ADDR_ABS, 3, 4);\n\n  // DEC:\n  this.setOp(this.INS_DEC, 0xc6, this.ADDR_ZP, 2, 5);\n  this.setOp(this.INS_DEC, 0xd6, this.ADDR_ZPX, 2, 6);\n  this.setOp(this.INS_DEC, 0xce, this.ADDR_ABS, 3, 6);\n  this.setOp(this.INS_DEC, 0xde, this.ADDR_ABSX, 3, 7);\n\n  // DEX:\n  this.setOp(this.INS_DEX, 0xca, this.ADDR_IMP, 1, 2);\n\n  // DEY:\n  this.setOp(this.INS_DEY, 0x88, this.ADDR_IMP, 1, 2);\n\n  // EOR:\n  this.setOp(this.INS_EOR, 0x49, this.ADDR_IMM, 2, 2);\n  this.setOp(this.INS_EOR, 0x45, this.ADDR_ZP, 2, 3);\n  this.setOp(this.INS_EOR, 0x55, this.ADDR_ZPX, 2, 4);\n  this.setOp(this.INS_EOR, 0x4d, this.ADDR_ABS, 3, 4);\n  this.setOp(this.INS_EOR, 0x5d, this.ADDR_ABSX, 3, 4);\n  this.setOp(this.INS_EOR, 0x59, this.ADDR_ABSY, 3, 4);\n  this.setOp(this.INS_EOR, 0x41, this.ADDR_PREIDXIND, 2, 6);\n  this.setOp(this.INS_EOR, 0x51, this.ADDR_POSTIDXIND, 2, 5);\n\n  // INC:\n  this.setOp(this.INS_INC, 0xe6, this.ADDR_ZP, 2, 5);\n  this.setOp(this.INS_INC, 0xf6, this.ADDR_ZPX, 2, 6);\n  this.setOp(this.INS_INC, 0xee, this.ADDR_ABS, 3, 6);\n  this.setOp(this.INS_INC, 0xfe, this.ADDR_ABSX, 3, 7);\n\n  // INX:\n  this.setOp(this.INS_INX, 0xe8, this.ADDR_IMP, 1, 2);\n\n  // INY:\n  this.setOp(this.INS_INY, 0xc8, this.ADDR_IMP, 1, 2);\n\n  // JMP:\n  this.setOp(this.INS_JMP, 0x4c, this.ADDR_ABS, 3, 3);\n  this.setOp(this.INS_JMP, 0x6c, this.ADDR_INDABS, 3, 5);\n\n  // JSR:\n  this.setOp(this.INS_JSR, 0x20, this.ADDR_ABS, 3, 6);\n\n  // LDA:\n  this.setOp(this.INS_LDA, 0xa9, this.ADDR_IMM, 2, 2);\n  this.setOp(this.INS_LDA, 0xa5, this.ADDR_ZP, 2, 3);\n  this.setOp(this.INS_LDA, 0xb5, this.ADDR_ZPX, 2, 4);\n  this.setOp(this.INS_LDA, 0xad, this.ADDR_ABS, 3, 4);\n  this.setOp(this.INS_LDA, 0xbd, this.ADDR_ABSX, 3, 4);\n  this.setOp(this.INS_LDA, 0xb9, this.ADDR_ABSY, 3, 4);\n  this.setOp(this.INS_LDA, 0xa1, this.ADDR_PREIDXIND, 2, 6);\n  this.setOp(this.INS_LDA, 0xb1, this.ADDR_POSTIDXIND, 2, 5);\n\n  // LDX:\n  this.setOp(this.INS_LDX, 0xa2, this.ADDR_IMM, 2, 2);\n  this.setOp(this.INS_LDX, 0xa6, this.ADDR_ZP, 2, 3);\n  this.setOp(this.INS_LDX, 0xb6, this.ADDR_ZPY, 2, 4);\n  this.setOp(this.INS_LDX, 0xae, this.ADDR_ABS, 3, 4);\n  this.setOp(this.INS_LDX, 0xbe, this.ADDR_ABSY, 3, 4);\n\n  // LDY:\n  this.setOp(this.INS_LDY, 0xa0, this.ADDR_IMM, 2, 2);\n  this.setOp(this.INS_LDY, 0xa4, this.ADDR_ZP, 2, 3);\n  this.setOp(this.INS_LDY, 0xb4, this.ADDR_ZPX, 2, 4);\n  this.setOp(this.INS_LDY, 0xac, this.ADDR_ABS, 3, 4);\n  this.setOp(this.INS_LDY, 0xbc, this.ADDR_ABSX, 3, 4);\n\n  // LSR:\n  this.setOp(this.INS_LSR, 0x4a, this.ADDR_ACC, 1, 2);\n  this.setOp(this.INS_LSR, 0x46, this.ADDR_ZP, 2, 5);\n  this.setOp(this.INS_LSR, 0x56, this.ADDR_ZPX, 2, 6);\n  this.setOp(this.INS_LSR, 0x4e, this.ADDR_ABS, 3, 6);\n  this.setOp(this.INS_LSR, 0x5e, this.ADDR_ABSX, 3, 7);\n\n  // NOP:\n  this.setOp(this.INS_NOP, 0xea, this.ADDR_IMP, 1, 2);\n\n  // ORA:\n  this.setOp(this.INS_ORA, 0x09, this.ADDR_IMM, 2, 2);\n  this.setOp(this.INS_ORA, 0x05, this.ADDR_ZP, 2, 3);\n  this.setOp(this.INS_ORA, 0x15, this.ADDR_ZPX, 2, 4);\n  this.setOp(this.INS_ORA, 0x0d, this.ADDR_ABS, 3, 4);\n  this.setOp(this.INS_ORA, 0x1d, this.ADDR_ABSX, 3, 4);\n  this.setOp(this.INS_ORA, 0x19, this.ADDR_ABSY, 3, 4);\n  this.setOp(this.INS_ORA, 0x01, this.ADDR_PREIDXIND, 2, 6);\n  this.setOp(this.INS_ORA, 0x11, this.ADDR_POSTIDXIND, 2, 5);\n\n  // PHA:\n  this.setOp(this.INS_PHA, 0x48, this.ADDR_IMP, 1, 3);\n\n  // PHP:\n  this.setOp(this.INS_PHP, 0x08, this.ADDR_IMP, 1, 3);\n\n  // PLA:\n  this.setOp(this.INS_PLA, 0x68, this.ADDR_IMP, 1, 4);\n\n  // PLP:\n  this.setOp(this.INS_PLP, 0x28, this.ADDR_IMP, 1, 4);\n\n  // ROL:\n  this.setOp(this.INS_ROL, 0x2a, this.ADDR_ACC, 1, 2);\n  this.setOp(this.INS_ROL, 0x26, this.ADDR_ZP, 2, 5);\n  this.setOp(this.INS_ROL, 0x36, this.ADDR_ZPX, 2, 6);\n  this.setOp(this.INS_ROL, 0x2e, this.ADDR_ABS, 3, 6);\n  this.setOp(this.INS_ROL, 0x3e, this.ADDR_ABSX, 3, 7);\n\n  // ROR:\n  this.setOp(this.INS_ROR, 0x6a, this.ADDR_ACC, 1, 2);\n  this.setOp(this.INS_ROR, 0x66, this.ADDR_ZP, 2, 5);\n  this.setOp(this.INS_ROR, 0x76, this.ADDR_ZPX, 2, 6);\n  this.setOp(this.INS_ROR, 0x6e, this.ADDR_ABS, 3, 6);\n  this.setOp(this.INS_ROR, 0x7e, this.ADDR_ABSX, 3, 7);\n\n  // RTI:\n  this.setOp(this.INS_RTI, 0x40, this.ADDR_IMP, 1, 6);\n\n  // RTS:\n  this.setOp(this.INS_RTS, 0x60, this.ADDR_IMP, 1, 6);\n\n  // SBC:\n  this.setOp(this.INS_SBC, 0xe9, this.ADDR_IMM, 2, 2);\n  this.setOp(this.INS_SBC, 0xe5, this.ADDR_ZP, 2, 3);\n  this.setOp(this.INS_SBC, 0xf5, this.ADDR_ZPX, 2, 4);\n  this.setOp(this.INS_SBC, 0xed, this.ADDR_ABS, 3, 4);\n  this.setOp(this.INS_SBC, 0xfd, this.ADDR_ABSX, 3, 4);\n  this.setOp(this.INS_SBC, 0xf9, this.ADDR_ABSY, 3, 4);\n  this.setOp(this.INS_SBC, 0xe1, this.ADDR_PREIDXIND, 2, 6);\n  this.setOp(this.INS_SBC, 0xf1, this.ADDR_POSTIDXIND, 2, 5);\n\n  // SEC:\n  this.setOp(this.INS_SEC, 0x38, this.ADDR_IMP, 1, 2);\n\n  // SED:\n  this.setOp(this.INS_SED, 0xf8, this.ADDR_IMP, 1, 2);\n\n  // SEI:\n  this.setOp(this.INS_SEI, 0x78, this.ADDR_IMP, 1, 2);\n\n  // STA:\n  this.setOp(this.INS_STA, 0x85, this.ADDR_ZP, 2, 3);\n  this.setOp(this.INS_STA, 0x95, this.ADDR_ZPX, 2, 4);\n  this.setOp(this.INS_STA, 0x8d, this.ADDR_ABS, 3, 4);\n  this.setOp(this.INS_STA, 0x9d, this.ADDR_ABSX, 3, 5);\n  this.setOp(this.INS_STA, 0x99, this.ADDR_ABSY, 3, 5);\n  this.setOp(this.INS_STA, 0x81, this.ADDR_PREIDXIND, 2, 6);\n  this.setOp(this.INS_STA, 0x91, this.ADDR_POSTIDXIND, 2, 6);\n\n  // STX:\n  this.setOp(this.INS_STX, 0x86, this.ADDR_ZP, 2, 3);\n  this.setOp(this.INS_STX, 0x96, this.ADDR_ZPY, 2, 4);\n  this.setOp(this.INS_STX, 0x8e, this.ADDR_ABS, 3, 4);\n\n  // STY:\n  this.setOp(this.INS_STY, 0x84, this.ADDR_ZP, 2, 3);\n  this.setOp(this.INS_STY, 0x94, this.ADDR_ZPX, 2, 4);\n  this.setOp(this.INS_STY, 0x8c, this.ADDR_ABS, 3, 4);\n\n  // TAX:\n  this.setOp(this.INS_TAX, 0xaa, this.ADDR_IMP, 1, 2);\n\n  // TAY:\n  this.setOp(this.INS_TAY, 0xa8, this.ADDR_IMP, 1, 2);\n\n  // TSX:\n  this.setOp(this.INS_TSX, 0xba, this.ADDR_IMP, 1, 2);\n\n  // TXA:\n  this.setOp(this.INS_TXA, 0x8a, this.ADDR_IMP, 1, 2);\n\n  // TXS:\n  this.setOp(this.INS_TXS, 0x9a, this.ADDR_IMP, 1, 2);\n\n  // TYA:\n  this.setOp(this.INS_TYA, 0x98, this.ADDR_IMP, 1, 2);\n\n  // prettier-ignore\n  this.cycTable = new Array(\n    /*0x00*/ 7,6,2,8,3,3,5,5,3,2,2,2,4,4,6,6,\n    /*0x10*/ 2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7,\n    /*0x20*/ 6,6,2,8,3,3,5,5,4,2,2,2,4,4,6,6,\n    /*0x30*/ 2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7,\n    /*0x40*/ 6,6,2,8,3,3,5,5,3,2,2,2,3,4,6,6,\n    /*0x50*/ 2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7,\n    /*0x60*/ 6,6,2,8,3,3,5,5,4,2,2,2,5,4,6,6,\n    /*0x70*/ 2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7,\n    /*0x80*/ 2,6,2,6,3,3,3,3,2,2,2,2,4,4,4,4,\n    /*0x90*/ 2,6,2,6,4,4,4,4,2,5,2,5,5,5,5,5,\n    /*0xA0*/ 2,6,2,6,3,3,3,3,2,2,2,2,4,4,4,4,\n    /*0xB0*/ 2,5,2,5,4,4,4,4,2,4,2,4,4,4,4,4,\n    /*0xC0*/ 2,6,2,8,3,3,5,5,2,2,2,2,4,4,6,6,\n    /*0xD0*/ 2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7,\n    /*0xE0*/ 2,6,3,8,3,3,5,5,2,2,2,2,4,4,6,6,\n    /*0xF0*/ 2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7\n  );\n\n  this.instname = new Array(56);\n\n  // Instruction Names:\n  this.instname[0] = \"ADC\";\n  this.instname[1] = \"AND\";\n  this.instname[2] = \"ASL\";\n  this.instname[3] = \"BCC\";\n  this.instname[4] = \"BCS\";\n  this.instname[5] = \"BEQ\";\n  this.instname[6] = \"BIT\";\n  this.instname[7] = \"BMI\";\n  this.instname[8] = \"BNE\";\n  this.instname[9] = \"BPL\";\n  this.instname[10] = \"BRK\";\n  this.instname[11] = \"BVC\";\n  this.instname[12] = \"BVS\";\n  this.instname[13] = \"CLC\";\n  this.instname[14] = \"CLD\";\n  this.instname[15] = \"CLI\";\n  this.instname[16] = \"CLV\";\n  this.instname[17] = \"CMP\";\n  this.instname[18] = \"CPX\";\n  this.instname[19] = \"CPY\";\n  this.instname[20] = \"DEC\";\n  this.instname[21] = \"DEX\";\n  this.instname[22] = \"DEY\";\n  this.instname[23] = \"EOR\";\n  this.instname[24] = \"INC\";\n  this.instname[25] = \"INX\";\n  this.instname[26] = \"INY\";\n  this.instname[27] = \"JMP\";\n  this.instname[28] = \"JSR\";\n  this.instname[29] = \"LDA\";\n  this.instname[30] = \"LDX\";\n  this.instname[31] = \"LDY\";\n  this.instname[32] = \"LSR\";\n  this.instname[33] = \"NOP\";\n  this.instname[34] = \"ORA\";\n  this.instname[35] = \"PHA\";\n  this.instname[36] = \"PHP\";\n  this.instname[37] = \"PLA\";\n  this.instname[38] = \"PLP\";\n  this.instname[39] = \"ROL\";\n  this.instname[40] = \"ROR\";\n  this.instname[41] = \"RTI\";\n  this.instname[42] = \"RTS\";\n  this.instname[43] = \"SBC\";\n  this.instname[44] = \"SEC\";\n  this.instname[45] = \"SED\";\n  this.instname[46] = \"SEI\";\n  this.instname[47] = \"STA\";\n  this.instname[48] = \"STX\";\n  this.instname[49] = \"STY\";\n  this.instname[50] = \"TAX\";\n  this.instname[51] = \"TAY\";\n  this.instname[52] = \"TSX\";\n  this.instname[53] = \"TXA\";\n  this.instname[54] = \"TXS\";\n  this.instname[55] = \"TYA\";\n\n  this.addrDesc = new Array(\n    \"Zero Page           \",\n    \"Relative            \",\n    \"Implied             \",\n    \"Absolute            \",\n    \"Accumulator         \",\n    \"Immediate           \",\n    \"Zero Page,X         \",\n    \"Zero Page,Y         \",\n    \"Absolute,X          \",\n    \"Absolute,Y          \",\n    \"Preindexed Indirect \",\n    \"Postindexed Indirect\",\n    \"Indirect Absolute   \"\n  );\n};\n\nOpData.prototype = {\n  INS_ADC: 0,\n  INS_AND: 1,\n  INS_ASL: 2,\n\n  INS_BCC: 3,\n  INS_BCS: 4,\n  INS_BEQ: 5,\n  INS_BIT: 6,\n  INS_BMI: 7,\n  INS_BNE: 8,\n  INS_BPL: 9,\n  INS_BRK: 10,\n  INS_BVC: 11,\n  INS_BVS: 12,\n\n  INS_CLC: 13,\n  INS_CLD: 14,\n  INS_CLI: 15,\n  INS_CLV: 16,\n  INS_CMP: 17,\n  INS_CPX: 18,\n  INS_CPY: 19,\n\n  INS_DEC: 20,\n  INS_DEX: 21,\n  INS_DEY: 22,\n\n  INS_EOR: 23,\n\n  INS_INC: 24,\n  INS_INX: 25,\n  INS_INY: 26,\n\n  INS_JMP: 27,\n  INS_JSR: 28,\n\n  INS_LDA: 29,\n  INS_LDX: 30,\n  INS_LDY: 31,\n  INS_LSR: 32,\n\n  INS_NOP: 33,\n\n  INS_ORA: 34,\n\n  INS_PHA: 35,\n  INS_PHP: 36,\n  INS_PLA: 37,\n  INS_PLP: 38,\n\n  INS_ROL: 39,\n  INS_ROR: 40,\n  INS_RTI: 41,\n  INS_RTS: 42,\n\n  INS_SBC: 43,\n  INS_SEC: 44,\n  INS_SED: 45,\n  INS_SEI: 46,\n  INS_STA: 47,\n  INS_STX: 48,\n  INS_STY: 49,\n\n  INS_TAX: 50,\n  INS_TAY: 51,\n  INS_TSX: 52,\n  INS_TXA: 53,\n  INS_TXS: 54,\n  INS_TYA: 55,\n\n  INS_DUMMY: 56, // dummy instruction used for 'halting' the processor some cycles\n\n  // -------------------------------- //\n\n  // Addressing modes:\n  ADDR_ZP: 0,\n  ADDR_REL: 1,\n  ADDR_IMP: 2,\n  ADDR_ABS: 3,\n  ADDR_ACC: 4,\n  ADDR_IMM: 5,\n  ADDR_ZPX: 6,\n  ADDR_ZPY: 7,\n  ADDR_ABSX: 8,\n  ADDR_ABSY: 9,\n  ADDR_PREIDXIND: 10,\n  ADDR_POSTIDXIND: 11,\n  ADDR_INDABS: 12,\n\n  setOp: function(inst, op, addr, size, cycles) {\n    this.opdata[op] =\n      (inst & 0xff) |\n      ((addr & 0xff) << 8) |\n      ((size & 0xff) << 16) |\n      ((cycles & 0xff) << 24);\n  }\n};\n\nmodule.exports = CPU;\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Tile = __webpack_require__(2);\nvar utils = __webpack_require__(0);\n\nvar PPU = function(nes) {\n  this.nes = nes;\n\n  // Keep Chrome happy\n  this.vramMem = null;\n  this.spriteMem = null;\n  this.vramAddress = null;\n  this.vramTmpAddress = null;\n  this.vramBufferedReadValue = null;\n  this.firstWrite = null;\n  this.sramAddress = null;\n  this.currentMirroring = null;\n  this.requestEndFrame = null;\n  this.nmiOk = null;\n  this.dummyCycleToggle = null;\n  this.validTileData = null;\n  this.nmiCounter = null;\n  this.scanlineAlreadyRendered = null;\n  this.f_nmiOnVblank = null;\n  this.f_spriteSize = null;\n  this.f_bgPatternTable = null;\n  this.f_spPatternTable = null;\n  this.f_addrInc = null;\n  this.f_nTblAddress = null;\n  this.f_color = null;\n  this.f_spVisibility = null;\n  this.f_bgVisibility = null;\n  this.f_spClipping = null;\n  this.f_bgClipping = null;\n  this.f_dispType = null;\n  this.cntFV = null;\n  this.cntV = null;\n  this.cntH = null;\n  this.cntVT = null;\n  this.cntHT = null;\n  this.regFV = null;\n  this.regV = null;\n  this.regH = null;\n  this.regVT = null;\n  this.regHT = null;\n  this.regFH = null;\n  this.regS = null;\n  this.curNt = null;\n  this.attrib = null;\n  this.buffer = null;\n  this.bgbuffer = null;\n  this.pixrendered = null;\n\n  this.validTileData = null;\n  this.scantile = null;\n  this.scanline = null;\n  this.lastRenderedScanline = null;\n  this.curX = null;\n  this.sprX = null;\n  this.sprY = null;\n  this.sprTile = null;\n  this.sprCol = null;\n  this.vertFlip = null;\n  this.horiFlip = null;\n  this.bgPriority = null;\n  this.spr0HitX = null;\n  this.spr0HitY = null;\n  this.hitSpr0 = null;\n  this.sprPalette = null;\n  this.imgPalette = null;\n  this.ptTile = null;\n  this.ntable1 = null;\n  this.currentMirroring = null;\n  this.nameTable = null;\n  this.vramMirrorTable = null;\n  this.palTable = null;\n\n  // Rendering Options:\n  this.showSpr0Hit = false;\n  this.clipToTvSize = true;\n\n  this.reset();\n};\n\nPPU.prototype = {\n  // Status flags:\n  STATUS_VRAMWRITE: 4,\n  STATUS_SLSPRITECOUNT: 5,\n  STATUS_SPRITE0HIT: 6,\n  STATUS_VBLANK: 7,\n\n  reset: function() {\n    var i;\n\n    // Memory\n    this.vramMem = new Array(0x8000);\n    this.spriteMem = new Array(0x100);\n    for (i = 0; i < this.vramMem.length; i++) {\n      this.vramMem[i] = 0;\n    }\n    for (i = 0; i < this.spriteMem.length; i++) {\n      this.spriteMem[i] = 0;\n    }\n\n    // VRAM I/O:\n    this.vramAddress = null;\n    this.vramTmpAddress = null;\n    this.vramBufferedReadValue = 0;\n    this.firstWrite = true; // VRAM/Scroll Hi/Lo latch\n\n    // SPR-RAM I/O:\n    this.sramAddress = 0; // 8-bit only.\n\n    this.currentMirroring = -1;\n    this.requestEndFrame = false;\n    this.nmiOk = false;\n    this.dummyCycleToggle = false;\n    this.validTileData = false;\n    this.nmiCounter = 0;\n    this.scanlineAlreadyRendered = null;\n\n    // Control Flags Register 1:\n    this.f_nmiOnVblank = 0; // NMI on VBlank. 0=disable, 1=enable\n    this.f_spriteSize = 0; // Sprite size. 0=8x8, 1=8x16\n    this.f_bgPatternTable = 0; // Background Pattern Table address. 0=0x0000,1=0x1000\n    this.f_spPatternTable = 0; // Sprite Pattern Table address. 0=0x0000,1=0x1000\n    this.f_addrInc = 0; // PPU Address Increment. 0=1,1=32\n    this.f_nTblAddress = 0; // Name Table Address. 0=0x2000,1=0x2400,2=0x2800,3=0x2C00\n\n    // Control Flags Register 2:\n    this.f_color = 0; // Background color. 0=black, 1=blue, 2=green, 4=red\n    this.f_spVisibility = 0; // Sprite visibility. 0=not displayed,1=displayed\n    this.f_bgVisibility = 0; // Background visibility. 0=Not Displayed,1=displayed\n    this.f_spClipping = 0; // Sprite clipping. 0=Sprites invisible in left 8-pixel column,1=No clipping\n    this.f_bgClipping = 0; // Background clipping. 0=BG invisible in left 8-pixel column, 1=No clipping\n    this.f_dispType = 0; // Display type. 0=color, 1=monochrome\n\n    // Counters:\n    this.cntFV = 0;\n    this.cntV = 0;\n    this.cntH = 0;\n    this.cntVT = 0;\n    this.cntHT = 0;\n\n    // Registers:\n    this.regFV = 0;\n    this.regV = 0;\n    this.regH = 0;\n    this.regVT = 0;\n    this.regHT = 0;\n    this.regFH = 0;\n    this.regS = 0;\n\n    // These are temporary variables used in rendering and sound procedures.\n    // Their states outside of those procedures can be ignored.\n    // TODO: the use of this is a bit weird, investigate\n    this.curNt = null;\n\n    // Variables used when rendering:\n    this.attrib = new Array(32);\n    this.buffer = new Array(256 * 240);\n    this.bgbuffer = new Array(256 * 240);\n    this.pixrendered = new Array(256 * 240);\n\n    this.validTileData = null;\n\n    this.scantile = new Array(32);\n\n    // Initialize misc vars:\n    this.scanline = 0;\n    this.lastRenderedScanline = -1;\n    this.curX = 0;\n\n    // Sprite data:\n    this.sprX = new Array(64); // X coordinate\n    this.sprY = new Array(64); // Y coordinate\n    this.sprTile = new Array(64); // Tile Index (into pattern table)\n    this.sprCol = new Array(64); // Upper two bits of color\n    this.vertFlip = new Array(64); // Vertical Flip\n    this.horiFlip = new Array(64); // Horizontal Flip\n    this.bgPriority = new Array(64); // Background priority\n    this.spr0HitX = 0; // Sprite #0 hit X coordinate\n    this.spr0HitY = 0; // Sprite #0 hit Y coordinate\n    this.hitSpr0 = false;\n\n    // Palette data:\n    this.sprPalette = new Array(16);\n    this.imgPalette = new Array(16);\n\n    // Create pattern table tile buffers:\n    this.ptTile = new Array(512);\n    for (i = 0; i < 512; i++) {\n      this.ptTile[i] = new Tile();\n    }\n\n    // Create nametable buffers:\n    // Name table data:\n    this.ntable1 = new Array(4);\n    this.currentMirroring = -1;\n    this.nameTable = new Array(4);\n    for (i = 0; i < 4; i++) {\n      this.nameTable[i] = new NameTable(32, 32, \"Nt\" + i);\n    }\n\n    // Initialize mirroring lookup table:\n    this.vramMirrorTable = new Array(0x8000);\n    for (i = 0; i < 0x8000; i++) {\n      this.vramMirrorTable[i] = i;\n    }\n\n    this.palTable = new PaletteTable();\n    this.palTable.loadNTSCPalette();\n    //this.palTable.loadDefaultPalette();\n\n    this.updateControlReg1(0);\n    this.updateControlReg2(0);\n  },\n\n  // Sets Nametable mirroring.\n  setMirroring: function(mirroring) {\n    if (mirroring === this.currentMirroring) {\n      return;\n    }\n\n    this.currentMirroring = mirroring;\n    this.triggerRendering();\n\n    // Remove mirroring:\n    if (this.vramMirrorTable === null) {\n      this.vramMirrorTable = new Array(0x8000);\n    }\n    for (var i = 0; i < 0x8000; i++) {\n      this.vramMirrorTable[i] = i;\n    }\n\n    // Palette mirroring:\n    this.defineMirrorRegion(0x3f20, 0x3f00, 0x20);\n    this.defineMirrorRegion(0x3f40, 0x3f00, 0x20);\n    this.defineMirrorRegion(0x3f80, 0x3f00, 0x20);\n    this.defineMirrorRegion(0x3fc0, 0x3f00, 0x20);\n\n    // Additional mirroring:\n    this.defineMirrorRegion(0x3000, 0x2000, 0xf00);\n    this.defineMirrorRegion(0x4000, 0x0000, 0x4000);\n\n    if (mirroring === this.nes.rom.HORIZONTAL_MIRRORING) {\n      // Horizontal mirroring.\n\n      this.ntable1[0] = 0;\n      this.ntable1[1] = 0;\n      this.ntable1[2] = 1;\n      this.ntable1[3] = 1;\n\n      this.defineMirrorRegion(0x2400, 0x2000, 0x400);\n      this.defineMirrorRegion(0x2c00, 0x2800, 0x400);\n    } else if (mirroring === this.nes.rom.VERTICAL_MIRRORING) {\n      // Vertical mirroring.\n\n      this.ntable1[0] = 0;\n      this.ntable1[1] = 1;\n      this.ntable1[2] = 0;\n      this.ntable1[3] = 1;\n\n      this.defineMirrorRegion(0x2800, 0x2000, 0x400);\n      this.defineMirrorRegion(0x2c00, 0x2400, 0x400);\n    } else if (mirroring === this.nes.rom.SINGLESCREEN_MIRRORING) {\n      // Single Screen mirroring\n\n      this.ntable1[0] = 0;\n      this.ntable1[1] = 0;\n      this.ntable1[2] = 0;\n      this.ntable1[3] = 0;\n\n      this.defineMirrorRegion(0x2400, 0x2000, 0x400);\n      this.defineMirrorRegion(0x2800, 0x2000, 0x400);\n      this.defineMirrorRegion(0x2c00, 0x2000, 0x400);\n    } else if (mirroring === this.nes.rom.SINGLESCREEN_MIRRORING2) {\n      this.ntable1[0] = 1;\n      this.ntable1[1] = 1;\n      this.ntable1[2] = 1;\n      this.ntable1[3] = 1;\n\n      this.defineMirrorRegion(0x2400, 0x2400, 0x400);\n      this.defineMirrorRegion(0x2800, 0x2400, 0x400);\n      this.defineMirrorRegion(0x2c00, 0x2400, 0x400);\n    } else {\n      // Assume Four-screen mirroring.\n\n      this.ntable1[0] = 0;\n      this.ntable1[1] = 1;\n      this.ntable1[2] = 2;\n      this.ntable1[3] = 3;\n    }\n  },\n\n  // Define a mirrored area in the address lookup table.\n  // Assumes the regions don't overlap.\n  // The 'to' region is the region that is physically in memory.\n  defineMirrorRegion: function(fromStart, toStart, size) {\n    for (var i = 0; i < size; i++) {\n      this.vramMirrorTable[fromStart + i] = toStart + i;\n    }\n  },\n\n  startVBlank: function() {\n    // Do NMI:\n    this.nes.cpu.requestIrq(this.nes.cpu.IRQ_NMI);\n\n    // Make sure everything is rendered:\n    if (this.lastRenderedScanline < 239) {\n      this.renderFramePartially(\n        this.lastRenderedScanline + 1,\n        240 - this.lastRenderedScanline\n      );\n    }\n\n    // End frame:\n    this.endFrame();\n\n    // Reset scanline counter:\n    this.lastRenderedScanline = -1;\n  },\n\n  endScanline: function() {\n    switch (this.scanline) {\n      case 19:\n        // Dummy scanline.\n        // May be variable length:\n        if (this.dummyCycleToggle) {\n          // Remove dead cycle at end of scanline,\n          // for next scanline:\n          this.curX = 1;\n          this.dummyCycleToggle = !this.dummyCycleToggle;\n        }\n        break;\n\n      case 20:\n        // Clear VBlank flag:\n        this.setStatusFlag(this.STATUS_VBLANK, false);\n\n        // Clear Sprite #0 hit flag:\n        this.setStatusFlag(this.STATUS_SPRITE0HIT, false);\n        this.hitSpr0 = false;\n        this.spr0HitX = -1;\n        this.spr0HitY = -1;\n\n        if (this.f_bgVisibility === 1 || this.f_spVisibility === 1) {\n          // Update counters:\n          this.cntFV = this.regFV;\n          this.cntV = this.regV;\n          this.cntH = this.regH;\n          this.cntVT = this.regVT;\n          this.cntHT = this.regHT;\n\n          if (this.f_bgVisibility === 1) {\n            // Render dummy scanline:\n            this.renderBgScanline(false, 0);\n          }\n        }\n\n        if (this.f_bgVisibility === 1 && this.f_spVisibility === 1) {\n          // Check sprite 0 hit for first scanline:\n          this.checkSprite0(0);\n        }\n\n        if (this.f_bgVisibility === 1 || this.f_spVisibility === 1) {\n          // Clock mapper IRQ Counter:\n          this.nes.mmap.clockIrqCounter();\n        }\n        break;\n\n      case 261:\n        // Dead scanline, no rendering.\n        // Set VINT:\n        this.setStatusFlag(this.STATUS_VBLANK, true);\n        this.requestEndFrame = true;\n        this.nmiCounter = 9;\n\n        // Wrap around:\n        this.scanline = -1; // will be incremented to 0\n\n        break;\n\n      default:\n        if (this.scanline >= 21 && this.scanline <= 260) {\n          // Render normally:\n          if (this.f_bgVisibility === 1) {\n            if (!this.scanlineAlreadyRendered) {\n              // update scroll:\n              this.cntHT = this.regHT;\n              this.cntH = this.regH;\n              this.renderBgScanline(true, this.scanline + 1 - 21);\n            }\n            this.scanlineAlreadyRendered = false;\n\n            // Check for sprite 0 (next scanline):\n            if (!this.hitSpr0 && this.f_spVisibility === 1) {\n              if (\n                this.sprX[0] >= -7 &&\n                this.sprX[0] < 256 &&\n                this.sprY[0] + 1 <= this.scanline - 20 &&\n                this.sprY[0] + 1 + (this.f_spriteSize === 0 ? 8 : 16) >=\n                  this.scanline - 20\n              ) {\n                if (this.checkSprite0(this.scanline - 20)) {\n                  this.hitSpr0 = true;\n                }\n              }\n            }\n          }\n\n          if (this.f_bgVisibility === 1 || this.f_spVisibility === 1) {\n            // Clock mapper IRQ Counter:\n            this.nes.mmap.clockIrqCounter();\n          }\n        }\n    }\n\n    this.scanline++;\n    this.regsToAddress();\n    this.cntsToAddress();\n  },\n\n  startFrame: function() {\n    // Set background color:\n    var bgColor = 0;\n\n    if (this.f_dispType === 0) {\n      // Color display.\n      // f_color determines color emphasis.\n      // Use first entry of image palette as BG color.\n      bgColor = this.imgPalette[0];\n    } else {\n      // Monochrome display.\n      // f_color determines the bg color.\n      switch (this.f_color) {\n        case 0:\n          // Black\n          bgColor = 0x00000;\n          break;\n        case 1:\n          // Green\n          bgColor = 0x00ff00;\n          break;\n        case 2:\n          // Blue\n          bgColor = 0xff0000;\n          break;\n        case 3:\n          // Invalid. Use black.\n          bgColor = 0x000000;\n          break;\n        case 4:\n          // Red\n          bgColor = 0x0000ff;\n          break;\n        default:\n          // Invalid. Use black.\n          bgColor = 0x0;\n      }\n    }\n\n    var buffer = this.buffer;\n    var i;\n    for (i = 0; i < 256 * 240; i++) {\n      buffer[i] = bgColor;\n    }\n    var pixrendered = this.pixrendered;\n    for (i = 0; i < pixrendered.length; i++) {\n      pixrendered[i] = 65;\n    }\n  },\n\n  endFrame: function() {\n    var i, x, y;\n    var buffer = this.buffer;\n\n    // Draw spr#0 hit coordinates:\n    if (this.showSpr0Hit) {\n      // Spr 0 position:\n      if (\n        this.sprX[0] >= 0 &&\n        this.sprX[0] < 256 &&\n        this.sprY[0] >= 0 &&\n        this.sprY[0] < 240\n      ) {\n        for (i = 0; i < 256; i++) {\n          buffer[(this.sprY[0] << 8) + i] = 0xff5555;\n        }\n        for (i = 0; i < 240; i++) {\n          buffer[(i << 8) + this.sprX[0]] = 0xff5555;\n        }\n      }\n      // Hit position:\n      if (\n        this.spr0HitX >= 0 &&\n        this.spr0HitX < 256 &&\n        this.spr0HitY >= 0 &&\n        this.spr0HitY < 240\n      ) {\n        for (i = 0; i < 256; i++) {\n          buffer[(this.spr0HitY << 8) + i] = 0x55ff55;\n        }\n        for (i = 0; i < 240; i++) {\n          buffer[(i << 8) + this.spr0HitX] = 0x55ff55;\n        }\n      }\n    }\n\n    // This is a bit lazy..\n    // if either the sprites or the background should be clipped,\n    // both are clipped after rendering is finished.\n    if (\n      this.clipToTvSize ||\n      this.f_bgClipping === 0 ||\n      this.f_spClipping === 0\n    ) {\n      // Clip left 8-pixels column:\n      for (y = 0; y < 240; y++) {\n        for (x = 0; x < 8; x++) {\n          buffer[(y << 8) + x] = 0;\n        }\n      }\n    }\n\n    if (this.clipToTvSize) {\n      // Clip right 8-pixels column too:\n      for (y = 0; y < 240; y++) {\n        for (x = 0; x < 8; x++) {\n          buffer[(y << 8) + 255 - x] = 0;\n        }\n      }\n    }\n\n    // Clip top and bottom 8 pixels:\n    if (this.clipToTvSize) {\n      for (y = 0; y < 8; y++) {\n        for (x = 0; x < 256; x++) {\n          buffer[(y << 8) + x] = 0;\n          buffer[((239 - y) << 8) + x] = 0;\n        }\n      }\n    }\n\n    this.nes.ui.writeFrame(buffer);\n  },\n\n  updateControlReg1: function(value) {\n    this.triggerRendering();\n\n    this.f_nmiOnVblank = (value >> 7) & 1;\n    this.f_spriteSize = (value >> 5) & 1;\n    this.f_bgPatternTable = (value >> 4) & 1;\n    this.f_spPatternTable = (value >> 3) & 1;\n    this.f_addrInc = (value >> 2) & 1;\n    this.f_nTblAddress = value & 3;\n\n    this.regV = (value >> 1) & 1;\n    this.regH = value & 1;\n    this.regS = (value >> 4) & 1;\n  },\n\n  updateControlReg2: function(value) {\n    this.triggerRendering();\n\n    this.f_color = (value >> 5) & 7;\n    this.f_spVisibility = (value >> 4) & 1;\n    this.f_bgVisibility = (value >> 3) & 1;\n    this.f_spClipping = (value >> 2) & 1;\n    this.f_bgClipping = (value >> 1) & 1;\n    this.f_dispType = value & 1;\n\n    if (this.f_dispType === 0) {\n      this.palTable.setEmphasis(this.f_color);\n    }\n    this.updatePalettes();\n  },\n\n  setStatusFlag: function(flag, value) {\n    var n = 1 << flag;\n    this.nes.cpu.mem[0x2002] =\n      (this.nes.cpu.mem[0x2002] & (255 - n)) | (value ? n : 0);\n  },\n\n  // CPU Register $2002:\n  // Read the Status Register.\n  readStatusRegister: function() {\n    var tmp = this.nes.cpu.mem[0x2002];\n\n    // Reset scroll & VRAM Address toggle:\n    this.firstWrite = true;\n\n    // Clear VBlank flag:\n    this.setStatusFlag(this.STATUS_VBLANK, false);\n\n    // Fetch status data:\n    return tmp;\n  },\n\n  // CPU Register $2003:\n  // Write the SPR-RAM address that is used for sramWrite (Register 0x2004 in CPU memory map)\n  writeSRAMAddress: function(address) {\n    this.sramAddress = address;\n  },\n\n  // CPU Register $2004 (R):\n  // Read from SPR-RAM (Sprite RAM).\n  // The address should be set first.\n  sramLoad: function() {\n    /*short tmp = sprMem.load(sramAddress);\n        sramAddress++; // Increment address\n        sramAddress%=0x100;\n        return tmp;*/\n    return this.spriteMem[this.sramAddress];\n  },\n\n  // CPU Register $2004 (W):\n  // Write to SPR-RAM (Sprite RAM).\n  // The address should be set first.\n  sramWrite: function(value) {\n    this.spriteMem[this.sramAddress] = value;\n    this.spriteRamWriteUpdate(this.sramAddress, value);\n    this.sramAddress++; // Increment address\n    this.sramAddress %= 0x100;\n  },\n\n  // CPU Register $2005:\n  // Write to scroll registers.\n  // The first write is the vertical offset, the second is the\n  // horizontal offset:\n  scrollWrite: function(value) {\n    this.triggerRendering();\n\n    if (this.firstWrite) {\n      // First write, horizontal scroll:\n      this.regHT = (value >> 3) & 31;\n      this.regFH = value & 7;\n    } else {\n      // Second write, vertical scroll:\n      this.regFV = value & 7;\n      this.regVT = (value >> 3) & 31;\n    }\n    this.firstWrite = !this.firstWrite;\n  },\n\n  // CPU Register $2006:\n  // Sets the adress used when reading/writing from/to VRAM.\n  // The first write sets the high byte, the second the low byte.\n  writeVRAMAddress: function(address) {\n    if (this.firstWrite) {\n      this.regFV = (address >> 4) & 3;\n      this.regV = (address >> 3) & 1;\n      this.regH = (address >> 2) & 1;\n      this.regVT = (this.regVT & 7) | ((address & 3) << 3);\n    } else {\n      this.triggerRendering();\n\n      this.regVT = (this.regVT & 24) | ((address >> 5) & 7);\n      this.regHT = address & 31;\n\n      this.cntFV = this.regFV;\n      this.cntV = this.regV;\n      this.cntH = this.regH;\n      this.cntVT = this.regVT;\n      this.cntHT = this.regHT;\n\n      this.checkSprite0(this.scanline - 20);\n    }\n\n    this.firstWrite = !this.firstWrite;\n\n    // Invoke mapper latch:\n    this.cntsToAddress();\n    if (this.vramAddress < 0x2000) {\n      this.nes.mmap.latchAccess(this.vramAddress);\n    }\n  },\n\n  // CPU Register $2007(R):\n  // Read from PPU memory. The address should be set first.\n  vramLoad: function() {\n    var tmp;\n\n    this.cntsToAddress();\n    this.regsToAddress();\n\n    // If address is in range 0x0000-0x3EFF, return buffered values:\n    if (this.vramAddress <= 0x3eff) {\n      tmp = this.vramBufferedReadValue;\n\n      // Update buffered value:\n      if (this.vramAddress < 0x2000) {\n        this.vramBufferedReadValue = this.vramMem[this.vramAddress];\n      } else {\n        this.vramBufferedReadValue = this.mirroredLoad(this.vramAddress);\n      }\n\n      // Mapper latch access:\n      if (this.vramAddress < 0x2000) {\n        this.nes.mmap.latchAccess(this.vramAddress);\n      }\n\n      // Increment by either 1 or 32, depending on d2 of Control Register 1:\n      this.vramAddress += this.f_addrInc === 1 ? 32 : 1;\n\n      this.cntsFromAddress();\n      this.regsFromAddress();\n\n      return tmp; // Return the previous buffered value.\n    }\n\n    // No buffering in this mem range. Read normally.\n    tmp = this.mirroredLoad(this.vramAddress);\n\n    // Increment by either 1 or 32, depending on d2 of Control Register 1:\n    this.vramAddress += this.f_addrInc === 1 ? 32 : 1;\n\n    this.cntsFromAddress();\n    this.regsFromAddress();\n\n    return tmp;\n  },\n\n  // CPU Register $2007(W):\n  // Write to PPU memory. The address should be set first.\n  vramWrite: function(value) {\n    this.triggerRendering();\n    this.cntsToAddress();\n    this.regsToAddress();\n\n    if (this.vramAddress >= 0x2000) {\n      // Mirroring is used.\n      this.mirroredWrite(this.vramAddress, value);\n    } else {\n      // Write normally.\n      this.writeMem(this.vramAddress, value);\n\n      // Invoke mapper latch:\n      this.nes.mmap.latchAccess(this.vramAddress);\n    }\n\n    // Increment by either 1 or 32, depending on d2 of Control Register 1:\n    this.vramAddress += this.f_addrInc === 1 ? 32 : 1;\n    this.regsFromAddress();\n    this.cntsFromAddress();\n  },\n\n  // CPU Register $4014:\n  // Write 256 bytes of main memory\n  // into Sprite RAM.\n  sramDMA: function(value) {\n    var baseAddress = value * 0x100;\n    var data;\n    for (var i = this.sramAddress; i < 256; i++) {\n      data = this.nes.cpu.mem[baseAddress + i];\n      this.spriteMem[i] = data;\n      this.spriteRamWriteUpdate(i, data);\n    }\n\n    this.nes.cpu.haltCycles(513);\n  },\n\n  // Updates the scroll registers from a new VRAM address.\n  regsFromAddress: function() {\n    var address = (this.vramTmpAddress >> 8) & 0xff;\n    this.regFV = (address >> 4) & 7;\n    this.regV = (address >> 3) & 1;\n    this.regH = (address >> 2) & 1;\n    this.regVT = (this.regVT & 7) | ((address & 3) << 3);\n\n    address = this.vramTmpAddress & 0xff;\n    this.regVT = (this.regVT & 24) | ((address >> 5) & 7);\n    this.regHT = address & 31;\n  },\n\n  // Updates the scroll registers from a new VRAM address.\n  cntsFromAddress: function() {\n    var address = (this.vramAddress >> 8) & 0xff;\n    this.cntFV = (address >> 4) & 3;\n    this.cntV = (address >> 3) & 1;\n    this.cntH = (address >> 2) & 1;\n    this.cntVT = (this.cntVT & 7) | ((address & 3) << 3);\n\n    address = this.vramAddress & 0xff;\n    this.cntVT = (this.cntVT & 24) | ((address >> 5) & 7);\n    this.cntHT = address & 31;\n  },\n\n  regsToAddress: function() {\n    var b1 = (this.regFV & 7) << 4;\n    b1 |= (this.regV & 1) << 3;\n    b1 |= (this.regH & 1) << 2;\n    b1 |= (this.regVT >> 3) & 3;\n\n    var b2 = (this.regVT & 7) << 5;\n    b2 |= this.regHT & 31;\n\n    this.vramTmpAddress = ((b1 << 8) | b2) & 0x7fff;\n  },\n\n  cntsToAddress: function() {\n    var b1 = (this.cntFV & 7) << 4;\n    b1 |= (this.cntV & 1) << 3;\n    b1 |= (this.cntH & 1) << 2;\n    b1 |= (this.cntVT >> 3) & 3;\n\n    var b2 = (this.cntVT & 7) << 5;\n    b2 |= this.cntHT & 31;\n\n    this.vramAddress = ((b1 << 8) | b2) & 0x7fff;\n  },\n\n  incTileCounter: function(count) {\n    for (var i = count; i !== 0; i--) {\n      this.cntHT++;\n      if (this.cntHT === 32) {\n        this.cntHT = 0;\n        this.cntVT++;\n        if (this.cntVT >= 30) {\n          this.cntH++;\n          if (this.cntH === 2) {\n            this.cntH = 0;\n            this.cntV++;\n            if (this.cntV === 2) {\n              this.cntV = 0;\n              this.cntFV++;\n              this.cntFV &= 0x7;\n            }\n          }\n        }\n      }\n    }\n  },\n\n  // Reads from memory, taking into account\n  // mirroring/mapping of address ranges.\n  mirroredLoad: function(address) {\n    return this.vramMem[this.vramMirrorTable[address]];\n  },\n\n  // Writes to memory, taking into account\n  // mirroring/mapping of address ranges.\n  mirroredWrite: function(address, value) {\n    if (address >= 0x3f00 && address < 0x3f20) {\n      // Palette write mirroring.\n      if (address === 0x3f00 || address === 0x3f10) {\n        this.writeMem(0x3f00, value);\n        this.writeMem(0x3f10, value);\n      } else if (address === 0x3f04 || address === 0x3f14) {\n        this.writeMem(0x3f04, value);\n        this.writeMem(0x3f14, value);\n      } else if (address === 0x3f08 || address === 0x3f18) {\n        this.writeMem(0x3f08, value);\n        this.writeMem(0x3f18, value);\n      } else if (address === 0x3f0c || address === 0x3f1c) {\n        this.writeMem(0x3f0c, value);\n        this.writeMem(0x3f1c, value);\n      } else {\n        this.writeMem(address, value);\n      }\n    } else {\n      // Use lookup table for mirrored address:\n      if (address < this.vramMirrorTable.length) {\n        this.writeMem(this.vramMirrorTable[address], value);\n      } else {\n        throw new Error(\"Invalid VRAM address: \" + address.toString(16));\n      }\n    }\n  },\n\n  triggerRendering: function() {\n    if (this.scanline >= 21 && this.scanline <= 260) {\n      // Render sprites, and combine:\n      this.renderFramePartially(\n        this.lastRenderedScanline + 1,\n        this.scanline - 21 - this.lastRenderedScanline\n      );\n\n      // Set last rendered scanline:\n      this.lastRenderedScanline = this.scanline - 21;\n    }\n  },\n\n  renderFramePartially: function(startScan, scanCount) {\n    if (this.f_spVisibility === 1) {\n      this.renderSpritesPartially(startScan, scanCount, true);\n    }\n\n    if (this.f_bgVisibility === 1) {\n      var si = startScan << 8;\n      var ei = (startScan + scanCount) << 8;\n      if (ei > 0xf000) {\n        ei = 0xf000;\n      }\n      var buffer = this.buffer;\n      var bgbuffer = this.bgbuffer;\n      var pixrendered = this.pixrendered;\n      for (var destIndex = si; destIndex < ei; destIndex++) {\n        if (pixrendered[destIndex] > 0xff) {\n          buffer[destIndex] = bgbuffer[destIndex];\n        }\n      }\n    }\n\n    if (this.f_spVisibility === 1) {\n      this.renderSpritesPartially(startScan, scanCount, false);\n    }\n\n    this.validTileData = false;\n  },\n\n  renderBgScanline: function(bgbuffer, scan) {\n    var baseTile = this.regS === 0 ? 0 : 256;\n    var destIndex = (scan << 8) - this.regFH;\n\n    this.curNt = this.ntable1[this.cntV + this.cntV + this.cntH];\n\n    this.cntHT = this.regHT;\n    this.cntH = this.regH;\n    this.curNt = this.ntable1[this.cntV + this.cntV + this.cntH];\n\n    if (scan < 240 && scan - this.cntFV >= 0) {\n      var tscanoffset = this.cntFV << 3;\n      var scantile = this.scantile;\n      var attrib = this.attrib;\n      var ptTile = this.ptTile;\n      var nameTable = this.nameTable;\n      var imgPalette = this.imgPalette;\n      var pixrendered = this.pixrendered;\n      var targetBuffer = bgbuffer ? this.bgbuffer : this.buffer;\n\n      var t, tpix, att, col;\n\n      for (var tile = 0; tile < 32; tile++) {\n        if (scan >= 0) {\n          // Fetch tile & attrib data:\n          if (this.validTileData) {\n            // Get data from array:\n            t = scantile[tile];\n            if (typeof t === \"undefined\") {\n              continue;\n            }\n            tpix = t.pix;\n            att = attrib[tile];\n          } else {\n            // Fetch data:\n            t =\n              ptTile[\n                baseTile +\n                  nameTable[this.curNt].getTileIndex(this.cntHT, this.cntVT)\n              ];\n            if (typeof t === \"undefined\") {\n              continue;\n            }\n            tpix = t.pix;\n            att = nameTable[this.curNt].getAttrib(this.cntHT, this.cntVT);\n            scantile[tile] = t;\n            attrib[tile] = att;\n          }\n\n          // Render tile scanline:\n          var sx = 0;\n          var x = (tile << 3) - this.regFH;\n\n          if (x > -8) {\n            if (x < 0) {\n              destIndex -= x;\n              sx = -x;\n            }\n            if (t.opaque[this.cntFV]) {\n              for (; sx < 8; sx++) {\n                targetBuffer[destIndex] =\n                  imgPalette[tpix[tscanoffset + sx] + att];\n                pixrendered[destIndex] |= 256;\n                destIndex++;\n              }\n            } else {\n              for (; sx < 8; sx++) {\n                col = tpix[tscanoffset + sx];\n                if (col !== 0) {\n                  targetBuffer[destIndex] = imgPalette[col + att];\n                  pixrendered[destIndex] |= 256;\n                }\n                destIndex++;\n              }\n            }\n          }\n        }\n\n        // Increase Horizontal Tile Counter:\n        if (++this.cntHT === 32) {\n          this.cntHT = 0;\n          this.cntH++;\n          this.cntH %= 2;\n          this.curNt = this.ntable1[(this.cntV << 1) + this.cntH];\n        }\n      }\n\n      // Tile data for one row should now have been fetched,\n      // so the data in the array is valid.\n      this.validTileData = true;\n    }\n\n    // update vertical scroll:\n    this.cntFV++;\n    if (this.cntFV === 8) {\n      this.cntFV = 0;\n      this.cntVT++;\n      if (this.cntVT === 30) {\n        this.cntVT = 0;\n        this.cntV++;\n        this.cntV %= 2;\n        this.curNt = this.ntable1[(this.cntV << 1) + this.cntH];\n      } else if (this.cntVT === 32) {\n        this.cntVT = 0;\n      }\n\n      // Invalidate fetched data:\n      this.validTileData = false;\n    }\n  },\n\n  renderSpritesPartially: function(startscan, scancount, bgPri) {\n    if (this.f_spVisibility === 1) {\n      for (var i = 0; i < 64; i++) {\n        if (\n          this.bgPriority[i] === bgPri &&\n          this.sprX[i] >= 0 &&\n          this.sprX[i] < 256 &&\n          this.sprY[i] + 8 >= startscan &&\n          this.sprY[i] < startscan + scancount\n        ) {\n          // Show sprite.\n          if (this.f_spriteSize === 0) {\n            // 8x8 sprites\n\n            this.srcy1 = 0;\n            this.srcy2 = 8;\n\n            if (this.sprY[i] < startscan) {\n              this.srcy1 = startscan - this.sprY[i] - 1;\n            }\n\n            if (this.sprY[i] + 8 > startscan + scancount) {\n              this.srcy2 = startscan + scancount - this.sprY[i] + 1;\n            }\n\n            if (this.f_spPatternTable === 0) {\n              this.ptTile[this.sprTile[i]].render(\n                this.buffer,\n                0,\n                this.srcy1,\n                8,\n                this.srcy2,\n                this.sprX[i],\n                this.sprY[i] + 1,\n                this.sprCol[i],\n                this.sprPalette,\n                this.horiFlip[i],\n                this.vertFlip[i],\n                i,\n                this.pixrendered\n              );\n            } else {\n              this.ptTile[this.sprTile[i] + 256].render(\n                this.buffer,\n                0,\n                this.srcy1,\n                8,\n                this.srcy2,\n                this.sprX[i],\n                this.sprY[i] + 1,\n                this.sprCol[i],\n                this.sprPalette,\n                this.horiFlip[i],\n                this.vertFlip[i],\n                i,\n                this.pixrendered\n              );\n            }\n          } else {\n            // 8x16 sprites\n            var top = this.sprTile[i];\n            if ((top & 1) !== 0) {\n              top = this.sprTile[i] - 1 + 256;\n            }\n\n            var srcy1 = 0;\n            var srcy2 = 8;\n\n            if (this.sprY[i] < startscan) {\n              srcy1 = startscan - this.sprY[i] - 1;\n            }\n\n            if (this.sprY[i] + 8 > startscan + scancount) {\n              srcy2 = startscan + scancount - this.sprY[i];\n            }\n\n            this.ptTile[top + (this.vertFlip[i] ? 1 : 0)].render(\n              this.buffer,\n              0,\n              srcy1,\n              8,\n              srcy2,\n              this.sprX[i],\n              this.sprY[i] + 1,\n              this.sprCol[i],\n              this.sprPalette,\n              this.horiFlip[i],\n              this.vertFlip[i],\n              i,\n              this.pixrendered\n            );\n\n            srcy1 = 0;\n            srcy2 = 8;\n\n            if (this.sprY[i] + 8 < startscan) {\n              srcy1 = startscan - (this.sprY[i] + 8 + 1);\n            }\n\n            if (this.sprY[i] + 16 > startscan + scancount) {\n              srcy2 = startscan + scancount - (this.sprY[i] + 8);\n            }\n\n            this.ptTile[top + (this.vertFlip[i] ? 0 : 1)].render(\n              this.buffer,\n              0,\n              srcy1,\n              8,\n              srcy2,\n              this.sprX[i],\n              this.sprY[i] + 1 + 8,\n              this.sprCol[i],\n              this.sprPalette,\n              this.horiFlip[i],\n              this.vertFlip[i],\n              i,\n              this.pixrendered\n            );\n          }\n        }\n      }\n    }\n  },\n\n  checkSprite0: function(scan) {\n    this.spr0HitX = -1;\n    this.spr0HitY = -1;\n\n    var toffset;\n    var tIndexAdd = this.f_spPatternTable === 0 ? 0 : 256;\n    var x, y, t, i;\n    var bufferIndex;\n    var col;\n    var bgPri;\n\n    x = this.sprX[0];\n    y = this.sprY[0] + 1;\n\n    if (this.f_spriteSize === 0) {\n      // 8x8 sprites.\n\n      // Check range:\n      if (y <= scan && y + 8 > scan && x >= -7 && x < 256) {\n        // Sprite is in range.\n        // Draw scanline:\n        t = this.ptTile[this.sprTile[0] + tIndexAdd];\n        col = this.sprCol[0];\n        bgPri = this.bgPriority[0];\n\n        if (this.vertFlip[0]) {\n          toffset = 7 - (scan - y);\n        } else {\n          toffset = scan - y;\n        }\n        toffset *= 8;\n\n        bufferIndex = scan * 256 + x;\n        if (this.horiFlip[0]) {\n          for (i = 7; i >= 0; i--) {\n            if (x >= 0 && x < 256) {\n              if (\n                bufferIndex >= 0 &&\n                bufferIndex < 61440 &&\n                this.pixrendered[bufferIndex] !== 0\n              ) {\n                if (t.pix[toffset + i] !== 0) {\n                  this.spr0HitX = bufferIndex % 256;\n                  this.spr0HitY = scan;\n                  return true;\n                }\n              }\n            }\n            x++;\n            bufferIndex++;\n          }\n        } else {\n          for (i = 0; i < 8; i++) {\n            if (x >= 0 && x < 256) {\n              if (\n                bufferIndex >= 0 &&\n                bufferIndex < 61440 &&\n                this.pixrendered[bufferIndex] !== 0\n              ) {\n                if (t.pix[toffset + i] !== 0) {\n                  this.spr0HitX = bufferIndex % 256;\n                  this.spr0HitY = scan;\n                  return true;\n                }\n              }\n            }\n            x++;\n            bufferIndex++;\n          }\n        }\n      }\n    } else {\n      // 8x16 sprites:\n\n      // Check range:\n      if (y <= scan && y + 16 > scan && x >= -7 && x < 256) {\n        // Sprite is in range.\n        // Draw scanline:\n\n        if (this.vertFlip[0]) {\n          toffset = 15 - (scan - y);\n        } else {\n          toffset = scan - y;\n        }\n\n        if (toffset < 8) {\n          // first half of sprite.\n          t = this.ptTile[\n            this.sprTile[0] +\n              (this.vertFlip[0] ? 1 : 0) +\n              ((this.sprTile[0] & 1) !== 0 ? 255 : 0)\n          ];\n        } else {\n          // second half of sprite.\n          t = this.ptTile[\n            this.sprTile[0] +\n              (this.vertFlip[0] ? 0 : 1) +\n              ((this.sprTile[0] & 1) !== 0 ? 255 : 0)\n          ];\n          if (this.vertFlip[0]) {\n            toffset = 15 - toffset;\n          } else {\n            toffset -= 8;\n          }\n        }\n        toffset *= 8;\n        col = this.sprCol[0];\n        bgPri = this.bgPriority[0];\n\n        bufferIndex = scan * 256 + x;\n        if (this.horiFlip[0]) {\n          for (i = 7; i >= 0; i--) {\n            if (x >= 0 && x < 256) {\n              if (\n                bufferIndex >= 0 &&\n                bufferIndex < 61440 &&\n                this.pixrendered[bufferIndex] !== 0\n              ) {\n                if (t.pix[toffset + i] !== 0) {\n                  this.spr0HitX = bufferIndex % 256;\n                  this.spr0HitY = scan;\n                  return true;\n                }\n              }\n            }\n            x++;\n            bufferIndex++;\n          }\n        } else {\n          for (i = 0; i < 8; i++) {\n            if (x >= 0 && x < 256) {\n              if (\n                bufferIndex >= 0 &&\n                bufferIndex < 61440 &&\n                this.pixrendered[bufferIndex] !== 0\n              ) {\n                if (t.pix[toffset + i] !== 0) {\n                  this.spr0HitX = bufferIndex % 256;\n                  this.spr0HitY = scan;\n                  return true;\n                }\n              }\n            }\n            x++;\n            bufferIndex++;\n          }\n        }\n      }\n    }\n\n    return false;\n  },\n\n  // This will write to PPU memory, and\n  // update internally buffered data\n  // appropriately.\n  writeMem: function(address, value) {\n    this.vramMem[address] = value;\n\n    // Update internally buffered data:\n    if (address < 0x2000) {\n      this.vramMem[address] = value;\n      this.patternWrite(address, value);\n    } else if (address >= 0x2000 && address < 0x23c0) {\n      this.nameTableWrite(this.ntable1[0], address - 0x2000, value);\n    } else if (address >= 0x23c0 && address < 0x2400) {\n      this.attribTableWrite(this.ntable1[0], address - 0x23c0, value);\n    } else if (address >= 0x2400 && address < 0x27c0) {\n      this.nameTableWrite(this.ntable1[1], address - 0x2400, value);\n    } else if (address >= 0x27c0 && address < 0x2800) {\n      this.attribTableWrite(this.ntable1[1], address - 0x27c0, value);\n    } else if (address >= 0x2800 && address < 0x2bc0) {\n      this.nameTableWrite(this.ntable1[2], address - 0x2800, value);\n    } else if (address >= 0x2bc0 && address < 0x2c00) {\n      this.attribTableWrite(this.ntable1[2], address - 0x2bc0, value);\n    } else if (address >= 0x2c00 && address < 0x2fc0) {\n      this.nameTableWrite(this.ntable1[3], address - 0x2c00, value);\n    } else if (address >= 0x2fc0 && address < 0x3000) {\n      this.attribTableWrite(this.ntable1[3], address - 0x2fc0, value);\n    } else if (address >= 0x3f00 && address < 0x3f20) {\n      this.updatePalettes();\n    }\n  },\n\n  // Reads data from $3f00 to $f20\n  // into the two buffered palettes.\n  updatePalettes: function() {\n    var i;\n\n    for (i = 0; i < 16; i++) {\n      if (this.f_dispType === 0) {\n        this.imgPalette[i] = this.palTable.getEntry(\n          this.vramMem[0x3f00 + i] & 63\n        );\n      } else {\n        this.imgPalette[i] = this.palTable.getEntry(\n          this.vramMem[0x3f00 + i] & 32\n        );\n      }\n    }\n    for (i = 0; i < 16; i++) {\n      if (this.f_dispType === 0) {\n        this.sprPalette[i] = this.palTable.getEntry(\n          this.vramMem[0x3f10 + i] & 63\n        );\n      } else {\n        this.sprPalette[i] = this.palTable.getEntry(\n          this.vramMem[0x3f10 + i] & 32\n        );\n      }\n    }\n  },\n\n  // Updates the internal pattern\n  // table buffers with this new byte.\n  // In vNES, there is a version of this with 4 arguments which isn't used.\n  patternWrite: function(address, value) {\n    var tileIndex = Math.floor(address / 16);\n    var leftOver = address % 16;\n    if (leftOver < 8) {\n      this.ptTile[tileIndex].setScanline(\n        leftOver,\n        value,\n        this.vramMem[address + 8]\n      );\n    } else {\n      this.ptTile[tileIndex].setScanline(\n        leftOver - 8,\n        this.vramMem[address - 8],\n        value\n      );\n    }\n  },\n\n  // Updates the internal name table buffers\n  // with this new byte.\n  nameTableWrite: function(index, address, value) {\n    this.nameTable[index].tile[address] = value;\n\n    // Update Sprite #0 hit:\n    //updateSpr0Hit();\n    this.checkSprite0(this.scanline - 20);\n  },\n\n  // Updates the internal pattern\n  // table buffers with this new attribute\n  // table byte.\n  attribTableWrite: function(index, address, value) {\n    this.nameTable[index].writeAttrib(address, value);\n  },\n\n  // Updates the internally buffered sprite\n  // data with this new byte of info.\n  spriteRamWriteUpdate: function(address, value) {\n    var tIndex = Math.floor(address / 4);\n\n    if (tIndex === 0) {\n      //updateSpr0Hit();\n      this.checkSprite0(this.scanline - 20);\n    }\n\n    if (address % 4 === 0) {\n      // Y coordinate\n      this.sprY[tIndex] = value;\n    } else if (address % 4 === 1) {\n      // Tile index\n      this.sprTile[tIndex] = value;\n    } else if (address % 4 === 2) {\n      // Attributes\n      this.vertFlip[tIndex] = (value & 0x80) !== 0;\n      this.horiFlip[tIndex] = (value & 0x40) !== 0;\n      this.bgPriority[tIndex] = (value & 0x20) !== 0;\n      this.sprCol[tIndex] = (value & 3) << 2;\n    } else if (address % 4 === 3) {\n      // X coordinate\n      this.sprX[tIndex] = value;\n    }\n  },\n\n  doNMI: function() {\n    // Set VBlank flag:\n    this.setStatusFlag(this.STATUS_VBLANK, true);\n    //nes.getCpu().doNonMaskableInterrupt();\n    this.nes.cpu.requestIrq(this.nes.cpu.IRQ_NMI);\n  },\n\n  isPixelWhite: function(x, y) {\n    this.triggerRendering();\n    return this.nes.ppu.buffer[(y << 8) + x] === 0xffffff;\n  },\n\n  JSON_PROPERTIES: [\n    // Memory\n    \"vramMem\",\n    \"spriteMem\",\n    // Counters\n    \"cntFV\",\n    \"cntV\",\n    \"cntH\",\n    \"cntVT\",\n    \"cntHT\",\n    // Registers\n    \"regFV\",\n    \"regV\",\n    \"regH\",\n    \"regVT\",\n    \"regHT\",\n    \"regFH\",\n    \"regS\",\n    // VRAM addr\n    \"vramAddress\",\n    \"vramTmpAddress\",\n    // Control/Status registers\n    \"f_nmiOnVblank\",\n    \"f_spriteSize\",\n    \"f_bgPatternTable\",\n    \"f_spPatternTable\",\n    \"f_addrInc\",\n    \"f_nTblAddress\",\n    \"f_color\",\n    \"f_spVisibility\",\n    \"f_bgVisibility\",\n    \"f_spClipping\",\n    \"f_bgClipping\",\n    \"f_dispType\",\n    // VRAM I/O\n    \"vramBufferedReadValue\",\n    \"firstWrite\",\n    // Mirroring\n    \"currentMirroring\",\n    \"vramMirrorTable\",\n    \"ntable1\",\n    // SPR-RAM I/O\n    \"sramAddress\",\n    // Sprites. Most sprite data is rebuilt from spriteMem\n    \"hitSpr0\",\n    // Palettes\n    \"sprPalette\",\n    \"imgPalette\",\n    // Rendering progression\n    \"curX\",\n    \"scanline\",\n    \"lastRenderedScanline\",\n    \"curNt\",\n    \"scantile\",\n    // Used during rendering\n    \"attrib\",\n    \"buffer\",\n    \"bgbuffer\",\n    \"pixrendered\",\n    // Misc\n    \"requestEndFrame\",\n    \"nmiOk\",\n    \"dummyCycleToggle\",\n    \"nmiCounter\",\n    \"validTileData\",\n    \"scanlineAlreadyRendered\"\n  ],\n\n  toJSON: function() {\n    var i;\n    var state = utils.toJSON(this);\n\n    state.nameTable = [];\n    for (i = 0; i < this.nameTable.length; i++) {\n      state.nameTable[i] = this.nameTable[i].toJSON();\n    }\n\n    state.ptTile = [];\n    for (i = 0; i < this.ptTile.length; i++) {\n      state.ptTile[i] = this.ptTile[i].toJSON();\n    }\n\n    return state;\n  },\n\n  fromJSON: function(state) {\n    var i;\n\n    utils.fromJSON(this, state);\n\n    for (i = 0; i < this.nameTable.length; i++) {\n      this.nameTable[i].fromJSON(state.nameTable[i]);\n    }\n\n    for (i = 0; i < this.ptTile.length; i++) {\n      this.ptTile[i].fromJSON(state.ptTile[i]);\n    }\n\n    // Sprite data:\n    for (i = 0; i < this.spriteMem.length; i++) {\n      this.spriteRamWriteUpdate(i, this.spriteMem[i]);\n    }\n  }\n};\n\nvar NameTable = function(width, height, name) {\n  this.width = width;\n  this.height = height;\n  this.name = name;\n\n  this.tile = new Array(width * height);\n  this.attrib = new Array(width * height);\n  for (var i = 0; i < width * height; i++) {\n    this.tile[i] = 0;\n    this.attrib[i] = 0;\n  }\n};\n\nNameTable.prototype = {\n  getTileIndex: function(x, y) {\n    return this.tile[y * this.width + x];\n  },\n\n  getAttrib: function(x, y) {\n    return this.attrib[y * this.width + x];\n  },\n\n  writeAttrib: function(index, value) {\n    var basex = (index % 8) * 4;\n    var basey = Math.floor(index / 8) * 4;\n    var add;\n    var tx, ty;\n    var attindex;\n\n    for (var sqy = 0; sqy < 2; sqy++) {\n      for (var sqx = 0; sqx < 2; sqx++) {\n        add = (value >> (2 * (sqy * 2 + sqx))) & 3;\n        for (var y = 0; y < 2; y++) {\n          for (var x = 0; x < 2; x++) {\n            tx = basex + sqx * 2 + x;\n            ty = basey + sqy * 2 + y;\n            attindex = ty * this.width + tx;\n            this.attrib[ty * this.width + tx] = (add << 2) & 12;\n          }\n        }\n      }\n    }\n  },\n\n  toJSON: function() {\n    return {\n      tile: this.tile,\n      attrib: this.attrib\n    };\n  },\n\n  fromJSON: function(s) {\n    this.tile = s.tile;\n    this.attrib = s.attrib;\n  }\n};\n\nvar PaletteTable = function() {\n  this.curTable = new Array(64);\n  this.emphTable = new Array(8);\n  this.currentEmph = -1;\n};\n\nPaletteTable.prototype = {\n  reset: function() {\n    this.setEmphasis(0);\n  },\n\n  loadNTSCPalette: function() {\n    // prettier-ignore\n    this.curTable = [0x525252, 0xB40000, 0xA00000, 0xB1003D, 0x740069, 0x00005B, 0x00005F, 0x001840, 0x002F10, 0x084A08, 0x006700, 0x124200, 0x6D2800, 0x000000, 0x000000, 0x000000, 0xC4D5E7, 0xFF4000, 0xDC0E22, 0xFF476B, 0xD7009F, 0x680AD7, 0x0019BC, 0x0054B1, 0x006A5B, 0x008C03, 0x00AB00, 0x2C8800, 0xA47200, 0x000000, 0x000000, 0x000000, 0xF8F8F8, 0xFFAB3C, 0xFF7981, 0xFF5BC5, 0xFF48F2, 0xDF49FF, 0x476DFF, 0x00B4F7, 0x00E0FF, 0x00E375, 0x03F42B, 0x78B82E, 0xE5E218, 0x787878, 0x000000, 0x000000, 0xFFFFFF, 0xFFF2BE, 0xF8B8B8, 0xF8B8D8, 0xFFB6FF, 0xFFC3FF, 0xC7D1FF, 0x9ADAFF, 0x88EDF8, 0x83FFDD, 0xB8F8B8, 0xF5F8AC, 0xFFFFB0, 0xF8D8F8, 0x000000, 0x000000];\n    this.makeTables();\n    this.setEmphasis(0);\n  },\n\n  loadPALPalette: function() {\n    // prettier-ignore\n    this.curTable = [0x525252, 0xB40000, 0xA00000, 0xB1003D, 0x740069, 0x00005B, 0x00005F, 0x001840, 0x002F10, 0x084A08, 0x006700, 0x124200, 0x6D2800, 0x000000, 0x000000, 0x000000, 0xC4D5E7, 0xFF4000, 0xDC0E22, 0xFF476B, 0xD7009F, 0x680AD7, 0x0019BC, 0x0054B1, 0x006A5B, 0x008C03, 0x00AB00, 0x2C8800, 0xA47200, 0x000000, 0x000000, 0x000000, 0xF8F8F8, 0xFFAB3C, 0xFF7981, 0xFF5BC5, 0xFF48F2, 0xDF49FF, 0x476DFF, 0x00B4F7, 0x00E0FF, 0x00E375, 0x03F42B, 0x78B82E, 0xE5E218, 0x787878, 0x000000, 0x000000, 0xFFFFFF, 0xFFF2BE, 0xF8B8B8, 0xF8B8D8, 0xFFB6FF, 0xFFC3FF, 0xC7D1FF, 0x9ADAFF, 0x88EDF8, 0x83FFDD, 0xB8F8B8, 0xF5F8AC, 0xFFFFB0, 0xF8D8F8, 0x000000, 0x000000];\n    this.makeTables();\n    this.setEmphasis(0);\n  },\n\n  makeTables: function() {\n    var r, g, b, col, i, rFactor, gFactor, bFactor;\n\n    // Calculate a table for each possible emphasis setting:\n    for (var emph = 0; emph < 8; emph++) {\n      // Determine color component factors:\n      rFactor = 1.0;\n      gFactor = 1.0;\n      bFactor = 1.0;\n\n      if ((emph & 1) !== 0) {\n        rFactor = 0.75;\n        bFactor = 0.75;\n      }\n      if ((emph & 2) !== 0) {\n        rFactor = 0.75;\n        gFactor = 0.75;\n      }\n      if ((emph & 4) !== 0) {\n        gFactor = 0.75;\n        bFactor = 0.75;\n      }\n\n      this.emphTable[emph] = new Array(64);\n\n      // Calculate table:\n      for (i = 0; i < 64; i++) {\n        col = this.curTable[i];\n        r = Math.floor(this.getRed(col) * rFactor);\n        g = Math.floor(this.getGreen(col) * gFactor);\n        b = Math.floor(this.getBlue(col) * bFactor);\n        this.emphTable[emph][i] = this.getRgb(r, g, b);\n      }\n    }\n  },\n\n  setEmphasis: function(emph) {\n    if (emph !== this.currentEmph) {\n      this.currentEmph = emph;\n      for (var i = 0; i < 64; i++) {\n        this.curTable[i] = this.emphTable[emph][i];\n      }\n    }\n  },\n\n  getEntry: function(yiq) {\n    return this.curTable[yiq];\n  },\n\n  getRed: function(rgb) {\n    return (rgb >> 16) & 0xff;\n  },\n\n  getGreen: function(rgb) {\n    return (rgb >> 8) & 0xff;\n  },\n\n  getBlue: function(rgb) {\n    return rgb & 0xff;\n  },\n\n  getRgb: function(r, g, b) {\n    return (r << 16) | (g << 8) | b;\n  },\n\n  loadDefaultPalette: function() {\n    this.curTable[0] = this.getRgb(117, 117, 117);\n    this.curTable[1] = this.getRgb(39, 27, 143);\n    this.curTable[2] = this.getRgb(0, 0, 171);\n    this.curTable[3] = this.getRgb(71, 0, 159);\n    this.curTable[4] = this.getRgb(143, 0, 119);\n    this.curTable[5] = this.getRgb(171, 0, 19);\n    this.curTable[6] = this.getRgb(167, 0, 0);\n    this.curTable[7] = this.getRgb(127, 11, 0);\n    this.curTable[8] = this.getRgb(67, 47, 0);\n    this.curTable[9] = this.getRgb(0, 71, 0);\n    this.curTable[10] = this.getRgb(0, 81, 0);\n    this.curTable[11] = this.getRgb(0, 63, 23);\n    this.curTable[12] = this.getRgb(27, 63, 95);\n    this.curTable[13] = this.getRgb(0, 0, 0);\n    this.curTable[14] = this.getRgb(0, 0, 0);\n    this.curTable[15] = this.getRgb(0, 0, 0);\n    this.curTable[16] = this.getRgb(188, 188, 188);\n    this.curTable[17] = this.getRgb(0, 115, 239);\n    this.curTable[18] = this.getRgb(35, 59, 239);\n    this.curTable[19] = this.getRgb(131, 0, 243);\n    this.curTable[20] = this.getRgb(191, 0, 191);\n    this.curTable[21] = this.getRgb(231, 0, 91);\n    this.curTable[22] = this.getRgb(219, 43, 0);\n    this.curTable[23] = this.getRgb(203, 79, 15);\n    this.curTable[24] = this.getRgb(139, 115, 0);\n    this.curTable[25] = this.getRgb(0, 151, 0);\n    this.curTable[26] = this.getRgb(0, 171, 0);\n    this.curTable[27] = this.getRgb(0, 147, 59);\n    this.curTable[28] = this.getRgb(0, 131, 139);\n    this.curTable[29] = this.getRgb(0, 0, 0);\n    this.curTable[30] = this.getRgb(0, 0, 0);\n    this.curTable[31] = this.getRgb(0, 0, 0);\n    this.curTable[32] = this.getRgb(255, 255, 255);\n    this.curTable[33] = this.getRgb(63, 191, 255);\n    this.curTable[34] = this.getRgb(95, 151, 255);\n    this.curTable[35] = this.getRgb(167, 139, 253);\n    this.curTable[36] = this.getRgb(247, 123, 255);\n    this.curTable[37] = this.getRgb(255, 119, 183);\n    this.curTable[38] = this.getRgb(255, 119, 99);\n    this.curTable[39] = this.getRgb(255, 155, 59);\n    this.curTable[40] = this.getRgb(243, 191, 63);\n    this.curTable[41] = this.getRgb(131, 211, 19);\n    this.curTable[42] = this.getRgb(79, 223, 75);\n    this.curTable[43] = this.getRgb(88, 248, 152);\n    this.curTable[44] = this.getRgb(0, 235, 219);\n    this.curTable[45] = this.getRgb(0, 0, 0);\n    this.curTable[46] = this.getRgb(0, 0, 0);\n    this.curTable[47] = this.getRgb(0, 0, 0);\n    this.curTable[48] = this.getRgb(255, 255, 255);\n    this.curTable[49] = this.getRgb(171, 231, 255);\n    this.curTable[50] = this.getRgb(199, 215, 255);\n    this.curTable[51] = this.getRgb(215, 203, 255);\n    this.curTable[52] = this.getRgb(255, 199, 255);\n    this.curTable[53] = this.getRgb(255, 199, 219);\n    this.curTable[54] = this.getRgb(255, 191, 179);\n    this.curTable[55] = this.getRgb(255, 219, 171);\n    this.curTable[56] = this.getRgb(255, 231, 163);\n    this.curTable[57] = this.getRgb(227, 255, 163);\n    this.curTable[58] = this.getRgb(171, 243, 191);\n    this.curTable[59] = this.getRgb(179, 255, 207);\n    this.curTable[60] = this.getRgb(159, 255, 243);\n    this.curTable[61] = this.getRgb(0, 0, 0);\n    this.curTable[62] = this.getRgb(0, 0, 0);\n    this.curTable[63] = this.getRgb(0, 0, 0);\n\n    this.makeTables();\n    this.setEmphasis(0);\n  }\n};\n\nmodule.exports = PPU;\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\nvar CPU_FREQ_NTSC = 1789772.5; //1789772.72727272d;\n// var CPU_FREQ_PAL = 1773447.4;\n\nvar PAPU = function(nes) {\n  this.nes = nes;\n\n  this.square1 = new ChannelSquare(this, true);\n  this.square2 = new ChannelSquare(this, false);\n  this.triangle = new ChannelTriangle(this);\n  this.noise = new ChannelNoise(this);\n  this.dmc = new ChannelDM(this);\n\n  this.frameIrqCounter = null;\n  this.frameIrqCounterMax = 4;\n  this.initCounter = 2048;\n  this.channelEnableValue = null;\n\n  this.sampleRate = 44100;\n\n  this.lengthLookup = null;\n  this.dmcFreqLookup = null;\n  this.noiseWavelengthLookup = null;\n  this.square_table = null;\n  this.tnd_table = null;\n\n  this.frameIrqEnabled = false;\n  this.frameIrqActive = null;\n  this.frameClockNow = null;\n  this.startedPlaying = false;\n  this.recordOutput = false;\n  this.initingHardware = false;\n\n  this.masterFrameCounter = null;\n  this.derivedFrameCounter = null;\n  this.countSequence = null;\n  this.sampleTimer = null;\n  this.frameTime = null;\n  this.sampleTimerMax = null;\n  this.sampleCount = null;\n  this.triValue = 0;\n\n  this.smpSquare1 = null;\n  this.smpSquare2 = null;\n  this.smpTriangle = null;\n  this.smpDmc = null;\n  this.accCount = null;\n\n  // DC removal vars:\n  this.prevSampleL = 0;\n  this.prevSampleR = 0;\n  this.smpAccumL = 0;\n  this.smpAccumR = 0;\n\n  // DAC range:\n  this.dacRange = 0;\n  this.dcValue = 0;\n\n  // Master volume:\n  this.masterVolume = 256;\n\n  // Stereo positioning:\n  this.stereoPosLSquare1 = null;\n  this.stereoPosLSquare2 = null;\n  this.stereoPosLTriangle = null;\n  this.stereoPosLNoise = null;\n  this.stereoPosLDMC = null;\n  this.stereoPosRSquare1 = null;\n  this.stereoPosRSquare2 = null;\n  this.stereoPosRTriangle = null;\n  this.stereoPosRNoise = null;\n  this.stereoPosRDMC = null;\n\n  this.extraCycles = null;\n\n  this.maxSample = null;\n  this.minSample = null;\n\n  // Panning:\n  this.panning = [80, 170, 100, 150, 128];\n  this.setPanning(this.panning);\n\n  // Initialize lookup tables:\n  this.initLengthLookup();\n  this.initDmcFrequencyLookup();\n  this.initNoiseWavelengthLookup();\n  this.initDACtables();\n\n  // Init sound registers:\n  for (var i = 0; i < 0x14; i++) {\n    if (i === 0x10) {\n      this.writeReg(0x4010, 0x10);\n    } else {\n      this.writeReg(0x4000 + i, 0);\n    }\n  }\n\n  this.reset();\n};\n\nPAPU.prototype = {\n  reset: function() {\n    this.sampleRate = this.nes.opts.sampleRate;\n    this.sampleTimerMax = Math.floor(\n      1024.0 *\n        CPU_FREQ_NTSC *\n        this.nes.opts.preferredFrameRate /\n        (this.sampleRate * 60.0)\n    );\n\n    this.frameTime = Math.floor(\n      14915.0 * this.nes.opts.preferredFrameRate / 60.0\n    );\n\n    this.sampleTimer = 0;\n\n    this.updateChannelEnable(0);\n    this.masterFrameCounter = 0;\n    this.derivedFrameCounter = 0;\n    this.countSequence = 0;\n    this.sampleCount = 0;\n    this.initCounter = 2048;\n    this.frameIrqEnabled = false;\n    this.initingHardware = false;\n\n    this.resetCounter();\n\n    this.square1.reset();\n    this.square2.reset();\n    this.triangle.reset();\n    this.noise.reset();\n    this.dmc.reset();\n\n    this.accCount = 0;\n    this.smpSquare1 = 0;\n    this.smpSquare2 = 0;\n    this.smpTriangle = 0;\n    this.smpDmc = 0;\n\n    this.frameIrqEnabled = false;\n    this.frameIrqCounterMax = 4;\n\n    this.channelEnableValue = 0xff;\n    this.startedPlaying = false;\n    this.prevSampleL = 0;\n    this.prevSampleR = 0;\n    this.smpAccumL = 0;\n    this.smpAccumR = 0;\n\n    this.maxSample = -500000;\n    this.minSample = 500000;\n  },\n\n  readReg: function(address) {\n    // Read 0x4015:\n    var tmp = 0;\n    tmp |= this.square1.getLengthStatus();\n    tmp |= this.square2.getLengthStatus() << 1;\n    tmp |= this.triangle.getLengthStatus() << 2;\n    tmp |= this.noise.getLengthStatus() << 3;\n    tmp |= this.dmc.getLengthStatus() << 4;\n    tmp |= (this.frameIrqActive && this.frameIrqEnabled ? 1 : 0) << 6;\n    tmp |= this.dmc.getIrqStatus() << 7;\n\n    this.frameIrqActive = false;\n    this.dmc.irqGenerated = false;\n\n    return tmp & 0xffff;\n  },\n\n  writeReg: function(address, value) {\n    if (address >= 0x4000 && address < 0x4004) {\n      // Square Wave 1 Control\n      this.square1.writeReg(address, value);\n      // console.log(\"Square Write\");\n    } else if (address >= 0x4004 && address < 0x4008) {\n      // Square 2 Control\n      this.square2.writeReg(address, value);\n    } else if (address >= 0x4008 && address < 0x400c) {\n      // Triangle Control\n      this.triangle.writeReg(address, value);\n    } else if (address >= 0x400c && address <= 0x400f) {\n      // Noise Control\n      this.noise.writeReg(address, value);\n    } else if (address === 0x4010) {\n      // DMC Play mode & DMA frequency\n      this.dmc.writeReg(address, value);\n    } else if (address === 0x4011) {\n      // DMC Delta Counter\n      this.dmc.writeReg(address, value);\n    } else if (address === 0x4012) {\n      // DMC Play code starting address\n      this.dmc.writeReg(address, value);\n    } else if (address === 0x4013) {\n      // DMC Play code length\n      this.dmc.writeReg(address, value);\n    } else if (address === 0x4015) {\n      // Channel enable\n      this.updateChannelEnable(value);\n\n      if (value !== 0 && this.initCounter > 0) {\n        // Start hardware initialization\n        this.initingHardware = true;\n      }\n\n      // DMC/IRQ Status\n      this.dmc.writeReg(address, value);\n    } else if (address === 0x4017) {\n      // Frame counter control\n      this.countSequence = (value >> 7) & 1;\n      this.masterFrameCounter = 0;\n      this.frameIrqActive = false;\n\n      if (((value >> 6) & 0x1) === 0) {\n        this.frameIrqEnabled = true;\n      } else {\n        this.frameIrqEnabled = false;\n      }\n\n      if (this.countSequence === 0) {\n        // NTSC:\n        this.frameIrqCounterMax = 4;\n        this.derivedFrameCounter = 4;\n      } else {\n        // PAL:\n        this.frameIrqCounterMax = 5;\n        this.derivedFrameCounter = 0;\n        this.frameCounterTick();\n      }\n    }\n  },\n\n  resetCounter: function() {\n    if (this.countSequence === 0) {\n      this.derivedFrameCounter = 4;\n    } else {\n      this.derivedFrameCounter = 0;\n    }\n  },\n\n  // Updates channel enable status.\n  // This is done on writes to the\n  // channel enable register (0x4015),\n  // and when the user enables/disables channels\n  // in the GUI.\n  updateChannelEnable: function(value) {\n    this.channelEnableValue = value & 0xffff;\n    this.square1.setEnabled((value & 1) !== 0);\n    this.square2.setEnabled((value & 2) !== 0);\n    this.triangle.setEnabled((value & 4) !== 0);\n    this.noise.setEnabled((value & 8) !== 0);\n    this.dmc.setEnabled((value & 16) !== 0);\n  },\n\n  // Clocks the frame counter. It should be clocked at\n  // twice the cpu speed, so the cycles will be\n  // divided by 2 for those counters that are\n  // clocked at cpu speed.\n  clockFrameCounter: function(nCycles) {\n    if (this.initCounter > 0) {\n      if (this.initingHardware) {\n        this.initCounter -= nCycles;\n        if (this.initCounter <= 0) {\n          this.initingHardware = false;\n        }\n        return;\n      }\n    }\n\n    // Don't process ticks beyond next sampling:\n    nCycles += this.extraCycles;\n    var maxCycles = this.sampleTimerMax - this.sampleTimer;\n    if (nCycles << 10 > maxCycles) {\n      this.extraCycles = ((nCycles << 10) - maxCycles) >> 10;\n      nCycles -= this.extraCycles;\n    } else {\n      this.extraCycles = 0;\n    }\n\n    var dmc = this.dmc;\n    var triangle = this.triangle;\n    var square1 = this.square1;\n    var square2 = this.square2;\n    var noise = this.noise;\n\n    // Clock DMC:\n    if (dmc.isEnabled) {\n      dmc.shiftCounter -= nCycles << 3;\n      while (dmc.shiftCounter <= 0 && dmc.dmaFrequency > 0) {\n        dmc.shiftCounter += dmc.dmaFrequency;\n        dmc.clockDmc();\n      }\n    }\n\n    // Clock Triangle channel Prog timer:\n    if (triangle.progTimerMax > 0) {\n      triangle.progTimerCount -= nCycles;\n      while (triangle.progTimerCount <= 0) {\n        triangle.progTimerCount += triangle.progTimerMax + 1;\n        if (triangle.linearCounter > 0 && triangle.lengthCounter > 0) {\n          triangle.triangleCounter++;\n          triangle.triangleCounter &= 0x1f;\n\n          if (triangle.isEnabled) {\n            if (triangle.triangleCounter >= 0x10) {\n              // Normal value.\n              triangle.sampleValue = triangle.triangleCounter & 0xf;\n            } else {\n              // Inverted value.\n              triangle.sampleValue = 0xf - (triangle.triangleCounter & 0xf);\n            }\n            triangle.sampleValue <<= 4;\n          }\n        }\n      }\n    }\n\n    // Clock Square channel 1 Prog timer:\n    square1.progTimerCount -= nCycles;\n    if (square1.progTimerCount <= 0) {\n      square1.progTimerCount += (square1.progTimerMax + 1) << 1;\n\n      square1.squareCounter++;\n      square1.squareCounter &= 0x7;\n      square1.updateSampleValue();\n    }\n\n    // Clock Square channel 2 Prog timer:\n    square2.progTimerCount -= nCycles;\n    if (square2.progTimerCount <= 0) {\n      square2.progTimerCount += (square2.progTimerMax + 1) << 1;\n\n      square2.squareCounter++;\n      square2.squareCounter &= 0x7;\n      square2.updateSampleValue();\n    }\n\n    // Clock noise channel Prog timer:\n    var acc_c = nCycles;\n    if (noise.progTimerCount - acc_c > 0) {\n      // Do all cycles at once:\n      noise.progTimerCount -= acc_c;\n      noise.accCount += acc_c;\n      noise.accValue += acc_c * noise.sampleValue;\n    } else {\n      // Slow-step:\n      while (acc_c-- > 0) {\n        if (--noise.progTimerCount <= 0 && noise.progTimerMax > 0) {\n          // Update noise shift register:\n          noise.shiftReg <<= 1;\n          noise.tmp =\n            ((noise.shiftReg << (noise.randomMode === 0 ? 1 : 6)) ^\n              noise.shiftReg) &\n            0x8000;\n          if (noise.tmp !== 0) {\n            // Sample value must be 0.\n            noise.shiftReg |= 0x01;\n            noise.randomBit = 0;\n            noise.sampleValue = 0;\n          } else {\n            // Find sample value:\n            noise.randomBit = 1;\n            if (noise.isEnabled && noise.lengthCounter > 0) {\n              noise.sampleValue = noise.masterVolume;\n            } else {\n              noise.sampleValue = 0;\n            }\n          }\n\n          noise.progTimerCount += noise.progTimerMax;\n        }\n\n        noise.accValue += noise.sampleValue;\n        noise.accCount++;\n      }\n    }\n\n    // Frame IRQ handling:\n    if (this.frameIrqEnabled && this.frameIrqActive) {\n      this.nes.cpu.requestIrq(this.nes.cpu.IRQ_NORMAL);\n    }\n\n    // Clock frame counter at double CPU speed:\n    this.masterFrameCounter += nCycles << 1;\n    if (this.masterFrameCounter >= this.frameTime) {\n      // 240Hz tick:\n      this.masterFrameCounter -= this.frameTime;\n      this.frameCounterTick();\n    }\n\n    // Accumulate sample value:\n    this.accSample(nCycles);\n\n    // Clock sample timer:\n    this.sampleTimer += nCycles << 10;\n    if (this.sampleTimer >= this.sampleTimerMax) {\n      // Sample channels:\n      this.sample();\n      this.sampleTimer -= this.sampleTimerMax;\n    }\n  },\n\n  accSample: function(cycles) {\n    // Special treatment for triangle channel - need to interpolate.\n    if (this.triangle.sampleCondition) {\n      this.triValue = Math.floor(\n        (this.triangle.progTimerCount << 4) / (this.triangle.progTimerMax + 1)\n      );\n      if (this.triValue > 16) {\n        this.triValue = 16;\n      }\n      if (this.triangle.triangleCounter >= 16) {\n        this.triValue = 16 - this.triValue;\n      }\n\n      // Add non-interpolated sample value:\n      this.triValue += this.triangle.sampleValue;\n    }\n\n    // Now sample normally:\n    if (cycles === 2) {\n      this.smpTriangle += this.triValue << 1;\n      this.smpDmc += this.dmc.sample << 1;\n      this.smpSquare1 += this.square1.sampleValue << 1;\n      this.smpSquare2 += this.square2.sampleValue << 1;\n      this.accCount += 2;\n    } else if (cycles === 4) {\n      this.smpTriangle += this.triValue << 2;\n      this.smpDmc += this.dmc.sample << 2;\n      this.smpSquare1 += this.square1.sampleValue << 2;\n      this.smpSquare2 += this.square2.sampleValue << 2;\n      this.accCount += 4;\n    } else {\n      this.smpTriangle += cycles * this.triValue;\n      this.smpDmc += cycles * this.dmc.sample;\n      this.smpSquare1 += cycles * this.square1.sampleValue;\n      this.smpSquare2 += cycles * this.square2.sampleValue;\n      this.accCount += cycles;\n    }\n  },\n\n  frameCounterTick: function() {\n    this.derivedFrameCounter++;\n    if (this.derivedFrameCounter >= this.frameIrqCounterMax) {\n      this.derivedFrameCounter = 0;\n    }\n\n    if (this.derivedFrameCounter === 1 || this.derivedFrameCounter === 3) {\n      // Clock length & sweep:\n      this.triangle.clockLengthCounter();\n      this.square1.clockLengthCounter();\n      this.square2.clockLengthCounter();\n      this.noise.clockLengthCounter();\n      this.square1.clockSweep();\n      this.square2.clockSweep();\n    }\n\n    if (this.derivedFrameCounter >= 0 && this.derivedFrameCounter < 4) {\n      // Clock linear & decay:\n      this.square1.clockEnvDecay();\n      this.square2.clockEnvDecay();\n      this.noise.clockEnvDecay();\n      this.triangle.clockLinearCounter();\n    }\n\n    if (this.derivedFrameCounter === 3 && this.countSequence === 0) {\n      // Enable IRQ:\n      this.frameIrqActive = true;\n    }\n\n    // End of 240Hz tick\n  },\n\n  // Samples the channels, mixes the output together, then writes to buffer.\n  sample: function() {\n    var sq_index, tnd_index;\n\n    if (this.accCount > 0) {\n      this.smpSquare1 <<= 4;\n      this.smpSquare1 = Math.floor(this.smpSquare1 / this.accCount);\n\n      this.smpSquare2 <<= 4;\n      this.smpSquare2 = Math.floor(this.smpSquare2 / this.accCount);\n\n      this.smpTriangle = Math.floor(this.smpTriangle / this.accCount);\n\n      this.smpDmc <<= 4;\n      this.smpDmc = Math.floor(this.smpDmc / this.accCount);\n\n      this.accCount = 0;\n    } else {\n      this.smpSquare1 = this.square1.sampleValue << 4;\n      this.smpSquare2 = this.square2.sampleValue << 4;\n      this.smpTriangle = this.triangle.sampleValue;\n      this.smpDmc = this.dmc.sample << 4;\n    }\n\n    var smpNoise = Math.floor((this.noise.accValue << 4) / this.noise.accCount);\n    this.noise.accValue = smpNoise >> 4;\n    this.noise.accCount = 1;\n\n    // Stereo sound.\n\n    // Left channel:\n    sq_index =\n      (this.smpSquare1 * this.stereoPosLSquare1 +\n        this.smpSquare2 * this.stereoPosLSquare2) >>\n      8;\n    tnd_index =\n      (3 * this.smpTriangle * this.stereoPosLTriangle +\n        (smpNoise << 1) * this.stereoPosLNoise +\n        this.smpDmc * this.stereoPosLDMC) >>\n      8;\n    if (sq_index >= this.square_table.length) {\n      sq_index = this.square_table.length - 1;\n    }\n    if (tnd_index >= this.tnd_table.length) {\n      tnd_index = this.tnd_table.length - 1;\n    }\n    var sampleValueL =\n      this.square_table[sq_index] + this.tnd_table[tnd_index] - this.dcValue;\n\n    // Right channel:\n    sq_index =\n      (this.smpSquare1 * this.stereoPosRSquare1 +\n        this.smpSquare2 * this.stereoPosRSquare2) >>\n      8;\n    tnd_index =\n      (3 * this.smpTriangle * this.stereoPosRTriangle +\n        (smpNoise << 1) * this.stereoPosRNoise +\n        this.smpDmc * this.stereoPosRDMC) >>\n      8;\n    if (sq_index >= this.square_table.length) {\n      sq_index = this.square_table.length - 1;\n    }\n    if (tnd_index >= this.tnd_table.length) {\n      tnd_index = this.tnd_table.length - 1;\n    }\n    var sampleValueR =\n      this.square_table[sq_index] + this.tnd_table[tnd_index] - this.dcValue;\n\n    // Remove DC from left channel:\n    var smpDiffL = sampleValueL - this.prevSampleL;\n    this.prevSampleL += smpDiffL;\n    this.smpAccumL += smpDiffL - (this.smpAccumL >> 10);\n    sampleValueL = this.smpAccumL;\n\n    // Remove DC from right channel:\n    var smpDiffR = sampleValueR - this.prevSampleR;\n    this.prevSampleR += smpDiffR;\n    this.smpAccumR += smpDiffR - (this.smpAccumR >> 10);\n    sampleValueR = this.smpAccumR;\n\n    // Write:\n    if (sampleValueL > this.maxSample) {\n      this.maxSample = sampleValueL;\n    }\n    if (sampleValueL < this.minSample) {\n      this.minSample = sampleValueL;\n    }\n\n    if (this.nes.opts.onAudioSample) {\n      this.nes.opts.onAudioSample(sampleValueL / 32768, sampleValueR / 32768);\n    }\n\n    // Reset sampled values:\n    this.smpSquare1 = 0;\n    this.smpSquare2 = 0;\n    this.smpTriangle = 0;\n    this.smpDmc = 0;\n  },\n\n  getLengthMax: function(value) {\n    return this.lengthLookup[value >> 3];\n  },\n\n  getDmcFrequency: function(value) {\n    if (value >= 0 && value < 0x10) {\n      return this.dmcFreqLookup[value];\n    }\n    return 0;\n  },\n\n  getNoiseWaveLength: function(value) {\n    if (value >= 0 && value < 0x10) {\n      return this.noiseWavelengthLookup[value];\n    }\n    return 0;\n  },\n\n  setPanning: function(pos) {\n    for (var i = 0; i < 5; i++) {\n      this.panning[i] = pos[i];\n    }\n    this.updateStereoPos();\n  },\n\n  setMasterVolume: function(value) {\n    if (value < 0) {\n      value = 0;\n    }\n    if (value > 256) {\n      value = 256;\n    }\n    this.masterVolume = value;\n    this.updateStereoPos();\n  },\n\n  updateStereoPos: function() {\n    this.stereoPosLSquare1 = (this.panning[0] * this.masterVolume) >> 8;\n    this.stereoPosLSquare2 = (this.panning[1] * this.masterVolume) >> 8;\n    this.stereoPosLTriangle = (this.panning[2] * this.masterVolume) >> 8;\n    this.stereoPosLNoise = (this.panning[3] * this.masterVolume) >> 8;\n    this.stereoPosLDMC = (this.panning[4] * this.masterVolume) >> 8;\n\n    this.stereoPosRSquare1 = this.masterVolume - this.stereoPosLSquare1;\n    this.stereoPosRSquare2 = this.masterVolume - this.stereoPosLSquare2;\n    this.stereoPosRTriangle = this.masterVolume - this.stereoPosLTriangle;\n    this.stereoPosRNoise = this.masterVolume - this.stereoPosLNoise;\n    this.stereoPosRDMC = this.masterVolume - this.stereoPosLDMC;\n  },\n\n  initLengthLookup: function() {\n    // prettier-ignore\n    this.lengthLookup = [\n            0x0A, 0xFE,\n            0x14, 0x02,\n            0x28, 0x04,\n            0x50, 0x06,\n            0xA0, 0x08,\n            0x3C, 0x0A,\n            0x0E, 0x0C,\n            0x1A, 0x0E,\n            0x0C, 0x10,\n            0x18, 0x12,\n            0x30, 0x14,\n            0x60, 0x16,\n            0xC0, 0x18,\n            0x48, 0x1A,\n            0x10, 0x1C,\n            0x20, 0x1E\n        ];\n  },\n\n  initDmcFrequencyLookup: function() {\n    this.dmcFreqLookup = new Array(16);\n\n    this.dmcFreqLookup[0x0] = 0xd60;\n    this.dmcFreqLookup[0x1] = 0xbe0;\n    this.dmcFreqLookup[0x2] = 0xaa0;\n    this.dmcFreqLookup[0x3] = 0xa00;\n    this.dmcFreqLookup[0x4] = 0x8f0;\n    this.dmcFreqLookup[0x5] = 0x7f0;\n    this.dmcFreqLookup[0x6] = 0x710;\n    this.dmcFreqLookup[0x7] = 0x6b0;\n    this.dmcFreqLookup[0x8] = 0x5f0;\n    this.dmcFreqLookup[0x9] = 0x500;\n    this.dmcFreqLookup[0xa] = 0x470;\n    this.dmcFreqLookup[0xb] = 0x400;\n    this.dmcFreqLookup[0xc] = 0x350;\n    this.dmcFreqLookup[0xd] = 0x2a0;\n    this.dmcFreqLookup[0xe] = 0x240;\n    this.dmcFreqLookup[0xf] = 0x1b0;\n    //for(int i=0;i<16;i++)dmcFreqLookup[i]/=8;\n  },\n\n  initNoiseWavelengthLookup: function() {\n    this.noiseWavelengthLookup = new Array(16);\n\n    this.noiseWavelengthLookup[0x0] = 0x004;\n    this.noiseWavelengthLookup[0x1] = 0x008;\n    this.noiseWavelengthLookup[0x2] = 0x010;\n    this.noiseWavelengthLookup[0x3] = 0x020;\n    this.noiseWavelengthLookup[0x4] = 0x040;\n    this.noiseWavelengthLookup[0x5] = 0x060;\n    this.noiseWavelengthLookup[0x6] = 0x080;\n    this.noiseWavelengthLookup[0x7] = 0x0a0;\n    this.noiseWavelengthLookup[0x8] = 0x0ca;\n    this.noiseWavelengthLookup[0x9] = 0x0fe;\n    this.noiseWavelengthLookup[0xa] = 0x17c;\n    this.noiseWavelengthLookup[0xb] = 0x1fc;\n    this.noiseWavelengthLookup[0xc] = 0x2fa;\n    this.noiseWavelengthLookup[0xd] = 0x3f8;\n    this.noiseWavelengthLookup[0xe] = 0x7f2;\n    this.noiseWavelengthLookup[0xf] = 0xfe4;\n  },\n\n  initDACtables: function() {\n    var value, ival, i;\n    var max_sqr = 0;\n    var max_tnd = 0;\n\n    this.square_table = new Array(32 * 16);\n    this.tnd_table = new Array(204 * 16);\n\n    for (i = 0; i < 32 * 16; i++) {\n      value = 95.52 / (8128.0 / (i / 16.0) + 100.0);\n      value *= 0.98411;\n      value *= 50000.0;\n      ival = Math.floor(value);\n\n      this.square_table[i] = ival;\n      if (ival > max_sqr) {\n        max_sqr = ival;\n      }\n    }\n\n    for (i = 0; i < 204 * 16; i++) {\n      value = 163.67 / (24329.0 / (i / 16.0) + 100.0);\n      value *= 0.98411;\n      value *= 50000.0;\n      ival = Math.floor(value);\n\n      this.tnd_table[i] = ival;\n      if (ival > max_tnd) {\n        max_tnd = ival;\n      }\n    }\n\n    this.dacRange = max_sqr + max_tnd;\n    this.dcValue = this.dacRange / 2;\n  }\n};\n\nvar ChannelDM = function(papu) {\n  this.papu = papu;\n\n  this.MODE_NORMAL = 0;\n  this.MODE_LOOP = 1;\n  this.MODE_IRQ = 2;\n\n  this.isEnabled = null;\n  this.hasSample = null;\n  this.irqGenerated = false;\n\n  this.playMode = null;\n  this.dmaFrequency = null;\n  this.dmaCounter = null;\n  this.deltaCounter = null;\n  this.playStartAddress = null;\n  this.playAddress = null;\n  this.playLength = null;\n  this.playLengthCounter = null;\n  this.shiftCounter = null;\n  this.reg4012 = null;\n  this.reg4013 = null;\n  this.sample = null;\n  this.dacLsb = null;\n  this.data = null;\n\n  this.reset();\n};\n\nChannelDM.prototype = {\n  clockDmc: function() {\n    // Only alter DAC value if the sample buffer has data:\n    if (this.hasSample) {\n      if ((this.data & 1) === 0) {\n        // Decrement delta:\n        if (this.deltaCounter > 0) {\n          this.deltaCounter--;\n        }\n      } else {\n        // Increment delta:\n        if (this.deltaCounter < 63) {\n          this.deltaCounter++;\n        }\n      }\n\n      // Update sample value:\n      this.sample = this.isEnabled ? (this.deltaCounter << 1) + this.dacLsb : 0;\n\n      // Update shift register:\n      this.data >>= 1;\n    }\n\n    this.dmaCounter--;\n    if (this.dmaCounter <= 0) {\n      // No more sample bits.\n      this.hasSample = false;\n      this.endOfSample();\n      this.dmaCounter = 8;\n    }\n\n    if (this.irqGenerated) {\n      this.papu.nes.cpu.requestIrq(this.papu.nes.cpu.IRQ_NORMAL);\n    }\n  },\n\n  endOfSample: function() {\n    if (this.playLengthCounter === 0 && this.playMode === this.MODE_LOOP) {\n      // Start from beginning of sample:\n      this.playAddress = this.playStartAddress;\n      this.playLengthCounter = this.playLength;\n    }\n\n    if (this.playLengthCounter > 0) {\n      // Fetch next sample:\n      this.nextSample();\n\n      if (this.playLengthCounter === 0) {\n        // Last byte of sample fetched, generate IRQ:\n        if (this.playMode === this.MODE_IRQ) {\n          // Generate IRQ:\n          this.irqGenerated = true;\n        }\n      }\n    }\n  },\n\n  nextSample: function() {\n    // Fetch byte:\n    this.data = this.papu.nes.mmap.load(this.playAddress);\n    this.papu.nes.cpu.haltCycles(4);\n\n    this.playLengthCounter--;\n    this.playAddress++;\n    if (this.playAddress > 0xffff) {\n      this.playAddress = 0x8000;\n    }\n\n    this.hasSample = true;\n  },\n\n  writeReg: function(address, value) {\n    if (address === 0x4010) {\n      // Play mode, DMA Frequency\n      if (value >> 6 === 0) {\n        this.playMode = this.MODE_NORMAL;\n      } else if (((value >> 6) & 1) === 1) {\n        this.playMode = this.MODE_LOOP;\n      } else if (value >> 6 === 2) {\n        this.playMode = this.MODE_IRQ;\n      }\n\n      if ((value & 0x80) === 0) {\n        this.irqGenerated = false;\n      }\n\n      this.dmaFrequency = this.papu.getDmcFrequency(value & 0xf);\n    } else if (address === 0x4011) {\n      // Delta counter load register:\n      this.deltaCounter = (value >> 1) & 63;\n      this.dacLsb = value & 1;\n      this.sample = (this.deltaCounter << 1) + this.dacLsb; // update sample value\n    } else if (address === 0x4012) {\n      // DMA address load register\n      this.playStartAddress = (value << 6) | 0x0c000;\n      this.playAddress = this.playStartAddress;\n      this.reg4012 = value;\n    } else if (address === 0x4013) {\n      // Length of play code\n      this.playLength = (value << 4) + 1;\n      this.playLengthCounter = this.playLength;\n      this.reg4013 = value;\n    } else if (address === 0x4015) {\n      // DMC/IRQ Status\n      if (((value >> 4) & 1) === 0) {\n        // Disable:\n        this.playLengthCounter = 0;\n      } else {\n        // Restart:\n        this.playAddress = this.playStartAddress;\n        this.playLengthCounter = this.playLength;\n      }\n      this.irqGenerated = false;\n    }\n  },\n\n  setEnabled: function(value) {\n    if (!this.isEnabled && value) {\n      this.playLengthCounter = this.playLength;\n    }\n    this.isEnabled = value;\n  },\n\n  getLengthStatus: function() {\n    return this.playLengthCounter === 0 || !this.isEnabled ? 0 : 1;\n  },\n\n  getIrqStatus: function() {\n    return this.irqGenerated ? 1 : 0;\n  },\n\n  reset: function() {\n    this.isEnabled = false;\n    this.irqGenerated = false;\n    this.playMode = this.MODE_NORMAL;\n    this.dmaFrequency = 0;\n    this.dmaCounter = 0;\n    this.deltaCounter = 0;\n    this.playStartAddress = 0;\n    this.playAddress = 0;\n    this.playLength = 0;\n    this.playLengthCounter = 0;\n    this.sample = 0;\n    this.dacLsb = 0;\n    this.shiftCounter = 0;\n    this.reg4012 = 0;\n    this.reg4013 = 0;\n    this.data = 0;\n  }\n};\n\nvar ChannelNoise = function(papu) {\n  this.papu = papu;\n\n  this.isEnabled = null;\n  this.envDecayDisable = null;\n  this.envDecayLoopEnable = null;\n  this.lengthCounterEnable = null;\n  this.envReset = null;\n  this.shiftNow = null;\n\n  this.lengthCounter = null;\n  this.progTimerCount = null;\n  this.progTimerMax = null;\n  this.envDecayRate = null;\n  this.envDecayCounter = null;\n  this.envVolume = null;\n  this.masterVolume = null;\n  this.shiftReg = 1 << 14;\n  this.randomBit = null;\n  this.randomMode = null;\n  this.sampleValue = null;\n  this.accValue = 0;\n  this.accCount = 1;\n  this.tmp = null;\n\n  this.reset();\n};\n\nChannelNoise.prototype = {\n  reset: function() {\n    this.progTimerCount = 0;\n    this.progTimerMax = 0;\n    this.isEnabled = false;\n    this.lengthCounter = 0;\n    this.lengthCounterEnable = false;\n    this.envDecayDisable = false;\n    this.envDecayLoopEnable = false;\n    this.shiftNow = false;\n    this.envDecayRate = 0;\n    this.envDecayCounter = 0;\n    this.envVolume = 0;\n    this.masterVolume = 0;\n    this.shiftReg = 1;\n    this.randomBit = 0;\n    this.randomMode = 0;\n    this.sampleValue = 0;\n    this.tmp = 0;\n  },\n\n  clockLengthCounter: function() {\n    if (this.lengthCounterEnable && this.lengthCounter > 0) {\n      this.lengthCounter--;\n      if (this.lengthCounter === 0) {\n        this.updateSampleValue();\n      }\n    }\n  },\n\n  clockEnvDecay: function() {\n    if (this.envReset) {\n      // Reset envelope:\n      this.envReset = false;\n      this.envDecayCounter = this.envDecayRate + 1;\n      this.envVolume = 0xf;\n    } else if (--this.envDecayCounter <= 0) {\n      // Normal handling:\n      this.envDecayCounter = this.envDecayRate + 1;\n      if (this.envVolume > 0) {\n        this.envVolume--;\n      } else {\n        this.envVolume = this.envDecayLoopEnable ? 0xf : 0;\n      }\n    }\n    if (this.envDecayDisable) {\n      this.masterVolume = this.envDecayRate;\n    } else {\n      this.masterVolume = this.envVolume;\n    }\n    this.updateSampleValue();\n  },\n\n  updateSampleValue: function() {\n    if (this.isEnabled && this.lengthCounter > 0) {\n      this.sampleValue = this.randomBit * this.masterVolume;\n    }\n  },\n\n  writeReg: function(address, value) {\n    if (address === 0x400c) {\n      // Volume/Envelope decay:\n      this.envDecayDisable = (value & 0x10) !== 0;\n      this.envDecayRate = value & 0xf;\n      this.envDecayLoopEnable = (value & 0x20) !== 0;\n      this.lengthCounterEnable = (value & 0x20) === 0;\n      if (this.envDecayDisable) {\n        this.masterVolume = this.envDecayRate;\n      } else {\n        this.masterVolume = this.envVolume;\n      }\n    } else if (address === 0x400e) {\n      // Programmable timer:\n      this.progTimerMax = this.papu.getNoiseWaveLength(value & 0xf);\n      this.randomMode = value >> 7;\n    } else if (address === 0x400f) {\n      // Length counter\n      this.lengthCounter = this.papu.getLengthMax(value & 248);\n      this.envReset = true;\n    }\n    // Update:\n    //updateSampleValue();\n  },\n\n  setEnabled: function(value) {\n    this.isEnabled = value;\n    if (!value) {\n      this.lengthCounter = 0;\n    }\n    this.updateSampleValue();\n  },\n\n  getLengthStatus: function() {\n    return this.lengthCounter === 0 || !this.isEnabled ? 0 : 1;\n  }\n};\n\nvar ChannelSquare = function(papu, square1) {\n  this.papu = papu;\n\n  // prettier-ignore\n  this.dutyLookup = [\n         0, 1, 0, 0, 0, 0, 0, 0,\n         0, 1, 1, 0, 0, 0, 0, 0,\n         0, 1, 1, 1, 1, 0, 0, 0,\n         1, 0, 0, 1, 1, 1, 1, 1\n    ];\n  // prettier-ignore\n  this.impLookup = [\n         1,-1, 0, 0, 0, 0, 0, 0,\n         1, 0,-1, 0, 0, 0, 0, 0,\n         1, 0, 0, 0,-1, 0, 0, 0,\n        -1, 0, 1, 0, 0, 0, 0, 0\n    ];\n\n  this.sqr1 = square1;\n  this.isEnabled = null;\n  this.lengthCounterEnable = null;\n  this.sweepActive = null;\n  this.envDecayDisable = null;\n  this.envDecayLoopEnable = null;\n  this.envReset = null;\n  this.sweepCarry = null;\n  this.updateSweepPeriod = null;\n\n  this.progTimerCount = null;\n  this.progTimerMax = null;\n  this.lengthCounter = null;\n  this.squareCounter = null;\n  this.sweepCounter = null;\n  this.sweepCounterMax = null;\n  this.sweepMode = null;\n  this.sweepShiftAmount = null;\n  this.envDecayRate = null;\n  this.envDecayCounter = null;\n  this.envVolume = null;\n  this.masterVolume = null;\n  this.dutyMode = null;\n  this.sweepResult = null;\n  this.sampleValue = null;\n  this.vol = null;\n\n  this.reset();\n};\n\nChannelSquare.prototype = {\n  reset: function() {\n    this.progTimerCount = 0;\n    this.progTimerMax = 0;\n    this.lengthCounter = 0;\n    this.squareCounter = 0;\n    this.sweepCounter = 0;\n    this.sweepCounterMax = 0;\n    this.sweepMode = 0;\n    this.sweepShiftAmount = 0;\n    this.envDecayRate = 0;\n    this.envDecayCounter = 0;\n    this.envVolume = 0;\n    this.masterVolume = 0;\n    this.dutyMode = 0;\n    this.vol = 0;\n\n    this.isEnabled = false;\n    this.lengthCounterEnable = false;\n    this.sweepActive = false;\n    this.sweepCarry = false;\n    this.envDecayDisable = false;\n    this.envDecayLoopEnable = false;\n  },\n\n  clockLengthCounter: function() {\n    if (this.lengthCounterEnable && this.lengthCounter > 0) {\n      this.lengthCounter--;\n      if (this.lengthCounter === 0) {\n        this.updateSampleValue();\n      }\n    }\n  },\n\n  clockEnvDecay: function() {\n    if (this.envReset) {\n      // Reset envelope:\n      this.envReset = false;\n      this.envDecayCounter = this.envDecayRate + 1;\n      this.envVolume = 0xf;\n    } else if (--this.envDecayCounter <= 0) {\n      // Normal handling:\n      this.envDecayCounter = this.envDecayRate + 1;\n      if (this.envVolume > 0) {\n        this.envVolume--;\n      } else {\n        this.envVolume = this.envDecayLoopEnable ? 0xf : 0;\n      }\n    }\n\n    if (this.envDecayDisable) {\n      this.masterVolume = this.envDecayRate;\n    } else {\n      this.masterVolume = this.envVolume;\n    }\n    this.updateSampleValue();\n  },\n\n  clockSweep: function() {\n    if (--this.sweepCounter <= 0) {\n      this.sweepCounter = this.sweepCounterMax + 1;\n      if (\n        this.sweepActive &&\n        this.sweepShiftAmount > 0 &&\n        this.progTimerMax > 7\n      ) {\n        // Calculate result from shifter:\n        this.sweepCarry = false;\n        if (this.sweepMode === 0) {\n          this.progTimerMax += this.progTimerMax >> this.sweepShiftAmount;\n          if (this.progTimerMax > 4095) {\n            this.progTimerMax = 4095;\n            this.sweepCarry = true;\n          }\n        } else {\n          this.progTimerMax =\n            this.progTimerMax -\n            ((this.progTimerMax >> this.sweepShiftAmount) -\n              (this.sqr1 ? 1 : 0));\n        }\n      }\n    }\n\n    if (this.updateSweepPeriod) {\n      this.updateSweepPeriod = false;\n      this.sweepCounter = this.sweepCounterMax + 1;\n    }\n  },\n\n  updateSampleValue: function() {\n    if (this.isEnabled && this.lengthCounter > 0 && this.progTimerMax > 7) {\n      if (\n        this.sweepMode === 0 &&\n        this.progTimerMax + (this.progTimerMax >> this.sweepShiftAmount) > 4095\n      ) {\n        //if (this.sweepCarry) {\n        this.sampleValue = 0;\n      } else {\n        this.sampleValue =\n          this.masterVolume *\n          this.dutyLookup[(this.dutyMode << 3) + this.squareCounter];\n      }\n    } else {\n      this.sampleValue = 0;\n    }\n  },\n\n  writeReg: function(address, value) {\n    var addrAdd = this.sqr1 ? 0 : 4;\n    if (address === 0x4000 + addrAdd) {\n      // Volume/Envelope decay:\n      this.envDecayDisable = (value & 0x10) !== 0;\n      this.envDecayRate = value & 0xf;\n      this.envDecayLoopEnable = (value & 0x20) !== 0;\n      this.dutyMode = (value >> 6) & 0x3;\n      this.lengthCounterEnable = (value & 0x20) === 0;\n      if (this.envDecayDisable) {\n        this.masterVolume = this.envDecayRate;\n      } else {\n        this.masterVolume = this.envVolume;\n      }\n      this.updateSampleValue();\n    } else if (address === 0x4001 + addrAdd) {\n      // Sweep:\n      this.sweepActive = (value & 0x80) !== 0;\n      this.sweepCounterMax = (value >> 4) & 7;\n      this.sweepMode = (value >> 3) & 1;\n      this.sweepShiftAmount = value & 7;\n      this.updateSweepPeriod = true;\n    } else if (address === 0x4002 + addrAdd) {\n      // Programmable timer:\n      this.progTimerMax &= 0x700;\n      this.progTimerMax |= value;\n    } else if (address === 0x4003 + addrAdd) {\n      // Programmable timer, length counter\n      this.progTimerMax &= 0xff;\n      this.progTimerMax |= (value & 0x7) << 8;\n\n      if (this.isEnabled) {\n        this.lengthCounter = this.papu.getLengthMax(value & 0xf8);\n      }\n\n      this.envReset = true;\n    }\n  },\n\n  setEnabled: function(value) {\n    this.isEnabled = value;\n    if (!value) {\n      this.lengthCounter = 0;\n    }\n    this.updateSampleValue();\n  },\n\n  getLengthStatus: function() {\n    return this.lengthCounter === 0 || !this.isEnabled ? 0 : 1;\n  }\n};\n\nvar ChannelTriangle = function(papu) {\n  this.papu = papu;\n\n  this.isEnabled = null;\n  this.sampleCondition = null;\n  this.lengthCounterEnable = null;\n  this.lcHalt = null;\n  this.lcControl = null;\n\n  this.progTimerCount = null;\n  this.progTimerMax = null;\n  this.triangleCounter = null;\n  this.lengthCounter = null;\n  this.linearCounter = null;\n  this.lcLoadValue = null;\n  this.sampleValue = null;\n  this.tmp = null;\n\n  this.reset();\n};\n\nChannelTriangle.prototype = {\n  reset: function() {\n    this.progTimerCount = 0;\n    this.progTimerMax = 0;\n    this.triangleCounter = 0;\n    this.isEnabled = false;\n    this.sampleCondition = false;\n    this.lengthCounter = 0;\n    this.lengthCounterEnable = false;\n    this.linearCounter = 0;\n    this.lcLoadValue = 0;\n    this.lcHalt = true;\n    this.lcControl = false;\n    this.tmp = 0;\n    this.sampleValue = 0xf;\n  },\n\n  clockLengthCounter: function() {\n    if (this.lengthCounterEnable && this.lengthCounter > 0) {\n      this.lengthCounter--;\n      if (this.lengthCounter === 0) {\n        this.updateSampleCondition();\n      }\n    }\n  },\n\n  clockLinearCounter: function() {\n    if (this.lcHalt) {\n      // Load:\n      this.linearCounter = this.lcLoadValue;\n      this.updateSampleCondition();\n    } else if (this.linearCounter > 0) {\n      // Decrement:\n      this.linearCounter--;\n      this.updateSampleCondition();\n    }\n    if (!this.lcControl) {\n      // Clear halt flag:\n      this.lcHalt = false;\n    }\n  },\n\n  getLengthStatus: function() {\n    return this.lengthCounter === 0 || !this.isEnabled ? 0 : 1;\n  },\n\n  readReg: function(address) {\n    return 0;\n  },\n\n  writeReg: function(address, value) {\n    if (address === 0x4008) {\n      // New values for linear counter:\n      this.lcControl = (value & 0x80) !== 0;\n      this.lcLoadValue = value & 0x7f;\n\n      // Length counter enable:\n      this.lengthCounterEnable = !this.lcControl;\n    } else if (address === 0x400a) {\n      // Programmable timer:\n      this.progTimerMax &= 0x700;\n      this.progTimerMax |= value;\n    } else if (address === 0x400b) {\n      // Programmable timer, length counter\n      this.progTimerMax &= 0xff;\n      this.progTimerMax |= (value & 0x07) << 8;\n      this.lengthCounter = this.papu.getLengthMax(value & 0xf8);\n      this.lcHalt = true;\n    }\n\n    this.updateSampleCondition();\n  },\n\n  clockProgrammableTimer: function(nCycles) {\n    if (this.progTimerMax > 0) {\n      this.progTimerCount += nCycles;\n      while (\n        this.progTimerMax > 0 &&\n        this.progTimerCount >= this.progTimerMax\n      ) {\n        this.progTimerCount -= this.progTimerMax;\n        if (\n          this.isEnabled &&\n          this.lengthCounter > 0 &&\n          this.linearCounter > 0\n        ) {\n          this.clockTriangleGenerator();\n        }\n      }\n    }\n  },\n\n  clockTriangleGenerator: function() {\n    this.triangleCounter++;\n    this.triangleCounter &= 0x1f;\n  },\n\n  setEnabled: function(value) {\n    this.isEnabled = value;\n    if (!value) {\n      this.lengthCounter = 0;\n    }\n    this.updateSampleCondition();\n  },\n\n  updateSampleCondition: function() {\n    this.sampleCondition =\n      this.isEnabled &&\n      this.progTimerMax > 7 &&\n      this.linearCounter > 0 &&\n      this.lengthCounter > 0;\n  }\n};\n\nmodule.exports = PAPU;\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\n\nvar GG = function() {\n  this.patches = [];\n  this.enabled = true;\n};\n\nvar LETTER_VALUES = 'APZLGITYEOXUKSVN';\n\nfunction toDigit(letter) {\n  return LETTER_VALUES.indexOf(letter);\n}\n\nfunction toLetter(digit) {\n  return LETTER_VALUES.substr(digit, 1);\n}\n\nfunction toHex(n, width) {\n  var s = n.toString(16);\n  return '0000'.substring(0, width - s.length) + s;\n}\n\n\nGG.prototype = {\n  setEnabled: function(enabled) {\n    this.enabled = enabled;\n  },\n\n  addCode: function(code) {\n    this.patches.push(this.decode(code));\n  },\n\n  addPatch: function(addr, value, key) {\n    this.patches.push({addr: addr, value: value, key: key});\n  },\n\n  applyCodes: function(addr, value) {\n    if (!this.enabled) return value;\n\n    for (var i = 0; i < this.patches.length; ++i) { // TODO: optimize data structure?\n      if (this.patches[i].addr === (addr & 0x7fff)) {\n        if (this.patches[i].key === undefined || this.patches[i].key === value) {\n          return this.patches[i].value;\n        }\n      }\n    }\n    return value;\n  },\n\n  decode: function(code) {\n    if (code.indexOf(':') !== -1) return this.decodeHex(code);\n\n    var digits = code.toUpperCase().split('').map(toDigit);\n\n    var value = ((digits[0] & 8) << 4) + ((digits[1] & 7) << 4) + (digits[0] & 7);\n    var addr = ((digits[3] & 7) << 12) + ((digits[4] & 8) << 8) + ((digits[5] & 7) << 8) +\n        ((digits[1] & 8) << 4) + ((digits[2] & 7) << 4) + (digits[3] & 8) + (digits[4] & 7);\n    var key;\n\n    if (digits.length === 8) {\n      value += (digits[7] & 8);\n      key = ((digits[6] & 8) << 4) + ((digits[7] & 7) << 4) + (digits[5] & 8) + (digits[6] & 7);\n    } else {\n      value += (digits[5] & 8);\n    }\n\n    var wantskey = !!(digits[2] >> 3);\n\n    return { value: value, addr: addr, wantskey: wantskey, key: key };\n  },\n\n  encodeHex: function(addr, value, key, wantskey) {\n    var s = toHex(addr, 4) + ':' + toHex(value, 2);\n\n    if (key !== undefined || wantskey) {\n      s += '?';\n    }\n\n    if (key !== undefined) {\n      s += toHex(key, 2);\n    }\n\n    return s;\n  },\n\n  decodeHex: function(s) {\n    var match = s.match(/([0-9a-fA-F]+):([0-9a-fA-F]+)(\\?[0-9a-fA-F]*)?/);\n    if (!match) return null;\n\n    var addr = parseInt(match[1], 16);\n    var value = parseInt(match[2], 16);\n    var wantskey = match[3] !== undefined;\n    var key = (match[3] !== undefined && match[3].length > 1) ? parseInt(match[3].substring(1), 16) : undefined;\n\n    return { value: value, addr: addr, wantskey: wantskey, key: key };\n  },\n\n  encode: function(addr, value, key, wantskey) {\n    var digits = Array(6);\n\n    digits[0] = (value & 7) + ((value >> 4) & 8);\n    digits[1] = ((value >> 4) & 7) + ((addr >> 4) & 8);\n    digits[2] = ((addr >> 4) & 7);\n    digits[3] = (addr >> 12) + (addr & 8);\n    digits[4] = (addr & 7) + ((addr >> 8) & 8);\n    digits[5] = ((addr >> 8) & 7);\n\n    if (key === undefined) {\n      digits[5] += value & 8;\n      if (wantskey) digits[2] += 8;\n    } else {\n      digits[2] += 8;\n      digits[5] += key & 8;\n      digits[6] = (key & 7) + ((key >> 4) & 8);\n      digits[7] = ((key >> 4) & 7) + (value & 8);\n    }\n\n    var code = digits.map(toLetter).join('');\n\n    return code;\n  },\n};\n\nmodule.exports = GG;\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Mappers = __webpack_require__(10);\nvar Tile = __webpack_require__(2);\n\nvar ROM = function(nes) {\n  this.nes = nes;\n\n  this.mapperName = new Array(92);\n\n  for (var i = 0; i < 92; i++) {\n    this.mapperName[i] = \"Unknown Mapper\";\n  }\n  this.mapperName[0] = \"Direct Access\";\n  this.mapperName[1] = \"Nintendo MMC1\";\n  this.mapperName[2] = \"UNROM\";\n  this.mapperName[3] = \"CNROM\";\n  this.mapperName[4] = \"Nintendo MMC3\";\n  this.mapperName[5] = \"Nintendo MMC5\";\n  this.mapperName[6] = \"FFE F4xxx\";\n  this.mapperName[7] = \"AOROM\";\n  this.mapperName[8] = \"FFE F3xxx\";\n  this.mapperName[9] = \"Nintendo MMC2\";\n  this.mapperName[10] = \"Nintendo MMC4\";\n  this.mapperName[11] = \"Color Dreams Chip\";\n  this.mapperName[12] = \"FFE F6xxx\";\n  this.mapperName[15] = \"100-in-1 switch\";\n  this.mapperName[16] = \"Bandai chip\";\n  this.mapperName[17] = \"FFE F8xxx\";\n  this.mapperName[18] = \"Jaleco SS8806 chip\";\n  this.mapperName[19] = \"Namcot 106 chip\";\n  this.mapperName[20] = \"Famicom Disk System\";\n  this.mapperName[21] = \"Konami VRC4a\";\n  this.mapperName[22] = \"Konami VRC2a\";\n  this.mapperName[23] = \"Konami VRC2a\";\n  this.mapperName[24] = \"Konami VRC6\";\n  this.mapperName[25] = \"Konami VRC4b\";\n  this.mapperName[32] = \"Irem G-101 chip\";\n  this.mapperName[33] = \"Taito TC0190/TC0350\";\n  this.mapperName[34] = \"32kB ROM switch\";\n\n  this.mapperName[64] = \"Tengen RAMBO-1 chip\";\n  this.mapperName[65] = \"Irem H-3001 chip\";\n  this.mapperName[66] = \"GNROM switch\";\n  this.mapperName[67] = \"SunSoft3 chip\";\n  this.mapperName[68] = \"SunSoft4 chip\";\n  this.mapperName[69] = \"SunSoft5 FME-7 chip\";\n  this.mapperName[71] = \"Camerica chip\";\n  this.mapperName[78] = \"Irem 74HC161/32-based\";\n  this.mapperName[91] = \"Pirate HK-SF3 chip\";\n};\n\nROM.prototype = {\n  // Mirroring types:\n  VERTICAL_MIRRORING: 0,\n  HORIZONTAL_MIRRORING: 1,\n  FOURSCREEN_MIRRORING: 2,\n  SINGLESCREEN_MIRRORING: 3,\n  SINGLESCREEN_MIRRORING2: 4,\n  SINGLESCREEN_MIRRORING3: 5,\n  SINGLESCREEN_MIRRORING4: 6,\n  CHRROM_MIRRORING: 7,\n\n  header: null,\n  rom: null,\n  vrom: null,\n  vromTile: null,\n\n  romCount: null,\n  vromCount: null,\n  mirroring: null,\n  batteryRam: null,\n  trainer: null,\n  fourScreen: null,\n  mapperType: null,\n  valid: false,\n\n  load: function(data) {\n    var i, j, v;\n\n    if (data.indexOf(\"NES\\x1a\") === -1) {\n      throw new Error(\"Not a valid NES ROM.\");\n    }\n    this.header = new Array(16);\n    for (i = 0; i < 16; i++) {\n      this.header[i] = data.charCodeAt(i) & 0xff;\n    }\n    this.romCount = this.header[4];\n    this.vromCount = this.header[5] * 2; // Get the number of 4kB banks, not 8kB\n    this.mirroring = (this.header[6] & 1) !== 0 ? 1 : 0;\n    this.batteryRam = (this.header[6] & 2) !== 0;\n    this.trainer = (this.header[6] & 4) !== 0;\n    this.fourScreen = (this.header[6] & 8) !== 0;\n    this.mapperType = (this.header[6] >> 4) | (this.header[7] & 0xf0);\n    /* TODO\n        if (this.batteryRam)\n            this.loadBatteryRam();*/\n    // Check whether byte 8-15 are zero's:\n    var foundError = false;\n    for (i = 8; i < 16; i++) {\n      if (this.header[i] !== 0) {\n        foundError = true;\n        break;\n      }\n    }\n    if (foundError) {\n      this.mapperType &= 0xf; // Ignore byte 7\n    }\n    // Load PRG-ROM banks:\n    this.rom = new Array(this.romCount);\n    var offset = 16;\n    for (i = 0; i < this.romCount; i++) {\n      this.rom[i] = new Array(16384);\n      for (j = 0; j < 16384; j++) {\n        if (offset + j >= data.length) {\n          break;\n        }\n        this.rom[i][j] = data.charCodeAt(offset + j) & 0xff;\n      }\n      offset += 16384;\n    }\n    // Load CHR-ROM banks:\n    this.vrom = new Array(this.vromCount);\n    for (i = 0; i < this.vromCount; i++) {\n      this.vrom[i] = new Array(4096);\n      for (j = 0; j < 4096; j++) {\n        if (offset + j >= data.length) {\n          break;\n        }\n        this.vrom[i][j] = data.charCodeAt(offset + j) & 0xff;\n      }\n      offset += 4096;\n    }\n\n    // Create VROM tiles:\n    this.vromTile = new Array(this.vromCount);\n    for (i = 0; i < this.vromCount; i++) {\n      this.vromTile[i] = new Array(256);\n      for (j = 0; j < 256; j++) {\n        this.vromTile[i][j] = new Tile();\n      }\n    }\n\n    // Convert CHR-ROM banks to tiles:\n    var tileIndex;\n    var leftOver;\n    for (v = 0; v < this.vromCount; v++) {\n      for (i = 0; i < 4096; i++) {\n        tileIndex = i >> 4;\n        leftOver = i % 16;\n        if (leftOver < 8) {\n          this.vromTile[v][tileIndex].setScanline(\n            leftOver,\n            this.vrom[v][i],\n            this.vrom[v][i + 8]\n          );\n        } else {\n          this.vromTile[v][tileIndex].setScanline(\n            leftOver - 8,\n            this.vrom[v][i - 8],\n            this.vrom[v][i]\n          );\n        }\n      }\n    }\n\n    this.valid = true;\n  },\n\n  getMirroringType: function() {\n    if (this.fourScreen) {\n      return this.FOURSCREEN_MIRRORING;\n    }\n    if (this.mirroring === 0) {\n      return this.HORIZONTAL_MIRRORING;\n    }\n    return this.VERTICAL_MIRRORING;\n  },\n\n  getMapperName: function() {\n    if (this.mapperType >= 0 && this.mapperType < this.mapperName.length) {\n      return this.mapperName[this.mapperType];\n    }\n    return \"Unknown Mapper, \" + this.mapperType;\n  },\n\n  mapperSupported: function() {\n    return typeof Mappers[this.mapperType] !== \"undefined\";\n  },\n\n  createMapper: function() {\n    if (this.mapperSupported()) {\n      return new Mappers[this.mapperType](this.nes);\n    } else {\n      throw new Error(\n        \"This ROM uses a mapper not supported by JSNES: \" +\n          this.getMapperName() +\n          \"(\" +\n          this.mapperType +\n          \")\"\n      );\n    }\n  }\n};\n\nmodule.exports = ROM;\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar utils = __webpack_require__(0);\n\nvar Mappers = {};\n\nMappers[0] = function(nes) {\n  this.nes = nes;\n};\n\nMappers[0].prototype = {\n  reset: function() {\n    this.joy1StrobeState = 0;\n    this.joy2StrobeState = 0;\n    this.joypadLastWrite = 0;\n\n    this.zapperFired = false;\n    this.zapperX = null;\n    this.zapperY = null;\n  },\n\n  write: function(address, value) {\n    if (address < 0x2000) {\n      // Mirroring of RAM:\n      this.nes.cpu.mem[address & 0x7ff] = value;\n    } else if (address > 0x4017) {\n      this.nes.cpu.mem[address] = value;\n      if (address >= 0x6000 && address < 0x8000) {\n        // Write to SaveRAM. Store in file:\n        // TODO: not yet\n        //if(this.nes.rom!=null)\n        //    this.nes.rom.writeBatteryRam(address,value);\n      }\n    } else if (address > 0x2007 && address < 0x4000) {\n      this.regWrite(0x2000 + (address & 0x7), value);\n    } else {\n      this.regWrite(address, value);\n    }\n  },\n\n  writelow: function(address, value) {\n    if (address < 0x2000) {\n      // Mirroring of RAM:\n      this.nes.cpu.mem[address & 0x7ff] = value;\n    } else if (address > 0x4017) {\n      this.nes.cpu.mem[address] = value;\n    } else if (address > 0x2007 && address < 0x4000) {\n      this.regWrite(0x2000 + (address & 0x7), value);\n    } else {\n      this.regWrite(address, value);\n    }\n  },\n\n  load: function(address) {\n    // Wrap around:\n    address &= 0xffff;\n\n    // Check address range:\n    if (address > 0x4017) {\n      // ROM:\n      return this.nes.cpu.mem[address];\n    } else if (address >= 0x2000) {\n      // I/O Ports.\n      return this.regLoad(address);\n    } else {\n      // RAM (mirrored)\n      return this.nes.cpu.mem[address & 0x7ff];\n    }\n  },\n\n  regLoad: function(address) {\n    switch (address >> 12) { // use fourth nibble (0xF000)\n      case 0:\n        break;\n\n      case 1:\n        break;\n\n      case 2:\n      // Fall through to case 3\n      case 3:\n        // PPU Registers\n        switch (address & 0x7) {\n          case 0x0:\n            // 0x2000:\n            // PPU Control Register 1.\n            // (the value is stored both\n            // in main memory and in the\n            // PPU as flags):\n            // (not in the real NES)\n            return this.nes.cpu.mem[0x2000];\n\n          case 0x1:\n            // 0x2001:\n            // PPU Control Register 2.\n            // (the value is stored both\n            // in main memory and in the\n            // PPU as flags):\n            // (not in the real NES)\n            return this.nes.cpu.mem[0x2001];\n\n          case 0x2:\n            // 0x2002:\n            // PPU Status Register.\n            // The value is stored in\n            // main memory in addition\n            // to as flags in the PPU.\n            // (not in the real NES)\n            return this.nes.ppu.readStatusRegister();\n\n          case 0x3:\n            return 0;\n\n          case 0x4:\n            // 0x2004:\n            // Sprite Memory read.\n            return this.nes.ppu.sramLoad();\n          case 0x5:\n            return 0;\n\n          case 0x6:\n            return 0;\n\n          case 0x7:\n            // 0x2007:\n            // VRAM read:\n            return this.nes.ppu.vramLoad();\n        }\n        break;\n      case 4:\n        // Sound+Joypad registers\n        switch (address - 0x4015) {\n          case 0:\n            // 0x4015:\n            // Sound channel enable, DMC Status\n            return this.nes.papu.readReg(address);\n\n          case 1:\n            // 0x4016:\n            // Joystick 1 + Strobe\n            return this.joy1Read();\n\n          case 2:\n            // 0x4017:\n            // Joystick 2 + Strobe\n            // https://wiki.nesdev.com/w/index.php/Zapper\n            var w;\n\n            if (\n              this.zapperX !== null &&\n              this.zapperY !== null &&\n              this.nes.ppu.isPixelWhite(this.zapperX, this.zapperY)\n            ) {\n              w = 0;\n            } else {\n              w = 0x1 << 3;\n            }\n\n            if (this.zapperFired) {\n              w |= 0x1 << 4;\n            }\n            return (this.joy2Read() | w) & 0xffff;\n        }\n        break;\n    }\n    return 0;\n  },\n\n  regWrite: function(address, value) {\n    switch (address) {\n      case 0x2000:\n        // PPU Control register 1\n        this.nes.cpu.mem[address] = value;\n        this.nes.ppu.updateControlReg1(value);\n        break;\n\n      case 0x2001:\n        // PPU Control register 2\n        this.nes.cpu.mem[address] = value;\n        this.nes.ppu.updateControlReg2(value);\n        break;\n\n      case 0x2003:\n        // Set Sprite RAM address:\n        this.nes.ppu.writeSRAMAddress(value);\n        break;\n\n      case 0x2004:\n        // Write to Sprite RAM:\n        this.nes.ppu.sramWrite(value);\n        break;\n\n      case 0x2005:\n        // Screen Scroll offsets:\n        this.nes.ppu.scrollWrite(value);\n        break;\n\n      case 0x2006:\n        // Set VRAM address:\n        this.nes.ppu.writeVRAMAddress(value);\n        break;\n\n      case 0x2007:\n        // Write to VRAM:\n        this.nes.ppu.vramWrite(value);\n        break;\n\n      case 0x4014:\n        // Sprite Memory DMA Access\n        this.nes.ppu.sramDMA(value);\n        break;\n\n      case 0x4015:\n        // Sound Channel Switch, DMC Status\n        this.nes.papu.writeReg(address, value);\n        break;\n\n      case 0x4016:\n        // Joystick 1 + Strobe\n        if ((value & 1) === 0 && (this.joypadLastWrite & 1) === 1) {\n          this.joy1StrobeState = 0;\n          this.joy2StrobeState = 0;\n        }\n        this.joypadLastWrite = value;\n        break;\n\n      case 0x4017:\n        // Sound channel frame sequencer:\n        this.nes.papu.writeReg(address, value);\n        break;\n\n      default:\n        // Sound registers\n        // console.log(\"write to sound reg\");\n        if (address >= 0x4000 && address <= 0x4017) {\n          this.nes.papu.writeReg(address, value);\n        }\n    }\n  },\n\n  joy1Read: function() {\n    var ret;\n\n    switch (this.joy1StrobeState) {\n      case 0:\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n        ret = this.nes.controllers[1].state[this.joy1StrobeState];\n        break;\n      case 8:\n      case 9:\n      case 10:\n      case 11:\n      case 12:\n      case 13:\n      case 14:\n      case 15:\n      case 16:\n      case 17:\n      case 18:\n        ret = 0;\n        break;\n      case 19:\n        ret = 1;\n        break;\n      default:\n        ret = 0;\n    }\n\n    this.joy1StrobeState++;\n    if (this.joy1StrobeState === 24) {\n      this.joy1StrobeState = 0;\n    }\n\n    return ret;\n  },\n\n  joy2Read: function() {\n    var ret;\n\n    switch (this.joy2StrobeState) {\n      case 0:\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n        ret = this.nes.controllers[2].state[this.joy2StrobeState];\n        break;\n      case 8:\n      case 9:\n      case 10:\n      case 11:\n      case 12:\n      case 13:\n      case 14:\n      case 15:\n      case 16:\n      case 17:\n      case 18:\n        ret = 0;\n        break;\n      case 19:\n        ret = 1;\n        break;\n      default:\n        ret = 0;\n    }\n\n    this.joy2StrobeState++;\n    if (this.joy2StrobeState === 24) {\n      this.joy2StrobeState = 0;\n    }\n\n    return ret;\n  },\n\n  loadROM: function() {\n    if (!this.nes.rom.valid || this.nes.rom.romCount < 1) {\n      throw new Error(\"NoMapper: Invalid ROM! Unable to load.\");\n    }\n\n    // Load ROM into memory:\n    this.loadPRGROM();\n\n    // Load CHR-ROM:\n    this.loadCHRROM();\n\n    // Load Battery RAM (if present):\n    this.loadBatteryRam();\n\n    // Reset IRQ:\n    //nes.getCpu().doResetInterrupt();\n    this.nes.cpu.requestIrq(this.nes.cpu.IRQ_RESET);\n  },\n\n  loadPRGROM: function() {\n    if (this.nes.rom.romCount > 1) {\n      // Load the two first banks into memory.\n      this.loadRomBank(0, 0x8000);\n      this.loadRomBank(1, 0xc000);\n    } else {\n      // Load the one bank into both memory locations:\n      this.loadRomBank(0, 0x8000);\n      this.loadRomBank(0, 0xc000);\n    }\n  },\n\n  loadCHRROM: function() {\n    // console.log(\"Loading CHR ROM..\");\n    if (this.nes.rom.vromCount > 0) {\n      if (this.nes.rom.vromCount === 1) {\n        this.loadVromBank(0, 0x0000);\n        this.loadVromBank(0, 0x1000);\n      } else {\n        this.loadVromBank(0, 0x0000);\n        this.loadVromBank(1, 0x1000);\n      }\n    } else {\n      //System.out.println(\"There aren't any CHR-ROM banks..\");\n    }\n  },\n\n  loadBatteryRam: function() {\n    if (this.nes.rom.batteryRam) {\n      var ram = this.nes.rom.batteryRam;\n      if (ram !== null && ram.length === 0x2000) {\n        // Load Battery RAM into memory:\n        utils.copyArrayElements(ram, 0, this.nes.cpu.mem, 0x6000, 0x2000);\n      }\n    }\n  },\n\n  loadRomBank: function(bank, address) {\n    // Loads a ROM bank into the specified address.\n    bank %= this.nes.rom.romCount;\n    //var data = this.nes.rom.rom[bank];\n    //cpuMem.write(address,data,data.length);\n    utils.copyArrayElements(\n      this.nes.rom.rom[bank],\n      0,\n      this.nes.cpu.mem,\n      address,\n      16384\n    );\n  },\n\n  loadVromBank: function(bank, address) {\n    if (this.nes.rom.vromCount === 0) {\n      return;\n    }\n    this.nes.ppu.triggerRendering();\n\n    utils.copyArrayElements(\n      this.nes.rom.vrom[bank % this.nes.rom.vromCount],\n      0,\n      this.nes.ppu.vramMem,\n      address,\n      4096\n    );\n\n    var vromTile = this.nes.rom.vromTile[bank % this.nes.rom.vromCount];\n    utils.copyArrayElements(\n      vromTile,\n      0,\n      this.nes.ppu.ptTile,\n      address >> 4,\n      256\n    );\n  },\n\n  load32kRomBank: function(bank, address) {\n    this.loadRomBank((bank * 2) % this.nes.rom.romCount, address);\n    this.loadRomBank((bank * 2 + 1) % this.nes.rom.romCount, address + 16384);\n  },\n\n  load8kVromBank: function(bank4kStart, address) {\n    if (this.nes.rom.vromCount === 0) {\n      return;\n    }\n    this.nes.ppu.triggerRendering();\n\n    this.loadVromBank(bank4kStart % this.nes.rom.vromCount, address);\n    this.loadVromBank(\n      (bank4kStart + 1) % this.nes.rom.vromCount,\n      address + 4096\n    );\n  },\n\n  load1kVromBank: function(bank1k, address) {\n    if (this.nes.rom.vromCount === 0) {\n      return;\n    }\n    this.nes.ppu.triggerRendering();\n\n    var bank4k = Math.floor(bank1k / 4) % this.nes.rom.vromCount;\n    var bankoffset = (bank1k % 4) * 1024;\n    utils.copyArrayElements(\n      this.nes.rom.vrom[bank4k],\n      0,\n      this.nes.ppu.vramMem,\n      bankoffset,\n      1024\n    );\n\n    // Update tiles:\n    var vromTile = this.nes.rom.vromTile[bank4k];\n    var baseIndex = address >> 4;\n    for (var i = 0; i < 64; i++) {\n      this.nes.ppu.ptTile[baseIndex + i] = vromTile[((bank1k % 4) << 6) + i];\n    }\n  },\n\n  load2kVromBank: function(bank2k, address) {\n    if (this.nes.rom.vromCount === 0) {\n      return;\n    }\n    this.nes.ppu.triggerRendering();\n\n    var bank4k = Math.floor(bank2k / 2) % this.nes.rom.vromCount;\n    var bankoffset = (bank2k % 2) * 2048;\n    utils.copyArrayElements(\n      this.nes.rom.vrom[bank4k],\n      bankoffset,\n      this.nes.ppu.vramMem,\n      address,\n      2048\n    );\n\n    // Update tiles:\n    var vromTile = this.nes.rom.vromTile[bank4k];\n    var baseIndex = address >> 4;\n    for (var i = 0; i < 128; i++) {\n      this.nes.ppu.ptTile[baseIndex + i] = vromTile[((bank2k % 2) << 7) + i];\n    }\n  },\n\n  load8kRomBank: function(bank8k, address) {\n    var bank16k = Math.floor(bank8k / 2) % this.nes.rom.romCount;\n    var offset = (bank8k % 2) * 8192;\n\n    //this.nes.cpu.mem.write(address,this.nes.rom.rom[bank16k],offset,8192);\n    utils.copyArrayElements(\n      this.nes.rom.rom[bank16k],\n      offset,\n      this.nes.cpu.mem,\n      address,\n      8192\n    );\n  },\n\n  clockIrqCounter: function() {\n    // Does nothing. This is used by the MMC3 mapper.\n  },\n\n  latchAccess: function(address) {\n    // Does nothing. This is used by MMC2.\n  },\n\n  toJSON: function() {\n    return {\n      joy1StrobeState: this.joy1StrobeState,\n      joy2StrobeState: this.joy2StrobeState,\n      joypadLastWrite: this.joypadLastWrite\n    };\n  },\n\n  fromJSON: function(s) {\n    this.joy1StrobeState = s.joy1StrobeState;\n    this.joy2StrobeState = s.joy2StrobeState;\n    this.joypadLastWrite = s.joypadLastWrite;\n  }\n};\n\nMappers[1] = function(nes) {\n  this.nes = nes;\n};\n\nMappers[1].prototype = new Mappers[0]();\n\nMappers[1].prototype.reset = function() {\n  Mappers[0].prototype.reset.apply(this);\n\n  // 5-bit buffer:\n  this.regBuffer = 0;\n  this.regBufferCounter = 0;\n\n  // Register 0:\n  this.mirroring = 0;\n  this.oneScreenMirroring = 0;\n  this.prgSwitchingArea = 1;\n  this.prgSwitchingSize = 1;\n  this.vromSwitchingSize = 0;\n\n  // Register 1:\n  this.romSelectionReg0 = 0;\n\n  // Register 2:\n  this.romSelectionReg1 = 0;\n\n  // Register 3:\n  this.romBankSelect = 0;\n};\n\nMappers[1].prototype.write = function(address, value) {\n  // Writes to addresses other than MMC registers are handled by NoMapper.\n  if (address < 0x8000) {\n    Mappers[0].prototype.write.apply(this, arguments);\n    return;\n  }\n\n  // See what should be done with the written value:\n  if ((value & 128) !== 0) {\n    // Reset buffering:\n    this.regBufferCounter = 0;\n    this.regBuffer = 0;\n\n    // Reset register:\n    if (this.getRegNumber(address) === 0) {\n      this.prgSwitchingArea = 1;\n      this.prgSwitchingSize = 1;\n    }\n  } else {\n    // Continue buffering:\n    //regBuffer = (regBuffer & (0xFF-(1<<regBufferCounter))) | ((value & (1<<regBufferCounter))<<regBufferCounter);\n    this.regBuffer =\n      (this.regBuffer & (0xff - (1 << this.regBufferCounter))) |\n      ((value & 1) << this.regBufferCounter);\n    this.regBufferCounter++;\n\n    if (this.regBufferCounter === 5) {\n      // Use the buffered value:\n      this.setReg(this.getRegNumber(address), this.regBuffer);\n\n      // Reset buffer:\n      this.regBuffer = 0;\n      this.regBufferCounter = 0;\n    }\n  }\n};\n\nMappers[1].prototype.setReg = function(reg, value) {\n  var tmp;\n\n  switch (reg) {\n    case 0:\n      // Mirroring:\n      tmp = value & 3;\n      if (tmp !== this.mirroring) {\n        // Set mirroring:\n        this.mirroring = tmp;\n        if ((this.mirroring & 2) === 0) {\n          // SingleScreen mirroring overrides the other setting:\n          this.nes.ppu.setMirroring(this.nes.rom.SINGLESCREEN_MIRRORING);\n        } else if ((this.mirroring & 1) !== 0) {\n          // Not overridden by SingleScreen mirroring.\n          this.nes.ppu.setMirroring(this.nes.rom.HORIZONTAL_MIRRORING);\n        } else {\n          this.nes.ppu.setMirroring(this.nes.rom.VERTICAL_MIRRORING);\n        }\n      }\n\n      // PRG Switching Area;\n      this.prgSwitchingArea = (value >> 2) & 1;\n\n      // PRG Switching Size:\n      this.prgSwitchingSize = (value >> 3) & 1;\n\n      // VROM Switching Size:\n      this.vromSwitchingSize = (value >> 4) & 1;\n\n      break;\n\n    case 1:\n      // ROM selection:\n      this.romSelectionReg0 = (value >> 4) & 1;\n\n      // Check whether the cart has VROM:\n      if (this.nes.rom.vromCount > 0) {\n        // Select VROM bank at 0x0000:\n        if (this.vromSwitchingSize === 0) {\n          // Swap 8kB VROM:\n          if (this.romSelectionReg0 === 0) {\n            this.load8kVromBank(value & 0xf, 0x0000);\n          } else {\n            this.load8kVromBank(\n              Math.floor(this.nes.rom.vromCount / 2) + (value & 0xf),\n              0x0000\n            );\n          }\n        } else {\n          // Swap 4kB VROM:\n          if (this.romSelectionReg0 === 0) {\n            this.loadVromBank(value & 0xf, 0x0000);\n          } else {\n            this.loadVromBank(\n              Math.floor(this.nes.rom.vromCount / 2) + (value & 0xf),\n              0x0000\n            );\n          }\n        }\n      }\n\n      break;\n\n    case 2:\n      // ROM selection:\n      this.romSelectionReg1 = (value >> 4) & 1;\n\n      // Check whether the cart has VROM:\n      if (this.nes.rom.vromCount > 0) {\n        // Select VROM bank at 0x1000:\n        if (this.vromSwitchingSize === 1) {\n          // Swap 4kB of VROM:\n          if (this.romSelectionReg1 === 0) {\n            this.loadVromBank(value & 0xf, 0x1000);\n          } else {\n            this.loadVromBank(\n              Math.floor(this.nes.rom.vromCount / 2) + (value & 0xf),\n              0x1000\n            );\n          }\n        }\n      }\n      break;\n\n    default:\n      // Select ROM bank:\n      // -------------------------\n      tmp = value & 0xf;\n      var bank;\n      var baseBank = 0;\n\n      if (this.nes.rom.romCount >= 32) {\n        // 1024 kB cart\n        if (this.vromSwitchingSize === 0) {\n          if (this.romSelectionReg0 === 1) {\n            baseBank = 16;\n          }\n        } else {\n          baseBank =\n            (this.romSelectionReg0 | (this.romSelectionReg1 << 1)) << 3;\n        }\n      } else if (this.nes.rom.romCount >= 16) {\n        // 512 kB cart\n        if (this.romSelectionReg0 === 1) {\n          baseBank = 8;\n        }\n      }\n\n      if (this.prgSwitchingSize === 0) {\n        // 32kB\n        bank = baseBank + (value & 0xf);\n        this.load32kRomBank(bank, 0x8000);\n      } else {\n        // 16kB\n        bank = baseBank * 2 + (value & 0xf);\n        if (this.prgSwitchingArea === 0) {\n          this.loadRomBank(bank, 0xc000);\n        } else {\n          this.loadRomBank(bank, 0x8000);\n        }\n      }\n  }\n};\n\n// Returns the register number from the address written to:\nMappers[1].prototype.getRegNumber = function(address) {\n  if (address >= 0x8000 && address <= 0x9fff) {\n    return 0;\n  } else if (address >= 0xa000 && address <= 0xbfff) {\n    return 1;\n  } else if (address >= 0xc000 && address <= 0xdfff) {\n    return 2;\n  } else {\n    return 3;\n  }\n};\n\nMappers[1].prototype.loadROM = function() {\n  if (!this.nes.rom.valid) {\n    throw new Error(\"MMC1: Invalid ROM! Unable to load.\");\n  }\n\n  // Load PRG-ROM:\n  this.loadRomBank(0, 0x8000); //   First ROM bank..\n  this.loadRomBank(this.nes.rom.romCount - 1, 0xc000); // ..and last ROM bank.\n\n  // Load CHR-ROM:\n  this.loadCHRROM();\n\n  // Load Battery RAM (if present):\n  this.loadBatteryRam();\n\n  // Do Reset-Interrupt:\n  this.nes.cpu.requestIrq(this.nes.cpu.IRQ_RESET);\n};\n\nMappers[1].prototype.switchLowHighPrgRom = function(oldSetting) {\n  // not yet.\n};\n\nMappers[1].prototype.switch16to32 = function() {\n  // not yet.\n};\n\nMappers[1].prototype.switch32to16 = function() {\n  // not yet.\n};\n\nMappers[1].prototype.toJSON = function() {\n  var s = Mappers[0].prototype.toJSON.apply(this);\n  s.mirroring = this.mirroring;\n  s.oneScreenMirroring = this.oneScreenMirroring;\n  s.prgSwitchingArea = this.prgSwitchingArea;\n  s.prgSwitchingSize = this.prgSwitchingSize;\n  s.vromSwitchingSize = this.vromSwitchingSize;\n  s.romSelectionReg0 = this.romSelectionReg0;\n  s.romSelectionReg1 = this.romSelectionReg1;\n  s.romBankSelect = this.romBankSelect;\n  s.regBuffer = this.regBuffer;\n  s.regBufferCounter = this.regBufferCounter;\n  return s;\n};\n\nMappers[1].prototype.fromJSON = function(s) {\n  Mappers[0].prototype.fromJSON.apply(this, arguments);\n  this.mirroring = s.mirroring;\n  this.oneScreenMirroring = s.oneScreenMirroring;\n  this.prgSwitchingArea = s.prgSwitchingArea;\n  this.prgSwitchingSize = s.prgSwitchingSize;\n  this.vromSwitchingSize = s.vromSwitchingSize;\n  this.romSelectionReg0 = s.romSelectionReg0;\n  this.romSelectionReg1 = s.romSelectionReg1;\n  this.romBankSelect = s.romBankSelect;\n  this.regBuffer = s.regBuffer;\n  this.regBufferCounter = s.regBufferCounter;\n};\n\nMappers[2] = function(nes) {\n  this.nes = nes;\n};\n\nMappers[2].prototype = new Mappers[0]();\n\nMappers[2].prototype.write = function(address, value) {\n  // Writes to addresses other than MMC registers are handled by NoMapper.\n  if (address < 0x8000) {\n    Mappers[0].prototype.write.apply(this, arguments);\n    return;\n  } else {\n    // This is a ROM bank select command.\n    // Swap in the given ROM bank at 0x8000:\n    this.loadRomBank(value, 0x8000);\n  }\n};\n\nMappers[2].prototype.loadROM = function() {\n  if (!this.nes.rom.valid) {\n    throw new Error(\"UNROM: Invalid ROM! Unable to load.\");\n  }\n\n  // Load PRG-ROM:\n  this.loadRomBank(0, 0x8000);\n  this.loadRomBank(this.nes.rom.romCount - 1, 0xc000);\n\n  // Load CHR-ROM:\n  this.loadCHRROM();\n\n  // Do Reset-Interrupt:\n  this.nes.cpu.requestIrq(this.nes.cpu.IRQ_RESET);\n};\n\n/**\n * Mapper 003 (CNROM)\n *\n * @constructor\n * @example Solomon's Key, Arkanoid, Arkista's Ring, Bump 'n' Jump, Cybernoid\n * @description http://wiki.nesdev.com/w/index.php/INES_Mapper_003\n */\nMappers[3] = function(nes) {\n  this.nes = nes;\n};\n\nMappers[3].prototype = new Mappers[0]();\n\nMappers[3].prototype.write = function(address, value) {\n  // Writes to addresses other than MMC registers are handled by NoMapper.\n  if (address < 0x8000) {\n    Mappers[0].prototype.write.apply(this, arguments);\n    return;\n  } else {\n    // This is a ROM bank select command.\n    // Swap in the given ROM bank at 0x8000:\n    // This is a VROM bank select command.\n    // Swap in the given VROM bank at 0x0000:\n    var bank = (value % (this.nes.rom.vromCount / 2)) * 2;\n    this.loadVromBank(bank, 0x0000);\n    this.loadVromBank(bank + 1, 0x1000);\n    this.load8kVromBank(value * 2, 0x0000);\n  }\n};\n\nMappers[4] = function(nes) {\n  this.nes = nes;\n\n  this.CMD_SEL_2_1K_VROM_0000 = 0;\n  this.CMD_SEL_2_1K_VROM_0800 = 1;\n  this.CMD_SEL_1K_VROM_1000 = 2;\n  this.CMD_SEL_1K_VROM_1400 = 3;\n  this.CMD_SEL_1K_VROM_1800 = 4;\n  this.CMD_SEL_1K_VROM_1C00 = 5;\n  this.CMD_SEL_ROM_PAGE1 = 6;\n  this.CMD_SEL_ROM_PAGE2 = 7;\n\n  this.command = null;\n  this.prgAddressSelect = null;\n  this.chrAddressSelect = null;\n  this.pageNumber = null;\n  this.irqCounter = null;\n  this.irqLatchValue = null;\n  this.irqEnable = null;\n  this.prgAddressChanged = false;\n};\n\nMappers[4].prototype = new Mappers[0]();\n\nMappers[4].prototype.write = function(address, value) {\n  // Writes to addresses other than MMC registers are handled by NoMapper.\n  if (address < 0x8000) {\n    Mappers[0].prototype.write.apply(this, arguments);\n    return;\n  }\n\n  switch (address) {\n    case 0x8000:\n      // Command/Address Select register\n      this.command = value & 7;\n      var tmp = (value >> 6) & 1;\n      if (tmp !== this.prgAddressSelect) {\n        this.prgAddressChanged = true;\n      }\n      this.prgAddressSelect = tmp;\n      this.chrAddressSelect = (value >> 7) & 1;\n      break;\n\n    case 0x8001:\n      // Page number for command\n      this.executeCommand(this.command, value);\n      break;\n\n    case 0xa000:\n      // Mirroring select\n      if ((value & 1) !== 0) {\n        this.nes.ppu.setMirroring(this.nes.rom.HORIZONTAL_MIRRORING);\n      } else {\n        this.nes.ppu.setMirroring(this.nes.rom.VERTICAL_MIRRORING);\n      }\n      break;\n\n    case 0xa001:\n      // SaveRAM Toggle\n      // TODO\n      //nes.getRom().setSaveState((value&1)!=0);\n      break;\n\n    case 0xc000:\n      // IRQ Counter register\n      this.irqCounter = value;\n      //nes.ppu.mapperIrqCounter = 0;\n      break;\n\n    case 0xc001:\n      // IRQ Latch register\n      this.irqLatchValue = value;\n      break;\n\n    case 0xe000:\n      // IRQ Control Reg 0 (disable)\n      //irqCounter = irqLatchValue;\n      this.irqEnable = 0;\n      break;\n\n    case 0xe001:\n      // IRQ Control Reg 1 (enable)\n      this.irqEnable = 1;\n      break;\n\n    default:\n    // Not a MMC3 register.\n    // The game has probably crashed,\n    // since it tries to write to ROM..\n    // IGNORE.\n  }\n};\n\nMappers[4].prototype.executeCommand = function(cmd, arg) {\n  switch (cmd) {\n    case this.CMD_SEL_2_1K_VROM_0000:\n      // Select 2 1KB VROM pages at 0x0000:\n      if (this.chrAddressSelect === 0) {\n        this.load1kVromBank(arg, 0x0000);\n        this.load1kVromBank(arg + 1, 0x0400);\n      } else {\n        this.load1kVromBank(arg, 0x1000);\n        this.load1kVromBank(arg + 1, 0x1400);\n      }\n      break;\n\n    case this.CMD_SEL_2_1K_VROM_0800:\n      // Select 2 1KB VROM pages at 0x0800:\n      if (this.chrAddressSelect === 0) {\n        this.load1kVromBank(arg, 0x0800);\n        this.load1kVromBank(arg + 1, 0x0c00);\n      } else {\n        this.load1kVromBank(arg, 0x1800);\n        this.load1kVromBank(arg + 1, 0x1c00);\n      }\n      break;\n\n    case this.CMD_SEL_1K_VROM_1000:\n      // Select 1K VROM Page at 0x1000:\n      if (this.chrAddressSelect === 0) {\n        this.load1kVromBank(arg, 0x1000);\n      } else {\n        this.load1kVromBank(arg, 0x0000);\n      }\n      break;\n\n    case this.CMD_SEL_1K_VROM_1400:\n      // Select 1K VROM Page at 0x1400:\n      if (this.chrAddressSelect === 0) {\n        this.load1kVromBank(arg, 0x1400);\n      } else {\n        this.load1kVromBank(arg, 0x0400);\n      }\n      break;\n\n    case this.CMD_SEL_1K_VROM_1800:\n      // Select 1K VROM Page at 0x1800:\n      if (this.chrAddressSelect === 0) {\n        this.load1kVromBank(arg, 0x1800);\n      } else {\n        this.load1kVromBank(arg, 0x0800);\n      }\n      break;\n\n    case this.CMD_SEL_1K_VROM_1C00:\n      // Select 1K VROM Page at 0x1C00:\n      if (this.chrAddressSelect === 0) {\n        this.load1kVromBank(arg, 0x1c00);\n      } else {\n        this.load1kVromBank(arg, 0x0c00);\n      }\n      break;\n\n    case this.CMD_SEL_ROM_PAGE1:\n      if (this.prgAddressChanged) {\n        // Load the two hardwired banks:\n        if (this.prgAddressSelect === 0) {\n          this.load8kRomBank((this.nes.rom.romCount - 1) * 2, 0xc000);\n        } else {\n          this.load8kRomBank((this.nes.rom.romCount - 1) * 2, 0x8000);\n        }\n        this.prgAddressChanged = false;\n      }\n\n      // Select first switchable ROM page:\n      if (this.prgAddressSelect === 0) {\n        this.load8kRomBank(arg, 0x8000);\n      } else {\n        this.load8kRomBank(arg, 0xc000);\n      }\n      break;\n\n    case this.CMD_SEL_ROM_PAGE2:\n      // Select second switchable ROM page:\n      this.load8kRomBank(arg, 0xa000);\n\n      // hardwire appropriate bank:\n      if (this.prgAddressChanged) {\n        // Load the two hardwired banks:\n        if (this.prgAddressSelect === 0) {\n          this.load8kRomBank((this.nes.rom.romCount - 1) * 2, 0xc000);\n        } else {\n          this.load8kRomBank((this.nes.rom.romCount - 1) * 2, 0x8000);\n        }\n        this.prgAddressChanged = false;\n      }\n  }\n};\n\nMappers[4].prototype.loadROM = function() {\n  if (!this.nes.rom.valid) {\n    throw new Error(\"MMC3: Invalid ROM! Unable to load.\");\n  }\n\n  // Load hardwired PRG banks (0xC000 and 0xE000):\n  this.load8kRomBank((this.nes.rom.romCount - 1) * 2, 0xc000);\n  this.load8kRomBank((this.nes.rom.romCount - 1) * 2 + 1, 0xe000);\n\n  // Load swappable PRG banks (0x8000 and 0xA000):\n  this.load8kRomBank(0, 0x8000);\n  this.load8kRomBank(1, 0xa000);\n\n  // Load CHR-ROM:\n  this.loadCHRROM();\n\n  // Load Battery RAM (if present):\n  this.loadBatteryRam();\n\n  // Do Reset-Interrupt:\n  this.nes.cpu.requestIrq(this.nes.cpu.IRQ_RESET);\n};\n\nMappers[4].prototype.clockIrqCounter = function() {\n  if (this.irqEnable === 1) {\n    this.irqCounter--;\n    if (this.irqCounter < 0) {\n      // Trigger IRQ:\n      //nes.getCpu().doIrq();\n      this.nes.cpu.requestIrq(this.nes.cpu.IRQ_NORMAL);\n      this.irqCounter = this.irqLatchValue;\n    }\n  }\n};\n\nMappers[4].prototype.toJSON = function() {\n  var s = Mappers[0].prototype.toJSON.apply(this);\n  s.command = this.command;\n  s.prgAddressSelect = this.prgAddressSelect;\n  s.chrAddressSelect = this.chrAddressSelect;\n  s.pageNumber = this.pageNumber;\n  s.irqCounter = this.irqCounter;\n  s.irqLatchValue = this.irqLatchValue;\n  s.irqEnable = this.irqEnable;\n  s.prgAddressChanged = this.prgAddressChanged;\n  return s;\n};\n\nMappers[4].prototype.fromJSON = function(s) {\n  Mappers[0].prototype.fromJSON.apply(this, arguments);\n  this.command = s.command;\n  this.prgAddressSelect = s.prgAddressSelect;\n  this.chrAddressSelect = s.chrAddressSelect;\n  this.pageNumber = s.pageNumber;\n  this.irqCounter = s.irqCounter;\n  this.irqLatchValue = s.irqLatchValue;\n  this.irqEnable = s.irqEnable;\n  this.prgAddressChanged = s.prgAddressChanged;\n};\n\n/**\n * Mapper005 (MMC5,ExROM)\n *\n * @example Castlevania 3, Just Breed, Uncharted Waters, Romance of the 3 Kingdoms 2, Laser Invasion, Metal Slader Glory, Uchuu Keibitai SDF, Shin 4 Nin Uchi Mahjong - Yakuman Tengoku\n * @description http://wiki.nesdev.com/w/index.php/INES_Mapper_005\n * @constructor\n */\nMappers[5] = function(nes) {\n  this.nes = nes;\n};\n\nMappers[5].prototype = new Mappers[0]();\n\nMappers[5].prototype.write = function(address, value) {\n  // Writes to addresses other than MMC registers are handled by NoMapper.\n  if (address < 0x8000) {\n    Mappers[0].prototype.write.apply(this, arguments);\n  } else {\n    this.load8kVromBank(value, 0x0000);\n  }\n};\n\nMappers[5].prototype.write = function(address, value) {\n  // Writes to addresses other than MMC registers are handled by NoMapper.\n  if (address < 0x5000) {\n    Mappers[0].prototype.write.apply(this, arguments);\n    return;\n  }\n\n  switch (address) {\n    case 0x5100:\n      this.prg_size = value & 3;\n      break;\n    case 0x5101:\n      this.chr_size = value & 3;\n      break;\n    case 0x5102:\n      this.sram_we_a = value & 3;\n      break;\n    case 0x5103:\n      this.sram_we_b = value & 3;\n      break;\n    case 0x5104:\n      this.graphic_mode = value & 3;\n      break;\n    case 0x5105:\n      this.nametable_mode = value;\n      this.nametable_type[0] = value & 3;\n      this.load1kVromBank(value & 3, 0x2000);\n      value >>= 2;\n      this.nametable_type[1] = value & 3;\n      this.load1kVromBank(value & 3, 0x2400);\n      value >>= 2;\n      this.nametable_type[2] = value & 3;\n      this.load1kVromBank(value & 3, 0x2800);\n      value >>= 2;\n      this.nametable_type[3] = value & 3;\n      this.load1kVromBank(value & 3, 0x2c00);\n      break;\n    case 0x5106:\n      this.fill_chr = value;\n      break;\n    case 0x5107:\n      this.fill_pal = value & 3;\n      break;\n    case 0x5113:\n      this.SetBank_SRAM(3, value & 3);\n      break;\n    case 0x5114:\n    case 0x5115:\n    case 0x5116:\n    case 0x5117:\n      this.SetBank_CPU(address, value);\n      break;\n    case 0x5120:\n    case 0x5121:\n    case 0x5122:\n    case 0x5123:\n    case 0x5124:\n    case 0x5125:\n    case 0x5126:\n    case 0x5127:\n      this.chr_mode = 0;\n      this.chr_page[0][address & 7] = value;\n      this.SetBank_PPU();\n      break;\n    case 0x5128:\n    case 0x5129:\n    case 0x512a:\n    case 0x512b:\n      this.chr_mode = 1;\n      this.chr_page[1][(address & 3) + 0] = value;\n      this.chr_page[1][(address & 3) + 4] = value;\n      this.SetBank_PPU();\n      break;\n    case 0x5200:\n      this.split_control = value;\n      break;\n    case 0x5201:\n      this.split_scroll = value;\n      break;\n    case 0x5202:\n      this.split_page = value & 0x3f;\n      break;\n    case 0x5203:\n      this.irq_line = value;\n      this.nes.cpu.ClearIRQ();\n      break;\n    case 0x5204:\n      this.irq_enable = value;\n      this.nes.cpu.ClearIRQ();\n      break;\n    case 0x5205:\n      this.mult_a = value;\n      break;\n    case 0x5206:\n      this.mult_b = value;\n      break;\n    default:\n      if (address >= 0x5000 && address <= 0x5015) {\n        this.nes.papu.exWrite(address, value);\n      } else if (address >= 0x5c00 && address <= 0x5fff) {\n        if (this.graphic_mode === 2) {\n          // ExRAM\n          // vram write\n        } else if (this.graphic_mode !== 3) {\n          // Split,ExGraphic\n          if (this.irq_status & 0x40) {\n            // vram write\n          } else {\n            // vram write\n          }\n        }\n      } else if (address >= 0x6000 && address <= 0x7fff) {\n        if (this.sram_we_a === 2 && this.sram_we_b === 1) {\n          // additional ram write\n        }\n      }\n      break;\n  }\n};\n\nMappers[5].prototype.loadROM = function() {\n  if (!this.nes.rom.valid) {\n    throw new Error(\"UNROM: Invalid ROM! Unable to load.\");\n  }\n\n  // Load PRG-ROM:\n  this.load8kRomBank(this.nes.rom.romCount * 2 - 1, 0x8000);\n  this.load8kRomBank(this.nes.rom.romCount * 2 - 1, 0xa000);\n  this.load8kRomBank(this.nes.rom.romCount * 2 - 1, 0xc000);\n  this.load8kRomBank(this.nes.rom.romCount * 2 - 1, 0xe000);\n\n  // Load CHR-ROM:\n  this.loadCHRROM();\n\n  // Do Reset-Interrupt:\n  this.nes.cpu.requestIrq(this.nes.cpu.IRQ_RESET);\n};\n\n/**\n * Mapper007 (AxROM)\n * @example Battletoads, Time Lord, Marble Madness\n * @description http://wiki.nesdev.com/w/index.php/INES_Mapper_007\n * @constructor\n */\nMappers[7] = function(nes) {\n  this.nes = nes;\n};\n\nMappers[7].prototype = new Mappers[0]();\n\nMappers[7].prototype.write = function(address, value) {\n  // Writes to addresses other than MMC registers are handled by NoMapper.\n  if (address < 0x8000) {\n    Mappers[0].prototype.write.apply(this, arguments);\n  } else {\n    this.load32kRomBank(value & 0x7, 0x8000);\n    if (value & 0x10) {\n      this.nes.ppu.setMirroring(this.nes.rom.SINGLESCREEN_MIRRORING2);\n    } else {\n      this.nes.ppu.setMirroring(this.nes.rom.SINGLESCREEN_MIRRORING);\n    }\n  }\n};\n\nMappers[7].prototype.loadROM = function() {\n  if (!this.nes.rom.valid) {\n    throw new Error(\"AOROM: Invalid ROM! Unable to load.\");\n  }\n\n  // Load PRG-ROM:\n  this.loadPRGROM();\n\n  // Load CHR-ROM:\n  this.loadCHRROM();\n\n  // Do Reset-Interrupt:\n  this.nes.cpu.requestIrq(this.nes.cpu.IRQ_RESET);\n};\n\n/**\n * Mapper 011 (Color Dreams)\n *\n * @description http://wiki.nesdev.com/w/index.php/Color_Dreams\n * @example Crystal Mines, Metal Fighter\n * @constructor\n */\nMappers[11] = function(nes) {\n  this.nes = nes;\n};\n\nMappers[11].prototype = new Mappers[0]();\n\nMappers[11].prototype.write = function(address, value) {\n  if (address < 0x8000) {\n    Mappers[0].prototype.write.apply(this, arguments);\n    return;\n  } else {\n    // Swap in the given PRG-ROM bank:\n    var prgbank1 = ((value & 0xf) * 2) % this.nes.rom.romCount;\n    var prgbank2 = ((value & 0xf) * 2 + 1) % this.nes.rom.romCount;\n\n    this.loadRomBank(prgbank1, 0x8000);\n    this.loadRomBank(prgbank2, 0xc000);\n\n    if (this.nes.rom.vromCount > 0) {\n      // Swap in the given VROM bank at 0x0000:\n      var bank = ((value >> 4) * 2) % this.nes.rom.vromCount;\n      this.loadVromBank(bank, 0x0000);\n      this.loadVromBank(bank + 1, 0x1000);\n    }\n  }\n};\n\n/**\n * Mapper 034 (BNROM, NINA-01)\n *\n * @description http://wiki.nesdev.com/w/index.php/INES_Mapper_034\n * @example Darkseed, Mashou, Mission Impossible 2\n * @constructor\n */\nMappers[34] = function(nes) {\n  this.nes = nes;\n};\n\nMappers[34].prototype = new Mappers[0]();\n\nMappers[34].prototype.write = function(address, value) {\n  if (address < 0x8000) {\n    Mappers[0].prototype.write.apply(this, arguments);\n    return;\n  } else {\n    this.load32kRomBank(value, 0x8000);\n  }\n};\n\n/**\n * Mapper 066 (GxROM)\n *\n * @description http://wiki.nesdev.com/w/index.php/INES_Mapper_066\n * @example Doraemon, Dragon Power, Gumshoe, Thunder & Lightning,\n * Super Mario Bros. + Duck Hunt\n * @constructor\n */\nMappers[66] = function(nes) {\n  this.nes = nes;\n  console.log(\"Mapper 66\");\n};\n\nMappers[66].prototype = new Mappers[0]();\n\nMappers[66].prototype.write = function(address, value) {\n  if (address < 0x8000) {\n    Mappers[0].prototype.write.apply(this, arguments);\n    return;\n  } else {\n    // Swap in the given PRG-ROM bank at 0x8000:\n    this.load32kRomBank((value >> 4) & 3, 0x8000);\n\n    // Swap in the given VROM bank at 0x0000:\n    this.load8kVromBank((value & 3) * 2, 0x0000);\n  }\n};\n\nmodule.exports = Mappers;\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// jsnes.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 4ad2b6d0fe0a02932a24","module.exports = {\n  copyArrayElements: function(src, srcPos, dest, destPos, length) {\n    for (var i = 0; i < length; ++i) {\n      dest[destPos + i] = src[srcPos + i];\n    }\n  },\n\n  copyArray: function(src) {\n    var dest = new Array(src.length);\n    for (var i = 0; i < src.length; i++) {\n      dest[i] = src[i];\n    }\n    return dest;\n  },\n\n  fromJSON: function(obj, state) {\n    for (var i = 0; i < obj.JSON_PROPERTIES.length; i++) {\n      obj[obj.JSON_PROPERTIES[i]] = state[obj.JSON_PROPERTIES[i]];\n    }\n  },\n\n  toJSON: function(obj) {\n    var state = {};\n    for (var i = 0; i < obj.JSON_PROPERTIES.length; i++) {\n      state[obj.JSON_PROPERTIES[i]] = obj[obj.JSON_PROPERTIES[i]];\n    }\n    return state;\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/utils.js\n// module id = 0\n// module chunks = 0 1","var Controller = function() {\n  this.state = new Array(8);\n  for (var i = 0; i < this.state.length; i++) {\n    this.state[i] = 0x40;\n  }\n};\n\nController.BUTTON_A = 0;\nController.BUTTON_B = 1;\nController.BUTTON_SELECT = 2;\nController.BUTTON_START = 3;\nController.BUTTON_UP = 4;\nController.BUTTON_DOWN = 5;\nController.BUTTON_LEFT = 6;\nController.BUTTON_RIGHT = 7;\n\nController.prototype = {\n  buttonDown: function(key) {\n    this.state[key] = 0x41;\n  },\n\n  buttonUp: function(key) {\n    this.state[key] = 0x40;\n  }\n};\n\nmodule.exports = Controller;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/controller.js\n// module id = 1\n// module chunks = 0 1","var Tile = function() {\n  // Tile data:\n  this.pix = new Array(64);\n\n  this.fbIndex = null;\n  this.tIndex = null;\n  this.x = null;\n  this.y = null;\n  this.w = null;\n  this.h = null;\n  this.incX = null;\n  this.incY = null;\n  this.palIndex = null;\n  this.tpri = null;\n  this.c = null;\n  this.initialized = false;\n  this.opaque = new Array(8);\n};\n\nTile.prototype = {\n  setBuffer: function(scanline) {\n    for (this.y = 0; this.y < 8; this.y++) {\n      this.setScanline(this.y, scanline[this.y], scanline[this.y + 8]);\n    }\n  },\n\n  setScanline: function(sline, b1, b2) {\n    this.initialized = true;\n    this.tIndex = sline << 3;\n    for (this.x = 0; this.x < 8; this.x++) {\n      this.pix[this.tIndex + this.x] =\n        ((b1 >> (7 - this.x)) & 1) + (((b2 >> (7 - this.x)) & 1) << 1);\n      if (this.pix[this.tIndex + this.x] === 0) {\n        this.opaque[sline] = false;\n      }\n    }\n  },\n\n  render: function(\n    buffer,\n    srcx1,\n    srcy1,\n    srcx2,\n    srcy2,\n    dx,\n    dy,\n    palAdd,\n    palette,\n    flipHorizontal,\n    flipVertical,\n    pri,\n    priTable\n  ) {\n    if (dx < -7 || dx >= 256 || dy < -7 || dy >= 240) {\n      return;\n    }\n\n    this.w = srcx2 - srcx1;\n    this.h = srcy2 - srcy1;\n\n    if (dx < 0) {\n      srcx1 -= dx;\n    }\n    if (dx + srcx2 >= 256) {\n      srcx2 = 256 - dx;\n    }\n\n    if (dy < 0) {\n      srcy1 -= dy;\n    }\n    if (dy + srcy2 >= 240) {\n      srcy2 = 240 - dy;\n    }\n\n    if (!flipHorizontal && !flipVertical) {\n      this.fbIndex = (dy << 8) + dx;\n      this.tIndex = 0;\n      for (this.y = 0; this.y < 8; this.y++) {\n        for (this.x = 0; this.x < 8; this.x++) {\n          if (\n            this.x >= srcx1 &&\n            this.x < srcx2 &&\n            this.y >= srcy1 &&\n            this.y < srcy2\n          ) {\n            this.palIndex = this.pix[this.tIndex];\n            this.tpri = priTable[this.fbIndex];\n            if (this.palIndex !== 0 && pri <= (this.tpri & 0xff)) {\n              //console.log(\"Rendering upright tile to buffer\");\n              buffer[this.fbIndex] = palette[this.palIndex + palAdd];\n              this.tpri = (this.tpri & 0xf00) | pri;\n              priTable[this.fbIndex] = this.tpri;\n            }\n          }\n          this.fbIndex++;\n          this.tIndex++;\n        }\n        this.fbIndex -= 8;\n        this.fbIndex += 256;\n      }\n    } else if (flipHorizontal && !flipVertical) {\n      this.fbIndex = (dy << 8) + dx;\n      this.tIndex = 7;\n      for (this.y = 0; this.y < 8; this.y++) {\n        for (this.x = 0; this.x < 8; this.x++) {\n          if (\n            this.x >= srcx1 &&\n            this.x < srcx2 &&\n            this.y >= srcy1 &&\n            this.y < srcy2\n          ) {\n            this.palIndex = this.pix[this.tIndex];\n            this.tpri = priTable[this.fbIndex];\n            if (this.palIndex !== 0 && pri <= (this.tpri & 0xff)) {\n              buffer[this.fbIndex] = palette[this.palIndex + palAdd];\n              this.tpri = (this.tpri & 0xf00) | pri;\n              priTable[this.fbIndex] = this.tpri;\n            }\n          }\n          this.fbIndex++;\n          this.tIndex--;\n        }\n        this.fbIndex -= 8;\n        this.fbIndex += 256;\n        this.tIndex += 16;\n      }\n    } else if (flipVertical && !flipHorizontal) {\n      this.fbIndex = (dy << 8) + dx;\n      this.tIndex = 56;\n      for (this.y = 0; this.y < 8; this.y++) {\n        for (this.x = 0; this.x < 8; this.x++) {\n          if (\n            this.x >= srcx1 &&\n            this.x < srcx2 &&\n            this.y >= srcy1 &&\n            this.y < srcy2\n          ) {\n            this.palIndex = this.pix[this.tIndex];\n            this.tpri = priTable[this.fbIndex];\n            if (this.palIndex !== 0 && pri <= (this.tpri & 0xff)) {\n              buffer[this.fbIndex] = palette[this.palIndex + palAdd];\n              this.tpri = (this.tpri & 0xf00) | pri;\n              priTable[this.fbIndex] = this.tpri;\n            }\n          }\n          this.fbIndex++;\n          this.tIndex++;\n        }\n        this.fbIndex -= 8;\n        this.fbIndex += 256;\n        this.tIndex -= 16;\n      }\n    } else {\n      this.fbIndex = (dy << 8) + dx;\n      this.tIndex = 63;\n      for (this.y = 0; this.y < 8; this.y++) {\n        for (this.x = 0; this.x < 8; this.x++) {\n          if (\n            this.x >= srcx1 &&\n            this.x < srcx2 &&\n            this.y >= srcy1 &&\n            this.y < srcy2\n          ) {\n            this.palIndex = this.pix[this.tIndex];\n            this.tpri = priTable[this.fbIndex];\n            if (this.palIndex !== 0 && pri <= (this.tpri & 0xff)) {\n              buffer[this.fbIndex] = palette[this.palIndex + palAdd];\n              this.tpri = (this.tpri & 0xf00) | pri;\n              priTable[this.fbIndex] = this.tpri;\n            }\n          }\n          this.fbIndex++;\n          this.tIndex--;\n        }\n        this.fbIndex -= 8;\n        this.fbIndex += 256;\n      }\n    }\n  },\n\n  isTransparent: function(x, y) {\n    return this.pix[(y << 3) + x] === 0;\n  },\n\n  toJSON: function() {\n    return {\n      opaque: this.opaque,\n      pix: this.pix\n    };\n  },\n\n  fromJSON: function(s) {\n    this.opaque = s.opaque;\n    this.pix = s.pix;\n  }\n};\n\nmodule.exports = Tile;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/tile.js\n// module id = 2\n// module chunks = 0 1","module.exports = {\n  Controller: require(\"./controller\"),\n  NES: require(\"./nes\"),\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.js\n// module id = 3\n// module chunks = 0 1","var CPU = require(\"./cpu\");\nvar Controller = require(\"./controller\");\nvar PPU = require(\"./ppu\");\nvar PAPU = require(\"./papu\");\nvar GameGenie = require(\"./gg\");\nvar ROM = require(\"./rom\");\n\nvar NES = function(opts) {\n  this.opts = {\n    onFrame: function() {},\n    onAudioSample: null,\n    onStatusUpdate: function() {},\n\n    // FIXME: not actually used except for in PAPU\n    preferredFrameRate: 60,\n\n    emulateSound: true,\n    sampleRate: 44100 // Sound sample rate in hz\n  };\n  if (typeof opts !== \"undefined\") {\n    var key;\n    for (key in this.opts) {\n      if (typeof opts[key] !== \"undefined\") {\n        this.opts[key] = opts[key];\n      }\n    }\n  }\n\n  this.frameTime = 1000 / this.opts.preferredFrameRate;\n\n  this.ui = {\n    writeFrame: this.opts.onFrame,\n    updateStatus: this.opts.onStatusUpdate\n  };\n  this.cpu = new CPU(this);\n  this.ppu = new PPU(this);\n  this.papu = new PAPU(this);\n  this.gameGenie = new GameGenie();\n  this.mmap = null; // set in loadROM()\n  this.controllers = {\n    1: new Controller(),\n    2: new Controller(),\n  };\n\n  this.ui.updateStatus(\"Ready to load a ROM.\");\n\n  this.frame = this.frame.bind(this);\n  this.buttonDown = this.buttonDown.bind(this);\n  this.buttonUp = this.buttonUp.bind(this);\n  this.zapperMove = this.zapperMove.bind(this);\n  this.zapperFireDown = this.zapperFireDown.bind(this);\n  this.zapperFireUp = this.zapperFireUp.bind(this);\n};\n\nNES.prototype = {\n  fpsFrameCount: 0,\n  romData: null,\n\n  // Resets the system\n  reset: function() {\n    if (this.mmap !== null) {\n      this.mmap.reset();\n    }\n\n    this.cpu.reset();\n    this.ppu.reset();\n    this.papu.reset();\n\n    this.lastFpsTime = null;\n    this.fpsFrameCount = 0;\n  },\n\n  frame: function() {\n    this.ppu.startFrame();\n    var cycles = 0;\n    var emulateSound = this.opts.emulateSound;\n    var cpu = this.cpu;\n    var ppu = this.ppu;\n    var papu = this.papu;\n    FRAMELOOP: for (;;) {\n      if (cpu.cyclesToHalt === 0) {\n        // Execute a CPU instruction\n        cycles = cpu.emulate();\n        if (emulateSound) {\n          papu.clockFrameCounter(cycles);\n        }\n        cycles *= 3;\n      } else {\n        if (cpu.cyclesToHalt > 8) {\n          cycles = 24;\n          if (emulateSound) {\n            papu.clockFrameCounter(8);\n          }\n          cpu.cyclesToHalt -= 8;\n        } else {\n          cycles = cpu.cyclesToHalt * 3;\n          if (emulateSound) {\n            papu.clockFrameCounter(cpu.cyclesToHalt);\n          }\n          cpu.cyclesToHalt = 0;\n        }\n      }\n\n      for (; cycles > 0; cycles--) {\n        if (\n          ppu.curX === ppu.spr0HitX &&\n          ppu.f_spVisibility === 1 &&\n          ppu.scanline - 21 === ppu.spr0HitY\n        ) {\n          // Set sprite 0 hit flag:\n          ppu.setStatusFlag(ppu.STATUS_SPRITE0HIT, true);\n        }\n\n        if (ppu.requestEndFrame) {\n          ppu.nmiCounter--;\n          if (ppu.nmiCounter === 0) {\n            ppu.requestEndFrame = false;\n            ppu.startVBlank();\n            break FRAMELOOP;\n          }\n        }\n\n        ppu.curX++;\n        if (ppu.curX === 341) {\n          ppu.curX = 0;\n          ppu.endScanline();\n        }\n      }\n    }\n    this.fpsFrameCount++;\n  },\n\n  buttonDown: function(controller, button) {\n    this.controllers[controller].buttonDown(button);\n  },\n\n  buttonUp: function(controller, button) {\n    this.controllers[controller].buttonUp(button);\n  },\n\n  zapperMove: function(x, y) {\n    if (!this.mmap) return;\n    this.mmap.zapperX = x;\n    this.mmap.zapperY = y;\n  },\n\n  zapperFireDown: function() {\n    if (!this.mmap) return;\n    this.mmap.zapperFired = true;\n  },\n\n  zapperFireUp: function() {\n    if (!this.mmap) return;\n    this.mmap.zapperFired = false;\n  },\n\n  getFPS: function() {\n    var now = +new Date();\n    var fps = null;\n    if (this.lastFpsTime) {\n      fps = this.fpsFrameCount / ((now - this.lastFpsTime) / 1000);\n    }\n    this.fpsFrameCount = 0;\n    this.lastFpsTime = now;\n    return fps;\n  },\n\n  reloadROM: function() {\n    if (this.romData !== null) {\n      this.loadROM(this.romData);\n    }\n  },\n\n  // Loads a ROM file into the CPU and PPU.\n  // The ROM file is validated first.\n  loadROM: function(data) {\n    // Load ROM file:\n    this.rom = new ROM(this);\n    this.rom.load(data);\n\n    this.reset();\n    this.mmap = this.rom.createMapper();\n    this.mmap.loadROM();\n    this.ppu.setMirroring(this.rom.getMirroringType());\n    this.romData = data;\n  },\n\n  setFramerate: function(rate) {\n    this.opts.preferredFrameRate = rate;\n    this.frameTime = 1000 / rate;\n    this.papu.setSampleRate(this.opts.sampleRate, false);\n  },\n\n  toJSON: function() {\n    return {\n      romData: this.romData,\n      cpu: this.cpu.toJSON(),\n      mmap: this.mmap.toJSON(),\n      ppu: this.ppu.toJSON()\n    };\n  },\n\n  fromJSON: function(s) {\n    this.loadROM(s.romData);\n    this.cpu.fromJSON(s.cpu);\n    this.mmap.fromJSON(s.mmap);\n    this.ppu.fromJSON(s.ppu);\n  }\n};\n\nmodule.exports = NES;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/nes.js\n// module id = 4\n// module chunks = 0 1","var utils = require(\"./utils\");\n\nvar CPU = function(nes) {\n  this.nes = nes;\n\n  // Keep Chrome happy\n  this.mem = null;\n  this.REG_ACC = null;\n  this.REG_X = null;\n  this.REG_Y = null;\n  this.REG_SP = null;\n  this.REG_PC = null;\n  this.REG_PC_NEW = null;\n  this.REG_STATUS = null;\n  this.F_CARRY = null;\n  this.F_DECIMAL = null;\n  this.F_INTERRUPT = null;\n  this.F_INTERRUPT_NEW = null;\n  this.F_OVERFLOW = null;\n  this.F_SIGN = null;\n  this.F_ZERO = null;\n  this.F_NOTUSED = null;\n  this.F_NOTUSED_NEW = null;\n  this.F_BRK = null;\n  this.F_BRK_NEW = null;\n  this.opdata = null;\n  this.cyclesToHalt = null;\n  this.crash = null;\n  this.irqRequested = null;\n  this.irqType = null;\n\n  this.reset();\n};\n\nCPU.prototype = {\n  // IRQ Types\n  IRQ_NORMAL: 0,\n  IRQ_NMI: 1,\n  IRQ_RESET: 2,\n\n  reset: function() {\n    // Main memory\n    this.mem = new Array(0x10000);\n\n    for (var i = 0; i < 0x2000; i++) {\n      this.mem[i] = 0xff;\n    }\n    for (var p = 0; p < 4; p++) {\n      var j = p * 0x800;\n      this.mem[j + 0x008] = 0xf7;\n      this.mem[j + 0x009] = 0xef;\n      this.mem[j + 0x00a] = 0xdf;\n      this.mem[j + 0x00f] = 0xbf;\n    }\n    for (var k = 0x2001; k < this.mem.length; k++) {\n      this.mem[k] = 0;\n    }\n\n    // CPU Registers:\n    this.REG_ACC = 0;\n    this.REG_X = 0;\n    this.REG_Y = 0;\n    // Reset Stack pointer:\n    this.REG_SP = 0x01ff;\n    // Reset Program counter:\n    this.REG_PC = 0x8000 - 1;\n    this.REG_PC_NEW = 0x8000 - 1;\n    // Reset Status register:\n    this.REG_STATUS = 0x28;\n\n    this.setStatus(0x28);\n\n    // Set flags:\n    this.F_CARRY = 0;\n    this.F_DECIMAL = 0;\n    this.F_INTERRUPT = 1;\n    this.F_INTERRUPT_NEW = 1;\n    this.F_OVERFLOW = 0;\n    this.F_SIGN = 0;\n    this.F_ZERO = 1;\n\n    this.F_NOTUSED = 1;\n    this.F_NOTUSED_NEW = 1;\n    this.F_BRK = 1;\n    this.F_BRK_NEW = 1;\n\n    this.opdata = new OpData().opdata;\n    this.cyclesToHalt = 0;\n\n    // Reset crash flag:\n    this.crash = false;\n\n    // Interrupt notification:\n    this.irqRequested = false;\n    this.irqType = null;\n  },\n\n  // Emulates a single CPU instruction, returns the number of cycles\n  emulate: function() {\n    var temp;\n    var add;\n\n    // Check interrupts:\n    if (this.irqRequested) {\n      temp =\n        this.F_CARRY |\n        ((this.F_ZERO === 0 ? 1 : 0) << 1) |\n        (this.F_INTERRUPT << 2) |\n        (this.F_DECIMAL << 3) |\n        (this.F_BRK << 4) |\n        (this.F_NOTUSED << 5) |\n        (this.F_OVERFLOW << 6) |\n        (this.F_SIGN << 7);\n\n      this.REG_PC_NEW = this.REG_PC;\n      this.F_INTERRUPT_NEW = this.F_INTERRUPT;\n      switch (this.irqType) {\n        case 0: {\n          // Normal IRQ:\n          if (this.F_INTERRUPT !== 0) {\n            // console.log(\"Interrupt was masked.\");\n            break;\n          }\n          this.doIrq(temp);\n          // console.log(\"Did normal IRQ. I=\"+this.F_INTERRUPT);\n          break;\n        }\n        case 1: {\n          // NMI:\n          this.doNonMaskableInterrupt(temp);\n          break;\n        }\n        case 2: {\n          // Reset:\n          this.doResetInterrupt();\n          break;\n        }\n      }\n\n      this.REG_PC = this.REG_PC_NEW;\n      this.F_INTERRUPT = this.F_INTERRUPT_NEW;\n      this.F_BRK = this.F_BRK_NEW;\n      this.irqRequested = false;\n    }\n\n    var opinf = this.opdata[this.loadFromCartridge(this.REG_PC + 1)];\n    var cycleCount = opinf >> 24;\n    var cycleAdd = 0;\n\n    // Find address mode:\n    var addrMode = (opinf >> 8) & 0xff;\n\n    // Increment PC by number of op bytes:\n    var opaddr = this.REG_PC;\n    this.REG_PC += (opinf >> 16) & 0xff;\n\n    var addr = 0;\n    switch (addrMode) {\n      case 0: {\n        // Zero Page mode. Use the address given after the opcode,\n        // but without high byte.\n        addr = this.load(opaddr + 2);\n        break;\n      }\n      case 1: {\n        // Relative mode.\n        addr = this.load(opaddr + 2);\n        if (addr < 0x80) {\n          addr += this.REG_PC;\n        } else {\n          addr += this.REG_PC - 256;\n        }\n        break;\n      }\n      case 2: {\n        // Ignore. Address is implied in instruction.\n        break;\n      }\n      case 3: {\n        // Absolute mode. Use the two bytes following the opcode as\n        // an address.\n        addr = this.load16bit(opaddr + 2);\n        break;\n      }\n      case 4: {\n        // Accumulator mode. The address is in the accumulator\n        // register.\n        addr = this.REG_ACC;\n        break;\n      }\n      case 5: {\n        // Immediate mode. The value is given after the opcode.\n        addr = this.REG_PC;\n        break;\n      }\n      case 6: {\n        // Zero Page Indexed mode, X as index. Use the address given\n        // after the opcode, then add the\n        // X register to it to get the final address.\n        addr = (this.load(opaddr + 2) + this.REG_X) & 0xff;\n        break;\n      }\n      case 7: {\n        // Zero Page Indexed mode, Y as index. Use the address given\n        // after the opcode, then add the\n        // Y register to it to get the final address.\n        addr = (this.load(opaddr + 2) + this.REG_Y) & 0xff;\n        break;\n      }\n      case 8: {\n        // Absolute Indexed Mode, X as index. Same as zero page\n        // indexed, but with the high byte.\n        addr = this.load16bit(opaddr + 2);\n        if ((addr & 0xff00) !== ((addr + this.REG_X) & 0xff00)) {\n          cycleAdd = 1;\n        }\n        addr += this.REG_X;\n        break;\n      }\n      case 9: {\n        // Absolute Indexed Mode, Y as index. Same as zero page\n        // indexed, but with the high byte.\n        addr = this.load16bit(opaddr + 2);\n        if ((addr & 0xff00) !== ((addr + this.REG_Y) & 0xff00)) {\n          cycleAdd = 1;\n        }\n        addr += this.REG_Y;\n        break;\n      }\n      case 10: {\n        // Pre-indexed Indirect mode. Find the 16-bit address\n        // starting at the given location plus\n        // the current X register. The value is the contents of that\n        // address.\n        addr = this.load(opaddr + 2);\n        if ((addr & 0xff00) !== ((addr + this.REG_X) & 0xff00)) {\n          cycleAdd = 1;\n        }\n        addr += this.REG_X;\n        addr &= 0xff;\n        addr = this.load16bit(addr);\n        break;\n      }\n      case 11: {\n        // Post-indexed Indirect mode. Find the 16-bit address\n        // contained in the given location\n        // (and the one following). Add to that address the contents\n        // of the Y register. Fetch the value\n        // stored at that adress.\n        addr = this.load16bit(this.load(opaddr + 2));\n        if ((addr & 0xff00) !== ((addr + this.REG_Y) & 0xff00)) {\n          cycleAdd = 1;\n        }\n        addr += this.REG_Y;\n        break;\n      }\n      case 12: {\n        // Indirect Absolute mode. Find the 16-bit address contained\n        // at the given location.\n        addr = this.load16bit(opaddr + 2); // Find op\n        if (addr < 0x1fff) {\n          addr =\n            this.mem[addr] +\n            (this.mem[(addr & 0xff00) | (((addr & 0xff) + 1) & 0xff)] << 8); // Read from address given in op\n        } else {\n          addr =\n            this.loadFromCartridge(addr) +\n            (this.loadFromCartridge(\n              (addr & 0xff00) | (((addr & 0xff) + 1) & 0xff)\n            ) <<\n              8);\n        }\n        break;\n      }\n    }\n    // Wrap around for addresses above 0xFFFF:\n    addr &= 0xffff;\n\n    // ----------------------------------------------------------------------------------------------------\n    // Decode & execute instruction:\n    // ----------------------------------------------------------------------------------------------------\n\n    // This should be compiled to a jump table.\n    switch (opinf & 0xff) {\n      case 0: {\n        // *******\n        // * ADC *\n        // *******\n\n        // Add with carry.\n        temp = this.REG_ACC + this.load(addr) + this.F_CARRY;\n\n        if (\n          ((this.REG_ACC ^ this.load(addr)) & 0x80) === 0 &&\n          ((this.REG_ACC ^ temp) & 0x80) !== 0\n        ) {\n          this.F_OVERFLOW = 1;\n        } else {\n          this.F_OVERFLOW = 0;\n        }\n        this.F_CARRY = temp > 255 ? 1 : 0;\n        this.F_SIGN = (temp >> 7) & 1;\n        this.F_ZERO = temp & 0xff;\n        this.REG_ACC = temp & 255;\n        cycleCount += cycleAdd;\n        break;\n      }\n      case 1: {\n        // *******\n        // * AND *\n        // *******\n\n        // AND memory with accumulator.\n        this.REG_ACC = this.REG_ACC & this.load(addr);\n        this.F_SIGN = (this.REG_ACC >> 7) & 1;\n        this.F_ZERO = this.REG_ACC;\n        //this.REG_ACC = temp;\n        if (addrMode !== 11) cycleCount += cycleAdd; // PostIdxInd = 11\n        break;\n      }\n      case 2: {\n        // *******\n        // * ASL *\n        // *******\n\n        // Shift left one bit\n        if (addrMode === 4) {\n          // ADDR_ACC = 4\n\n          this.F_CARRY = (this.REG_ACC >> 7) & 1;\n          this.REG_ACC = (this.REG_ACC << 1) & 255;\n          this.F_SIGN = (this.REG_ACC >> 7) & 1;\n          this.F_ZERO = this.REG_ACC;\n        } else {\n          temp = this.load(addr);\n          this.F_CARRY = (temp >> 7) & 1;\n          temp = (temp << 1) & 255;\n          this.F_SIGN = (temp >> 7) & 1;\n          this.F_ZERO = temp;\n          this.write(addr, temp);\n        }\n        break;\n      }\n      case 3: {\n        // *******\n        // * BCC *\n        // *******\n\n        // Branch on carry clear\n        if (this.F_CARRY === 0) {\n          cycleCount += (opaddr & 0xff00) !== (addr & 0xff00) ? 2 : 1;\n          this.REG_PC = addr;\n        }\n        break;\n      }\n      case 4: {\n        // *******\n        // * BCS *\n        // *******\n\n        // Branch on carry set\n        if (this.F_CARRY === 1) {\n          cycleCount += (opaddr & 0xff00) !== (addr & 0xff00) ? 2 : 1;\n          this.REG_PC = addr;\n        }\n        break;\n      }\n      case 5: {\n        // *******\n        // * BEQ *\n        // *******\n\n        // Branch on zero\n        if (this.F_ZERO === 0) {\n          cycleCount += (opaddr & 0xff00) !== (addr & 0xff00) ? 2 : 1;\n          this.REG_PC = addr;\n        }\n        break;\n      }\n      case 6: {\n        // *******\n        // * BIT *\n        // *******\n\n        temp = this.load(addr);\n        this.F_SIGN = (temp >> 7) & 1;\n        this.F_OVERFLOW = (temp >> 6) & 1;\n        temp &= this.REG_ACC;\n        this.F_ZERO = temp;\n        break;\n      }\n      case 7: {\n        // *******\n        // * BMI *\n        // *******\n\n        // Branch on negative result\n        if (this.F_SIGN === 1) {\n          cycleCount++;\n          this.REG_PC = addr;\n        }\n        break;\n      }\n      case 8: {\n        // *******\n        // * BNE *\n        // *******\n\n        // Branch on not zero\n        if (this.F_ZERO !== 0) {\n          cycleCount += (opaddr & 0xff00) !== (addr & 0xff00) ? 2 : 1;\n          this.REG_PC = addr;\n        }\n        break;\n      }\n      case 9: {\n        // *******\n        // * BPL *\n        // *******\n\n        // Branch on positive result\n        if (this.F_SIGN === 0) {\n          cycleCount += (opaddr & 0xff00) !== (addr & 0xff00) ? 2 : 1;\n          this.REG_PC = addr;\n        }\n        break;\n      }\n      case 10: {\n        // *******\n        // * BRK *\n        // *******\n\n        this.REG_PC += 2;\n        this.push((this.REG_PC >> 8) & 255);\n        this.push(this.REG_PC & 255);\n        this.F_BRK = 1;\n\n        this.push(\n          this.F_CARRY |\n            ((this.F_ZERO === 0 ? 1 : 0) << 1) |\n            (this.F_INTERRUPT << 2) |\n            (this.F_DECIMAL << 3) |\n            (this.F_BRK << 4) |\n            (this.F_NOTUSED << 5) |\n            (this.F_OVERFLOW << 6) |\n            (this.F_SIGN << 7)\n        );\n\n        this.F_INTERRUPT = 1;\n        //this.REG_PC = load(0xFFFE) | (load(0xFFFF) << 8);\n        this.REG_PC = this.load16bit(0xfffe);\n        this.REG_PC--;\n        break;\n      }\n      case 11: {\n        // *******\n        // * BVC *\n        // *******\n\n        // Branch on overflow clear\n        if (this.F_OVERFLOW === 0) {\n          cycleCount += (opaddr & 0xff00) !== (addr & 0xff00) ? 2 : 1;\n          this.REG_PC = addr;\n        }\n        break;\n      }\n      case 12: {\n        // *******\n        // * BVS *\n        // *******\n\n        // Branch on overflow set\n        if (this.F_OVERFLOW === 1) {\n          cycleCount += (opaddr & 0xff00) !== (addr & 0xff00) ? 2 : 1;\n          this.REG_PC = addr;\n        }\n        break;\n      }\n      case 13: {\n        // *******\n        // * CLC *\n        // *******\n\n        // Clear carry flag\n        this.F_CARRY = 0;\n        break;\n      }\n      case 14: {\n        // *******\n        // * CLD *\n        // *******\n\n        // Clear decimal flag\n        this.F_DECIMAL = 0;\n        break;\n      }\n      case 15: {\n        // *******\n        // * CLI *\n        // *******\n\n        // Clear interrupt flag\n        this.F_INTERRUPT = 0;\n        break;\n      }\n      case 16: {\n        // *******\n        // * CLV *\n        // *******\n\n        // Clear overflow flag\n        this.F_OVERFLOW = 0;\n        break;\n      }\n      case 17: {\n        // *******\n        // * CMP *\n        // *******\n\n        // Compare memory and accumulator:\n        temp = this.REG_ACC - this.load(addr);\n        this.F_CARRY = temp >= 0 ? 1 : 0;\n        this.F_SIGN = (temp >> 7) & 1;\n        this.F_ZERO = temp & 0xff;\n        cycleCount += cycleAdd;\n        break;\n      }\n      case 18: {\n        // *******\n        // * CPX *\n        // *******\n\n        // Compare memory and index X:\n        temp = this.REG_X - this.load(addr);\n        this.F_CARRY = temp >= 0 ? 1 : 0;\n        this.F_SIGN = (temp >> 7) & 1;\n        this.F_ZERO = temp & 0xff;\n        break;\n      }\n      case 19: {\n        // *******\n        // * CPY *\n        // *******\n\n        // Compare memory and index Y:\n        temp = this.REG_Y - this.load(addr);\n        this.F_CARRY = temp >= 0 ? 1 : 0;\n        this.F_SIGN = (temp >> 7) & 1;\n        this.F_ZERO = temp & 0xff;\n        break;\n      }\n      case 20: {\n        // *******\n        // * DEC *\n        // *******\n\n        // Decrement memory by one:\n        temp = (this.load(addr) - 1) & 0xff;\n        this.F_SIGN = (temp >> 7) & 1;\n        this.F_ZERO = temp;\n        this.write(addr, temp);\n        break;\n      }\n      case 21: {\n        // *******\n        // * DEX *\n        // *******\n\n        // Decrement index X by one:\n        this.REG_X = (this.REG_X - 1) & 0xff;\n        this.F_SIGN = (this.REG_X >> 7) & 1;\n        this.F_ZERO = this.REG_X;\n        break;\n      }\n      case 22: {\n        // *******\n        // * DEY *\n        // *******\n\n        // Decrement index Y by one:\n        this.REG_Y = (this.REG_Y - 1) & 0xff;\n        this.F_SIGN = (this.REG_Y >> 7) & 1;\n        this.F_ZERO = this.REG_Y;\n        break;\n      }\n      case 23: {\n        // *******\n        // * EOR *\n        // *******\n\n        // XOR Memory with accumulator, store in accumulator:\n        this.REG_ACC = (this.load(addr) ^ this.REG_ACC) & 0xff;\n        this.F_SIGN = (this.REG_ACC >> 7) & 1;\n        this.F_ZERO = this.REG_ACC;\n        cycleCount += cycleAdd;\n        break;\n      }\n      case 24: {\n        // *******\n        // * INC *\n        // *******\n\n        // Increment memory by one:\n        temp = (this.load(addr) + 1) & 0xff;\n        this.F_SIGN = (temp >> 7) & 1;\n        this.F_ZERO = temp;\n        this.write(addr, temp & 0xff);\n        break;\n      }\n      case 25: {\n        // *******\n        // * INX *\n        // *******\n\n        // Increment index X by one:\n        this.REG_X = (this.REG_X + 1) & 0xff;\n        this.F_SIGN = (this.REG_X >> 7) & 1;\n        this.F_ZERO = this.REG_X;\n        break;\n      }\n      case 26: {\n        // *******\n        // * INY *\n        // *******\n\n        // Increment index Y by one:\n        this.REG_Y++;\n        this.REG_Y &= 0xff;\n        this.F_SIGN = (this.REG_Y >> 7) & 1;\n        this.F_ZERO = this.REG_Y;\n        break;\n      }\n      case 27: {\n        // *******\n        // * JMP *\n        // *******\n\n        // Jump to new location:\n        this.REG_PC = addr - 1;\n        break;\n      }\n      case 28: {\n        // *******\n        // * JSR *\n        // *******\n\n        // Jump to new location, saving return address.\n        // Push return address on stack:\n        this.push((this.REG_PC >> 8) & 255);\n        this.push(this.REG_PC & 255);\n        this.REG_PC = addr - 1;\n        break;\n      }\n      case 29: {\n        // *******\n        // * LDA *\n        // *******\n\n        // Load accumulator with memory:\n        this.REG_ACC = this.load(addr);\n        this.F_SIGN = (this.REG_ACC >> 7) & 1;\n        this.F_ZERO = this.REG_ACC;\n        cycleCount += cycleAdd;\n        break;\n      }\n      case 30: {\n        // *******\n        // * LDX *\n        // *******\n\n        // Load index X with memory:\n        this.REG_X = this.load(addr);\n        this.F_SIGN = (this.REG_X >> 7) & 1;\n        this.F_ZERO = this.REG_X;\n        cycleCount += cycleAdd;\n        break;\n      }\n      case 31: {\n        // *******\n        // * LDY *\n        // *******\n\n        // Load index Y with memory:\n        this.REG_Y = this.load(addr);\n        this.F_SIGN = (this.REG_Y >> 7) & 1;\n        this.F_ZERO = this.REG_Y;\n        cycleCount += cycleAdd;\n        break;\n      }\n      case 32: {\n        // *******\n        // * LSR *\n        // *******\n\n        // Shift right one bit:\n        if (addrMode === 4) {\n          // ADDR_ACC\n\n          temp = this.REG_ACC & 0xff;\n          this.F_CARRY = temp & 1;\n          temp >>= 1;\n          this.REG_ACC = temp;\n        } else {\n          temp = this.load(addr) & 0xff;\n          this.F_CARRY = temp & 1;\n          temp >>= 1;\n          this.write(addr, temp);\n        }\n        this.F_SIGN = 0;\n        this.F_ZERO = temp;\n        break;\n      }\n      case 33: {\n        // *******\n        // * NOP *\n        // *******\n\n        // No OPeration.\n        // Ignore.\n        break;\n      }\n      case 34: {\n        // *******\n        // * ORA *\n        // *******\n\n        // OR memory with accumulator, store in accumulator.\n        temp = (this.load(addr) | this.REG_ACC) & 255;\n        this.F_SIGN = (temp >> 7) & 1;\n        this.F_ZERO = temp;\n        this.REG_ACC = temp;\n        if (addrMode !== 11) cycleCount += cycleAdd; // PostIdxInd = 11\n        break;\n      }\n      case 35: {\n        // *******\n        // * PHA *\n        // *******\n\n        // Push accumulator on stack\n        this.push(this.REG_ACC);\n        break;\n      }\n      case 36: {\n        // *******\n        // * PHP *\n        // *******\n\n        // Push processor status on stack\n        this.F_BRK = 1;\n        this.push(\n          this.F_CARRY |\n            ((this.F_ZERO === 0 ? 1 : 0) << 1) |\n            (this.F_INTERRUPT << 2) |\n            (this.F_DECIMAL << 3) |\n            (this.F_BRK << 4) |\n            (this.F_NOTUSED << 5) |\n            (this.F_OVERFLOW << 6) |\n            (this.F_SIGN << 7)\n        );\n        break;\n      }\n      case 37: {\n        // *******\n        // * PLA *\n        // *******\n\n        // Pull accumulator from stack\n        this.REG_ACC = this.pull();\n        this.F_SIGN = (this.REG_ACC >> 7) & 1;\n        this.F_ZERO = this.REG_ACC;\n        break;\n      }\n      case 38: {\n        // *******\n        // * PLP *\n        // *******\n\n        // Pull processor status from stack\n        temp = this.pull();\n        this.F_CARRY = temp & 1;\n        this.F_ZERO = ((temp >> 1) & 1) === 1 ? 0 : 1;\n        this.F_INTERRUPT = (temp >> 2) & 1;\n        this.F_DECIMAL = (temp >> 3) & 1;\n        this.F_BRK = (temp >> 4) & 1;\n        this.F_NOTUSED = (temp >> 5) & 1;\n        this.F_OVERFLOW = (temp >> 6) & 1;\n        this.F_SIGN = (temp >> 7) & 1;\n\n        this.F_NOTUSED = 1;\n        break;\n      }\n      case 39: {\n        // *******\n        // * ROL *\n        // *******\n\n        // Rotate one bit left\n        if (addrMode === 4) {\n          // ADDR_ACC = 4\n\n          temp = this.REG_ACC;\n          add = this.F_CARRY;\n          this.F_CARRY = (temp >> 7) & 1;\n          temp = ((temp << 1) & 0xff) + add;\n          this.REG_ACC = temp;\n        } else {\n          temp = this.load(addr);\n          add = this.F_CARRY;\n          this.F_CARRY = (temp >> 7) & 1;\n          temp = ((temp << 1) & 0xff) + add;\n          this.write(addr, temp);\n        }\n        this.F_SIGN = (temp >> 7) & 1;\n        this.F_ZERO = temp;\n        break;\n      }\n      case 40: {\n        // *******\n        // * ROR *\n        // *******\n\n        // Rotate one bit right\n        if (addrMode === 4) {\n          // ADDR_ACC = 4\n\n          add = this.F_CARRY << 7;\n          this.F_CARRY = this.REG_ACC & 1;\n          temp = (this.REG_ACC >> 1) + add;\n          this.REG_ACC = temp;\n        } else {\n          temp = this.load(addr);\n          add = this.F_CARRY << 7;\n          this.F_CARRY = temp & 1;\n          temp = (temp >> 1) + add;\n          this.write(addr, temp);\n        }\n        this.F_SIGN = (temp >> 7) & 1;\n        this.F_ZERO = temp;\n        break;\n      }\n      case 41: {\n        // *******\n        // * RTI *\n        // *******\n\n        // Return from interrupt. Pull status and PC from stack.\n\n        temp = this.pull();\n        this.F_CARRY = temp & 1;\n        this.F_ZERO = ((temp >> 1) & 1) === 0 ? 1 : 0;\n        this.F_INTERRUPT = (temp >> 2) & 1;\n        this.F_DECIMAL = (temp >> 3) & 1;\n        this.F_BRK = (temp >> 4) & 1;\n        this.F_NOTUSED = (temp >> 5) & 1;\n        this.F_OVERFLOW = (temp >> 6) & 1;\n        this.F_SIGN = (temp >> 7) & 1;\n\n        this.REG_PC = this.pull();\n        this.REG_PC += this.pull() << 8;\n        if (this.REG_PC === 0xffff) {\n          return;\n        }\n        this.REG_PC--;\n        this.F_NOTUSED = 1;\n        break;\n      }\n      case 42: {\n        // *******\n        // * RTS *\n        // *******\n\n        // Return from subroutine. Pull PC from stack.\n\n        this.REG_PC = this.pull();\n        this.REG_PC += this.pull() << 8;\n\n        if (this.REG_PC === 0xffff) {\n          return; // return from NSF play routine:\n        }\n        break;\n      }\n      case 43: {\n        // *******\n        // * SBC *\n        // *******\n\n        temp = this.REG_ACC - this.load(addr) - (1 - this.F_CARRY);\n        this.F_SIGN = (temp >> 7) & 1;\n        this.F_ZERO = temp & 0xff;\n        if (\n          ((this.REG_ACC ^ temp) & 0x80) !== 0 &&\n          ((this.REG_ACC ^ this.load(addr)) & 0x80) !== 0\n        ) {\n          this.F_OVERFLOW = 1;\n        } else {\n          this.F_OVERFLOW = 0;\n        }\n        this.F_CARRY = temp < 0 ? 0 : 1;\n        this.REG_ACC = temp & 0xff;\n        if (addrMode !== 11) cycleCount += cycleAdd; // PostIdxInd = 11\n        break;\n      }\n      case 44: {\n        // *******\n        // * SEC *\n        // *******\n\n        // Set carry flag\n        this.F_CARRY = 1;\n        break;\n      }\n      case 45: {\n        // *******\n        // * SED *\n        // *******\n\n        // Set decimal mode\n        this.F_DECIMAL = 1;\n        break;\n      }\n      case 46: {\n        // *******\n        // * SEI *\n        // *******\n\n        // Set interrupt disable status\n        this.F_INTERRUPT = 1;\n        break;\n      }\n      case 47: {\n        // *******\n        // * STA *\n        // *******\n\n        // Store accumulator in memory\n        this.write(addr, this.REG_ACC);\n        break;\n      }\n      case 48: {\n        // *******\n        // * STX *\n        // *******\n\n        // Store index X in memory\n        this.write(addr, this.REG_X);\n        break;\n      }\n      case 49: {\n        // *******\n        // * STY *\n        // *******\n\n        // Store index Y in memory:\n        this.write(addr, this.REG_Y);\n        break;\n      }\n      case 50: {\n        // *******\n        // * TAX *\n        // *******\n\n        // Transfer accumulator to index X:\n        this.REG_X = this.REG_ACC;\n        this.F_SIGN = (this.REG_ACC >> 7) & 1;\n        this.F_ZERO = this.REG_ACC;\n        break;\n      }\n      case 51: {\n        // *******\n        // * TAY *\n        // *******\n\n        // Transfer accumulator to index Y:\n        this.REG_Y = this.REG_ACC;\n        this.F_SIGN = (this.REG_ACC >> 7) & 1;\n        this.F_ZERO = this.REG_ACC;\n        break;\n      }\n      case 52: {\n        // *******\n        // * TSX *\n        // *******\n\n        // Transfer stack pointer to index X:\n        this.REG_X = this.REG_SP - 0x0100;\n        this.F_SIGN = (this.REG_SP >> 7) & 1;\n        this.F_ZERO = this.REG_X;\n        break;\n      }\n      case 53: {\n        // *******\n        // * TXA *\n        // *******\n\n        // Transfer index X to accumulator:\n        this.REG_ACC = this.REG_X;\n        this.F_SIGN = (this.REG_X >> 7) & 1;\n        this.F_ZERO = this.REG_X;\n        break;\n      }\n      case 54: {\n        // *******\n        // * TXS *\n        // *******\n\n        // Transfer index X to stack pointer:\n        this.REG_SP = this.REG_X + 0x0100;\n        this.stackWrap();\n        break;\n      }\n      case 55: {\n        // *******\n        // * TYA *\n        // *******\n\n        // Transfer index Y to accumulator:\n        this.REG_ACC = this.REG_Y;\n        this.F_SIGN = (this.REG_Y >> 7) & 1;\n        this.F_ZERO = this.REG_Y;\n        break;\n      }\n      default: {\n        // *******\n        // * ??? *\n        // *******\n\n        this.nes.stop();\n        this.nes.crashMessage =\n          \"Game crashed, invalid opcode at address $\" + opaddr.toString(16);\n        break;\n      }\n    } // end of switch\n\n    return cycleCount;\n  },\n\n  loadFromCartridge: function(addr) {\n    var value = this.nes.mmap.load(addr);\n\n    if (this.nes.gameGenie.enabled) {\n      value = this.nes.gameGenie.applyCodes(addr, value);\n    }\n\n    return value;\n  },\n\n  load: function(addr) {\n    if (addr < 0x2000) {\n      return this.mem[addr & 0x7ff];\n    } else {\n      return this.loadFromCartridge(addr);\n    }\n  },\n\n  load16bit: function(addr) {\n    if (addr < 0x1fff) {\n      return this.mem[addr & 0x7ff] | (this.mem[(addr + 1) & 0x7ff] << 8);\n    } else {\n      return this.loadFromCartridge(addr) | (this.loadFromCartridge(addr + 1) << 8);\n    }\n  },\n\n  write: function(addr, val) {\n    if (addr < 0x2000) {\n      this.mem[addr & 0x7ff] = val;\n    } else {\n      this.nes.mmap.write(addr, val);\n    }\n  },\n\n  requestIrq: function(type) {\n    if (this.irqRequested) {\n      if (type === this.IRQ_NORMAL) {\n        return;\n      }\n      // console.log(\"too fast irqs. type=\"+type);\n    }\n    this.irqRequested = true;\n    this.irqType = type;\n  },\n\n  push: function(value) {\n    this.nes.mmap.write(this.REG_SP, value);\n    this.REG_SP--;\n    this.REG_SP = 0x0100 | (this.REG_SP & 0xff);\n  },\n\n  stackWrap: function() {\n    this.REG_SP = 0x0100 | (this.REG_SP & 0xff);\n  },\n\n  pull: function() {\n    this.REG_SP++;\n    this.REG_SP = 0x0100 | (this.REG_SP & 0xff);\n    return this.nes.mmap.load(this.REG_SP);\n  },\n\n  pageCrossed: function(addr1, addr2) {\n    return (addr1 & 0xff00) !== (addr2 & 0xff00);\n  },\n\n  haltCycles: function(cycles) {\n    this.cyclesToHalt += cycles;\n  },\n\n  doNonMaskableInterrupt: function(status) {\n    if ((this.nes.mmap.load(0x2000) & 128) !== 0) {\n      // Check whether VBlank Interrupts are enabled\n\n      this.REG_PC_NEW++;\n      this.push((this.REG_PC_NEW >> 8) & 0xff);\n      this.push(this.REG_PC_NEW & 0xff);\n      //this.F_INTERRUPT_NEW = 1;\n      this.push(status);\n\n      this.REG_PC_NEW =\n        this.loadFromCartridge(0xfffa) | (this.loadFromCartridge(0xfffb) << 8);\n      this.REG_PC_NEW--;\n    }\n  },\n\n  doResetInterrupt: function() {\n    this.REG_PC_NEW =\n      this.loadFromCartridge(0xfffc) | (this.loadFromCartridge(0xfffd) << 8);\n    this.REG_PC_NEW--;\n  },\n\n  doIrq: function(status) {\n    this.REG_PC_NEW++;\n    this.push((this.REG_PC_NEW >> 8) & 0xff);\n    this.push(this.REG_PC_NEW & 0xff);\n    this.push(status);\n    this.F_INTERRUPT_NEW = 1;\n    this.F_BRK_NEW = 0;\n\n    this.REG_PC_NEW =\n      this.loadFromCartridge(0xfffe) | (this.loadFromCartridge(0xffff) << 8);\n    this.REG_PC_NEW--;\n  },\n\n  getStatus: function() {\n    return (\n      this.F_CARRY |\n      (this.F_ZERO << 1) |\n      (this.F_INTERRUPT << 2) |\n      (this.F_DECIMAL << 3) |\n      (this.F_BRK << 4) |\n      (this.F_NOTUSED << 5) |\n      (this.F_OVERFLOW << 6) |\n      (this.F_SIGN << 7)\n    );\n  },\n\n  setStatus: function(st) {\n    this.F_CARRY = st & 1;\n    this.F_ZERO = (st >> 1) & 1;\n    this.F_INTERRUPT = (st >> 2) & 1;\n    this.F_DECIMAL = (st >> 3) & 1;\n    this.F_BRK = (st >> 4) & 1;\n    this.F_NOTUSED = (st >> 5) & 1;\n    this.F_OVERFLOW = (st >> 6) & 1;\n    this.F_SIGN = (st >> 7) & 1;\n  },\n\n  JSON_PROPERTIES: [\n    \"mem\",\n    \"cyclesToHalt\",\n    \"irqRequested\",\n    \"irqType\",\n    // Registers\n    \"REG_ACC\",\n    \"REG_X\",\n    \"REG_Y\",\n    \"REG_SP\",\n    \"REG_PC\",\n    \"REG_PC_NEW\",\n    \"REG_STATUS\",\n    // Status\n    \"F_CARRY\",\n    \"F_DECIMAL\",\n    \"F_INTERRUPT\",\n    \"F_INTERRUPT_NEW\",\n    \"F_OVERFLOW\",\n    \"F_SIGN\",\n    \"F_ZERO\",\n    \"F_NOTUSED\",\n    \"F_NOTUSED_NEW\",\n    \"F_BRK\",\n    \"F_BRK_NEW\"\n  ],\n\n  toJSON: function() {\n    return utils.toJSON(this);\n  },\n\n  fromJSON: function(s) {\n    utils.fromJSON(this, s);\n  }\n};\n\n// Generates and provides an array of details about instructions\nvar OpData = function() {\n  this.opdata = new Array(256);\n\n  // Set all to invalid instruction (to detect crashes):\n  for (var i = 0; i < 256; i++) this.opdata[i] = 0xff;\n\n  // Now fill in all valid opcodes:\n\n  // ADC:\n  this.setOp(this.INS_ADC, 0x69, this.ADDR_IMM, 2, 2);\n  this.setOp(this.INS_ADC, 0x65, this.ADDR_ZP, 2, 3);\n  this.setOp(this.INS_ADC, 0x75, this.ADDR_ZPX, 2, 4);\n  this.setOp(this.INS_ADC, 0x6d, this.ADDR_ABS, 3, 4);\n  this.setOp(this.INS_ADC, 0x7d, this.ADDR_ABSX, 3, 4);\n  this.setOp(this.INS_ADC, 0x79, this.ADDR_ABSY, 3, 4);\n  this.setOp(this.INS_ADC, 0x61, this.ADDR_PREIDXIND, 2, 6);\n  this.setOp(this.INS_ADC, 0x71, this.ADDR_POSTIDXIND, 2, 5);\n\n  // AND:\n  this.setOp(this.INS_AND, 0x29, this.ADDR_IMM, 2, 2);\n  this.setOp(this.INS_AND, 0x25, this.ADDR_ZP, 2, 3);\n  this.setOp(this.INS_AND, 0x35, this.ADDR_ZPX, 2, 4);\n  this.setOp(this.INS_AND, 0x2d, this.ADDR_ABS, 3, 4);\n  this.setOp(this.INS_AND, 0x3d, this.ADDR_ABSX, 3, 4);\n  this.setOp(this.INS_AND, 0x39, this.ADDR_ABSY, 3, 4);\n  this.setOp(this.INS_AND, 0x21, this.ADDR_PREIDXIND, 2, 6);\n  this.setOp(this.INS_AND, 0x31, this.ADDR_POSTIDXIND, 2, 5);\n\n  // ASL:\n  this.setOp(this.INS_ASL, 0x0a, this.ADDR_ACC, 1, 2);\n  this.setOp(this.INS_ASL, 0x06, this.ADDR_ZP, 2, 5);\n  this.setOp(this.INS_ASL, 0x16, this.ADDR_ZPX, 2, 6);\n  this.setOp(this.INS_ASL, 0x0e, this.ADDR_ABS, 3, 6);\n  this.setOp(this.INS_ASL, 0x1e, this.ADDR_ABSX, 3, 7);\n\n  // BCC:\n  this.setOp(this.INS_BCC, 0x90, this.ADDR_REL, 2, 2);\n\n  // BCS:\n  this.setOp(this.INS_BCS, 0xb0, this.ADDR_REL, 2, 2);\n\n  // BEQ:\n  this.setOp(this.INS_BEQ, 0xf0, this.ADDR_REL, 2, 2);\n\n  // BIT:\n  this.setOp(this.INS_BIT, 0x24, this.ADDR_ZP, 2, 3);\n  this.setOp(this.INS_BIT, 0x2c, this.ADDR_ABS, 3, 4);\n\n  // BMI:\n  this.setOp(this.INS_BMI, 0x30, this.ADDR_REL, 2, 2);\n\n  // BNE:\n  this.setOp(this.INS_BNE, 0xd0, this.ADDR_REL, 2, 2);\n\n  // BPL:\n  this.setOp(this.INS_BPL, 0x10, this.ADDR_REL, 2, 2);\n\n  // BRK:\n  this.setOp(this.INS_BRK, 0x00, this.ADDR_IMP, 1, 7);\n\n  // BVC:\n  this.setOp(this.INS_BVC, 0x50, this.ADDR_REL, 2, 2);\n\n  // BVS:\n  this.setOp(this.INS_BVS, 0x70, this.ADDR_REL, 2, 2);\n\n  // CLC:\n  this.setOp(this.INS_CLC, 0x18, this.ADDR_IMP, 1, 2);\n\n  // CLD:\n  this.setOp(this.INS_CLD, 0xd8, this.ADDR_IMP, 1, 2);\n\n  // CLI:\n  this.setOp(this.INS_CLI, 0x58, this.ADDR_IMP, 1, 2);\n\n  // CLV:\n  this.setOp(this.INS_CLV, 0xb8, this.ADDR_IMP, 1, 2);\n\n  // CMP:\n  this.setOp(this.INS_CMP, 0xc9, this.ADDR_IMM, 2, 2);\n  this.setOp(this.INS_CMP, 0xc5, this.ADDR_ZP, 2, 3);\n  this.setOp(this.INS_CMP, 0xd5, this.ADDR_ZPX, 2, 4);\n  this.setOp(this.INS_CMP, 0xcd, this.ADDR_ABS, 3, 4);\n  this.setOp(this.INS_CMP, 0xdd, this.ADDR_ABSX, 3, 4);\n  this.setOp(this.INS_CMP, 0xd9, this.ADDR_ABSY, 3, 4);\n  this.setOp(this.INS_CMP, 0xc1, this.ADDR_PREIDXIND, 2, 6);\n  this.setOp(this.INS_CMP, 0xd1, this.ADDR_POSTIDXIND, 2, 5);\n\n  // CPX:\n  this.setOp(this.INS_CPX, 0xe0, this.ADDR_IMM, 2, 2);\n  this.setOp(this.INS_CPX, 0xe4, this.ADDR_ZP, 2, 3);\n  this.setOp(this.INS_CPX, 0xec, this.ADDR_ABS, 3, 4);\n\n  // CPY:\n  this.setOp(this.INS_CPY, 0xc0, this.ADDR_IMM, 2, 2);\n  this.setOp(this.INS_CPY, 0xc4, this.ADDR_ZP, 2, 3);\n  this.setOp(this.INS_CPY, 0xcc, this.ADDR_ABS, 3, 4);\n\n  // DEC:\n  this.setOp(this.INS_DEC, 0xc6, this.ADDR_ZP, 2, 5);\n  this.setOp(this.INS_DEC, 0xd6, this.ADDR_ZPX, 2, 6);\n  this.setOp(this.INS_DEC, 0xce, this.ADDR_ABS, 3, 6);\n  this.setOp(this.INS_DEC, 0xde, this.ADDR_ABSX, 3, 7);\n\n  // DEX:\n  this.setOp(this.INS_DEX, 0xca, this.ADDR_IMP, 1, 2);\n\n  // DEY:\n  this.setOp(this.INS_DEY, 0x88, this.ADDR_IMP, 1, 2);\n\n  // EOR:\n  this.setOp(this.INS_EOR, 0x49, this.ADDR_IMM, 2, 2);\n  this.setOp(this.INS_EOR, 0x45, this.ADDR_ZP, 2, 3);\n  this.setOp(this.INS_EOR, 0x55, this.ADDR_ZPX, 2, 4);\n  this.setOp(this.INS_EOR, 0x4d, this.ADDR_ABS, 3, 4);\n  this.setOp(this.INS_EOR, 0x5d, this.ADDR_ABSX, 3, 4);\n  this.setOp(this.INS_EOR, 0x59, this.ADDR_ABSY, 3, 4);\n  this.setOp(this.INS_EOR, 0x41, this.ADDR_PREIDXIND, 2, 6);\n  this.setOp(this.INS_EOR, 0x51, this.ADDR_POSTIDXIND, 2, 5);\n\n  // INC:\n  this.setOp(this.INS_INC, 0xe6, this.ADDR_ZP, 2, 5);\n  this.setOp(this.INS_INC, 0xf6, this.ADDR_ZPX, 2, 6);\n  this.setOp(this.INS_INC, 0xee, this.ADDR_ABS, 3, 6);\n  this.setOp(this.INS_INC, 0xfe, this.ADDR_ABSX, 3, 7);\n\n  // INX:\n  this.setOp(this.INS_INX, 0xe8, this.ADDR_IMP, 1, 2);\n\n  // INY:\n  this.setOp(this.INS_INY, 0xc8, this.ADDR_IMP, 1, 2);\n\n  // JMP:\n  this.setOp(this.INS_JMP, 0x4c, this.ADDR_ABS, 3, 3);\n  this.setOp(this.INS_JMP, 0x6c, this.ADDR_INDABS, 3, 5);\n\n  // JSR:\n  this.setOp(this.INS_JSR, 0x20, this.ADDR_ABS, 3, 6);\n\n  // LDA:\n  this.setOp(this.INS_LDA, 0xa9, this.ADDR_IMM, 2, 2);\n  this.setOp(this.INS_LDA, 0xa5, this.ADDR_ZP, 2, 3);\n  this.setOp(this.INS_LDA, 0xb5, this.ADDR_ZPX, 2, 4);\n  this.setOp(this.INS_LDA, 0xad, this.ADDR_ABS, 3, 4);\n  this.setOp(this.INS_LDA, 0xbd, this.ADDR_ABSX, 3, 4);\n  this.setOp(this.INS_LDA, 0xb9, this.ADDR_ABSY, 3, 4);\n  this.setOp(this.INS_LDA, 0xa1, this.ADDR_PREIDXIND, 2, 6);\n  this.setOp(this.INS_LDA, 0xb1, this.ADDR_POSTIDXIND, 2, 5);\n\n  // LDX:\n  this.setOp(this.INS_LDX, 0xa2, this.ADDR_IMM, 2, 2);\n  this.setOp(this.INS_LDX, 0xa6, this.ADDR_ZP, 2, 3);\n  this.setOp(this.INS_LDX, 0xb6, this.ADDR_ZPY, 2, 4);\n  this.setOp(this.INS_LDX, 0xae, this.ADDR_ABS, 3, 4);\n  this.setOp(this.INS_LDX, 0xbe, this.ADDR_ABSY, 3, 4);\n\n  // LDY:\n  this.setOp(this.INS_LDY, 0xa0, this.ADDR_IMM, 2, 2);\n  this.setOp(this.INS_LDY, 0xa4, this.ADDR_ZP, 2, 3);\n  this.setOp(this.INS_LDY, 0xb4, this.ADDR_ZPX, 2, 4);\n  this.setOp(this.INS_LDY, 0xac, this.ADDR_ABS, 3, 4);\n  this.setOp(this.INS_LDY, 0xbc, this.ADDR_ABSX, 3, 4);\n\n  // LSR:\n  this.setOp(this.INS_LSR, 0x4a, this.ADDR_ACC, 1, 2);\n  this.setOp(this.INS_LSR, 0x46, this.ADDR_ZP, 2, 5);\n  this.setOp(this.INS_LSR, 0x56, this.ADDR_ZPX, 2, 6);\n  this.setOp(this.INS_LSR, 0x4e, this.ADDR_ABS, 3, 6);\n  this.setOp(this.INS_LSR, 0x5e, this.ADDR_ABSX, 3, 7);\n\n  // NOP:\n  this.setOp(this.INS_NOP, 0xea, this.ADDR_IMP, 1, 2);\n\n  // ORA:\n  this.setOp(this.INS_ORA, 0x09, this.ADDR_IMM, 2, 2);\n  this.setOp(this.INS_ORA, 0x05, this.ADDR_ZP, 2, 3);\n  this.setOp(this.INS_ORA, 0x15, this.ADDR_ZPX, 2, 4);\n  this.setOp(this.INS_ORA, 0x0d, this.ADDR_ABS, 3, 4);\n  this.setOp(this.INS_ORA, 0x1d, this.ADDR_ABSX, 3, 4);\n  this.setOp(this.INS_ORA, 0x19, this.ADDR_ABSY, 3, 4);\n  this.setOp(this.INS_ORA, 0x01, this.ADDR_PREIDXIND, 2, 6);\n  this.setOp(this.INS_ORA, 0x11, this.ADDR_POSTIDXIND, 2, 5);\n\n  // PHA:\n  this.setOp(this.INS_PHA, 0x48, this.ADDR_IMP, 1, 3);\n\n  // PHP:\n  this.setOp(this.INS_PHP, 0x08, this.ADDR_IMP, 1, 3);\n\n  // PLA:\n  this.setOp(this.INS_PLA, 0x68, this.ADDR_IMP, 1, 4);\n\n  // PLP:\n  this.setOp(this.INS_PLP, 0x28, this.ADDR_IMP, 1, 4);\n\n  // ROL:\n  this.setOp(this.INS_ROL, 0x2a, this.ADDR_ACC, 1, 2);\n  this.setOp(this.INS_ROL, 0x26, this.ADDR_ZP, 2, 5);\n  this.setOp(this.INS_ROL, 0x36, this.ADDR_ZPX, 2, 6);\n  this.setOp(this.INS_ROL, 0x2e, this.ADDR_ABS, 3, 6);\n  this.setOp(this.INS_ROL, 0x3e, this.ADDR_ABSX, 3, 7);\n\n  // ROR:\n  this.setOp(this.INS_ROR, 0x6a, this.ADDR_ACC, 1, 2);\n  this.setOp(this.INS_ROR, 0x66, this.ADDR_ZP, 2, 5);\n  this.setOp(this.INS_ROR, 0x76, this.ADDR_ZPX, 2, 6);\n  this.setOp(this.INS_ROR, 0x6e, this.ADDR_ABS, 3, 6);\n  this.setOp(this.INS_ROR, 0x7e, this.ADDR_ABSX, 3, 7);\n\n  // RTI:\n  this.setOp(this.INS_RTI, 0x40, this.ADDR_IMP, 1, 6);\n\n  // RTS:\n  this.setOp(this.INS_RTS, 0x60, this.ADDR_IMP, 1, 6);\n\n  // SBC:\n  this.setOp(this.INS_SBC, 0xe9, this.ADDR_IMM, 2, 2);\n  this.setOp(this.INS_SBC, 0xe5, this.ADDR_ZP, 2, 3);\n  this.setOp(this.INS_SBC, 0xf5, this.ADDR_ZPX, 2, 4);\n  this.setOp(this.INS_SBC, 0xed, this.ADDR_ABS, 3, 4);\n  this.setOp(this.INS_SBC, 0xfd, this.ADDR_ABSX, 3, 4);\n  this.setOp(this.INS_SBC, 0xf9, this.ADDR_ABSY, 3, 4);\n  this.setOp(this.INS_SBC, 0xe1, this.ADDR_PREIDXIND, 2, 6);\n  this.setOp(this.INS_SBC, 0xf1, this.ADDR_POSTIDXIND, 2, 5);\n\n  // SEC:\n  this.setOp(this.INS_SEC, 0x38, this.ADDR_IMP, 1, 2);\n\n  // SED:\n  this.setOp(this.INS_SED, 0xf8, this.ADDR_IMP, 1, 2);\n\n  // SEI:\n  this.setOp(this.INS_SEI, 0x78, this.ADDR_IMP, 1, 2);\n\n  // STA:\n  this.setOp(this.INS_STA, 0x85, this.ADDR_ZP, 2, 3);\n  this.setOp(this.INS_STA, 0x95, this.ADDR_ZPX, 2, 4);\n  this.setOp(this.INS_STA, 0x8d, this.ADDR_ABS, 3, 4);\n  this.setOp(this.INS_STA, 0x9d, this.ADDR_ABSX, 3, 5);\n  this.setOp(this.INS_STA, 0x99, this.ADDR_ABSY, 3, 5);\n  this.setOp(this.INS_STA, 0x81, this.ADDR_PREIDXIND, 2, 6);\n  this.setOp(this.INS_STA, 0x91, this.ADDR_POSTIDXIND, 2, 6);\n\n  // STX:\n  this.setOp(this.INS_STX, 0x86, this.ADDR_ZP, 2, 3);\n  this.setOp(this.INS_STX, 0x96, this.ADDR_ZPY, 2, 4);\n  this.setOp(this.INS_STX, 0x8e, this.ADDR_ABS, 3, 4);\n\n  // STY:\n  this.setOp(this.INS_STY, 0x84, this.ADDR_ZP, 2, 3);\n  this.setOp(this.INS_STY, 0x94, this.ADDR_ZPX, 2, 4);\n  this.setOp(this.INS_STY, 0x8c, this.ADDR_ABS, 3, 4);\n\n  // TAX:\n  this.setOp(this.INS_TAX, 0xaa, this.ADDR_IMP, 1, 2);\n\n  // TAY:\n  this.setOp(this.INS_TAY, 0xa8, this.ADDR_IMP, 1, 2);\n\n  // TSX:\n  this.setOp(this.INS_TSX, 0xba, this.ADDR_IMP, 1, 2);\n\n  // TXA:\n  this.setOp(this.INS_TXA, 0x8a, this.ADDR_IMP, 1, 2);\n\n  // TXS:\n  this.setOp(this.INS_TXS, 0x9a, this.ADDR_IMP, 1, 2);\n\n  // TYA:\n  this.setOp(this.INS_TYA, 0x98, this.ADDR_IMP, 1, 2);\n\n  // prettier-ignore\n  this.cycTable = new Array(\n    /*0x00*/ 7,6,2,8,3,3,5,5,3,2,2,2,4,4,6,6,\n    /*0x10*/ 2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7,\n    /*0x20*/ 6,6,2,8,3,3,5,5,4,2,2,2,4,4,6,6,\n    /*0x30*/ 2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7,\n    /*0x40*/ 6,6,2,8,3,3,5,5,3,2,2,2,3,4,6,6,\n    /*0x50*/ 2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7,\n    /*0x60*/ 6,6,2,8,3,3,5,5,4,2,2,2,5,4,6,6,\n    /*0x70*/ 2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7,\n    /*0x80*/ 2,6,2,6,3,3,3,3,2,2,2,2,4,4,4,4,\n    /*0x90*/ 2,6,2,6,4,4,4,4,2,5,2,5,5,5,5,5,\n    /*0xA0*/ 2,6,2,6,3,3,3,3,2,2,2,2,4,4,4,4,\n    /*0xB0*/ 2,5,2,5,4,4,4,4,2,4,2,4,4,4,4,4,\n    /*0xC0*/ 2,6,2,8,3,3,5,5,2,2,2,2,4,4,6,6,\n    /*0xD0*/ 2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7,\n    /*0xE0*/ 2,6,3,8,3,3,5,5,2,2,2,2,4,4,6,6,\n    /*0xF0*/ 2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7\n  );\n\n  this.instname = new Array(56);\n\n  // Instruction Names:\n  this.instname[0] = \"ADC\";\n  this.instname[1] = \"AND\";\n  this.instname[2] = \"ASL\";\n  this.instname[3] = \"BCC\";\n  this.instname[4] = \"BCS\";\n  this.instname[5] = \"BEQ\";\n  this.instname[6] = \"BIT\";\n  this.instname[7] = \"BMI\";\n  this.instname[8] = \"BNE\";\n  this.instname[9] = \"BPL\";\n  this.instname[10] = \"BRK\";\n  this.instname[11] = \"BVC\";\n  this.instname[12] = \"BVS\";\n  this.instname[13] = \"CLC\";\n  this.instname[14] = \"CLD\";\n  this.instname[15] = \"CLI\";\n  this.instname[16] = \"CLV\";\n  this.instname[17] = \"CMP\";\n  this.instname[18] = \"CPX\";\n  this.instname[19] = \"CPY\";\n  this.instname[20] = \"DEC\";\n  this.instname[21] = \"DEX\";\n  this.instname[22] = \"DEY\";\n  this.instname[23] = \"EOR\";\n  this.instname[24] = \"INC\";\n  this.instname[25] = \"INX\";\n  this.instname[26] = \"INY\";\n  this.instname[27] = \"JMP\";\n  this.instname[28] = \"JSR\";\n  this.instname[29] = \"LDA\";\n  this.instname[30] = \"LDX\";\n  this.instname[31] = \"LDY\";\n  this.instname[32] = \"LSR\";\n  this.instname[33] = \"NOP\";\n  this.instname[34] = \"ORA\";\n  this.instname[35] = \"PHA\";\n  this.instname[36] = \"PHP\";\n  this.instname[37] = \"PLA\";\n  this.instname[38] = \"PLP\";\n  this.instname[39] = \"ROL\";\n  this.instname[40] = \"ROR\";\n  this.instname[41] = \"RTI\";\n  this.instname[42] = \"RTS\";\n  this.instname[43] = \"SBC\";\n  this.instname[44] = \"SEC\";\n  this.instname[45] = \"SED\";\n  this.instname[46] = \"SEI\";\n  this.instname[47] = \"STA\";\n  this.instname[48] = \"STX\";\n  this.instname[49] = \"STY\";\n  this.instname[50] = \"TAX\";\n  this.instname[51] = \"TAY\";\n  this.instname[52] = \"TSX\";\n  this.instname[53] = \"TXA\";\n  this.instname[54] = \"TXS\";\n  this.instname[55] = \"TYA\";\n\n  this.addrDesc = new Array(\n    \"Zero Page           \",\n    \"Relative            \",\n    \"Implied             \",\n    \"Absolute            \",\n    \"Accumulator         \",\n    \"Immediate           \",\n    \"Zero Page,X         \",\n    \"Zero Page,Y         \",\n    \"Absolute,X          \",\n    \"Absolute,Y          \",\n    \"Preindexed Indirect \",\n    \"Postindexed Indirect\",\n    \"Indirect Absolute   \"\n  );\n};\n\nOpData.prototype = {\n  INS_ADC: 0,\n  INS_AND: 1,\n  INS_ASL: 2,\n\n  INS_BCC: 3,\n  INS_BCS: 4,\n  INS_BEQ: 5,\n  INS_BIT: 6,\n  INS_BMI: 7,\n  INS_BNE: 8,\n  INS_BPL: 9,\n  INS_BRK: 10,\n  INS_BVC: 11,\n  INS_BVS: 12,\n\n  INS_CLC: 13,\n  INS_CLD: 14,\n  INS_CLI: 15,\n  INS_CLV: 16,\n  INS_CMP: 17,\n  INS_CPX: 18,\n  INS_CPY: 19,\n\n  INS_DEC: 20,\n  INS_DEX: 21,\n  INS_DEY: 22,\n\n  INS_EOR: 23,\n\n  INS_INC: 24,\n  INS_INX: 25,\n  INS_INY: 26,\n\n  INS_JMP: 27,\n  INS_JSR: 28,\n\n  INS_LDA: 29,\n  INS_LDX: 30,\n  INS_LDY: 31,\n  INS_LSR: 32,\n\n  INS_NOP: 33,\n\n  INS_ORA: 34,\n\n  INS_PHA: 35,\n  INS_PHP: 36,\n  INS_PLA: 37,\n  INS_PLP: 38,\n\n  INS_ROL: 39,\n  INS_ROR: 40,\n  INS_RTI: 41,\n  INS_RTS: 42,\n\n  INS_SBC: 43,\n  INS_SEC: 44,\n  INS_SED: 45,\n  INS_SEI: 46,\n  INS_STA: 47,\n  INS_STX: 48,\n  INS_STY: 49,\n\n  INS_TAX: 50,\n  INS_TAY: 51,\n  INS_TSX: 52,\n  INS_TXA: 53,\n  INS_TXS: 54,\n  INS_TYA: 55,\n\n  INS_DUMMY: 56, // dummy instruction used for 'halting' the processor some cycles\n\n  // -------------------------------- //\n\n  // Addressing modes:\n  ADDR_ZP: 0,\n  ADDR_REL: 1,\n  ADDR_IMP: 2,\n  ADDR_ABS: 3,\n  ADDR_ACC: 4,\n  ADDR_IMM: 5,\n  ADDR_ZPX: 6,\n  ADDR_ZPY: 7,\n  ADDR_ABSX: 8,\n  ADDR_ABSY: 9,\n  ADDR_PREIDXIND: 10,\n  ADDR_POSTIDXIND: 11,\n  ADDR_INDABS: 12,\n\n  setOp: function(inst, op, addr, size, cycles) {\n    this.opdata[op] =\n      (inst & 0xff) |\n      ((addr & 0xff) << 8) |\n      ((size & 0xff) << 16) |\n      ((cycles & 0xff) << 24);\n  }\n};\n\nmodule.exports = CPU;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/cpu.js\n// module id = 5\n// module chunks = 0 1","var Tile = require('./tile');\nvar utils = require('./utils');\n\nvar PPU = function(nes) {\n  this.nes = nes;\n\n  // Keep Chrome happy\n  this.vramMem = null;\n  this.spriteMem = null;\n  this.vramAddress = null;\n  this.vramTmpAddress = null;\n  this.vramBufferedReadValue = null;\n  this.firstWrite = null;\n  this.sramAddress = null;\n  this.currentMirroring = null;\n  this.requestEndFrame = null;\n  this.nmiOk = null;\n  this.dummyCycleToggle = null;\n  this.validTileData = null;\n  this.nmiCounter = null;\n  this.scanlineAlreadyRendered = null;\n  this.f_nmiOnVblank = null;\n  this.f_spriteSize = null;\n  this.f_bgPatternTable = null;\n  this.f_spPatternTable = null;\n  this.f_addrInc = null;\n  this.f_nTblAddress = null;\n  this.f_color = null;\n  this.f_spVisibility = null;\n  this.f_bgVisibility = null;\n  this.f_spClipping = null;\n  this.f_bgClipping = null;\n  this.f_dispType = null;\n  this.cntFV = null;\n  this.cntV = null;\n  this.cntH = null;\n  this.cntVT = null;\n  this.cntHT = null;\n  this.regFV = null;\n  this.regV = null;\n  this.regH = null;\n  this.regVT = null;\n  this.regHT = null;\n  this.regFH = null;\n  this.regS = null;\n  this.curNt = null;\n  this.attrib = null;\n  this.buffer = null;\n  this.bgbuffer = null;\n  this.pixrendered = null;\n\n  this.validTileData = null;\n  this.scantile = null;\n  this.scanline = null;\n  this.lastRenderedScanline = null;\n  this.curX = null;\n  this.sprX = null;\n  this.sprY = null;\n  this.sprTile = null;\n  this.sprCol = null;\n  this.vertFlip = null;\n  this.horiFlip = null;\n  this.bgPriority = null;\n  this.spr0HitX = null;\n  this.spr0HitY = null;\n  this.hitSpr0 = null;\n  this.sprPalette = null;\n  this.imgPalette = null;\n  this.ptTile = null;\n  this.ntable1 = null;\n  this.currentMirroring = null;\n  this.nameTable = null;\n  this.vramMirrorTable = null;\n  this.palTable = null;\n\n  // Rendering Options:\n  this.showSpr0Hit = false;\n  this.clipToTvSize = true;\n\n  this.reset();\n};\n\nPPU.prototype = {\n  // Status flags:\n  STATUS_VRAMWRITE: 4,\n  STATUS_SLSPRITECOUNT: 5,\n  STATUS_SPRITE0HIT: 6,\n  STATUS_VBLANK: 7,\n\n  reset: function() {\n    var i;\n\n    // Memory\n    this.vramMem = new Array(0x8000);\n    this.spriteMem = new Array(0x100);\n    for (i = 0; i < this.vramMem.length; i++) {\n      this.vramMem[i] = 0;\n    }\n    for (i = 0; i < this.spriteMem.length; i++) {\n      this.spriteMem[i] = 0;\n    }\n\n    // VRAM I/O:\n    this.vramAddress = null;\n    this.vramTmpAddress = null;\n    this.vramBufferedReadValue = 0;\n    this.firstWrite = true; // VRAM/Scroll Hi/Lo latch\n\n    // SPR-RAM I/O:\n    this.sramAddress = 0; // 8-bit only.\n\n    this.currentMirroring = -1;\n    this.requestEndFrame = false;\n    this.nmiOk = false;\n    this.dummyCycleToggle = false;\n    this.validTileData = false;\n    this.nmiCounter = 0;\n    this.scanlineAlreadyRendered = null;\n\n    // Control Flags Register 1:\n    this.f_nmiOnVblank = 0; // NMI on VBlank. 0=disable, 1=enable\n    this.f_spriteSize = 0; // Sprite size. 0=8x8, 1=8x16\n    this.f_bgPatternTable = 0; // Background Pattern Table address. 0=0x0000,1=0x1000\n    this.f_spPatternTable = 0; // Sprite Pattern Table address. 0=0x0000,1=0x1000\n    this.f_addrInc = 0; // PPU Address Increment. 0=1,1=32\n    this.f_nTblAddress = 0; // Name Table Address. 0=0x2000,1=0x2400,2=0x2800,3=0x2C00\n\n    // Control Flags Register 2:\n    this.f_color = 0; // Background color. 0=black, 1=blue, 2=green, 4=red\n    this.f_spVisibility = 0; // Sprite visibility. 0=not displayed,1=displayed\n    this.f_bgVisibility = 0; // Background visibility. 0=Not Displayed,1=displayed\n    this.f_spClipping = 0; // Sprite clipping. 0=Sprites invisible in left 8-pixel column,1=No clipping\n    this.f_bgClipping = 0; // Background clipping. 0=BG invisible in left 8-pixel column, 1=No clipping\n    this.f_dispType = 0; // Display type. 0=color, 1=monochrome\n\n    // Counters:\n    this.cntFV = 0;\n    this.cntV = 0;\n    this.cntH = 0;\n    this.cntVT = 0;\n    this.cntHT = 0;\n\n    // Registers:\n    this.regFV = 0;\n    this.regV = 0;\n    this.regH = 0;\n    this.regVT = 0;\n    this.regHT = 0;\n    this.regFH = 0;\n    this.regS = 0;\n\n    // These are temporary variables used in rendering and sound procedures.\n    // Their states outside of those procedures can be ignored.\n    // TODO: the use of this is a bit weird, investigate\n    this.curNt = null;\n\n    // Variables used when rendering:\n    this.attrib = new Array(32);\n    this.buffer = new Array(256 * 240);\n    this.bgbuffer = new Array(256 * 240);\n    this.pixrendered = new Array(256 * 240);\n\n    this.validTileData = null;\n\n    this.scantile = new Array(32);\n\n    // Initialize misc vars:\n    this.scanline = 0;\n    this.lastRenderedScanline = -1;\n    this.curX = 0;\n\n    // Sprite data:\n    this.sprX = new Array(64); // X coordinate\n    this.sprY = new Array(64); // Y coordinate\n    this.sprTile = new Array(64); // Tile Index (into pattern table)\n    this.sprCol = new Array(64); // Upper two bits of color\n    this.vertFlip = new Array(64); // Vertical Flip\n    this.horiFlip = new Array(64); // Horizontal Flip\n    this.bgPriority = new Array(64); // Background priority\n    this.spr0HitX = 0; // Sprite #0 hit X coordinate\n    this.spr0HitY = 0; // Sprite #0 hit Y coordinate\n    this.hitSpr0 = false;\n\n    // Palette data:\n    this.sprPalette = new Array(16);\n    this.imgPalette = new Array(16);\n\n    // Create pattern table tile buffers:\n    this.ptTile = new Array(512);\n    for (i = 0; i < 512; i++) {\n      this.ptTile[i] = new Tile();\n    }\n\n    // Create nametable buffers:\n    // Name table data:\n    this.ntable1 = new Array(4);\n    this.currentMirroring = -1;\n    this.nameTable = new Array(4);\n    for (i = 0; i < 4; i++) {\n      this.nameTable[i] = new NameTable(32, 32, \"Nt\" + i);\n    }\n\n    // Initialize mirroring lookup table:\n    this.vramMirrorTable = new Array(0x8000);\n    for (i = 0; i < 0x8000; i++) {\n      this.vramMirrorTable[i] = i;\n    }\n\n    this.palTable = new PaletteTable();\n    this.palTable.loadNTSCPalette();\n    //this.palTable.loadDefaultPalette();\n\n    this.updateControlReg1(0);\n    this.updateControlReg2(0);\n  },\n\n  // Sets Nametable mirroring.\n  setMirroring: function(mirroring) {\n    if (mirroring === this.currentMirroring) {\n      return;\n    }\n\n    this.currentMirroring = mirroring;\n    this.triggerRendering();\n\n    // Remove mirroring:\n    if (this.vramMirrorTable === null) {\n      this.vramMirrorTable = new Array(0x8000);\n    }\n    for (var i = 0; i < 0x8000; i++) {\n      this.vramMirrorTable[i] = i;\n    }\n\n    // Palette mirroring:\n    this.defineMirrorRegion(0x3f20, 0x3f00, 0x20);\n    this.defineMirrorRegion(0x3f40, 0x3f00, 0x20);\n    this.defineMirrorRegion(0x3f80, 0x3f00, 0x20);\n    this.defineMirrorRegion(0x3fc0, 0x3f00, 0x20);\n\n    // Additional mirroring:\n    this.defineMirrorRegion(0x3000, 0x2000, 0xf00);\n    this.defineMirrorRegion(0x4000, 0x0000, 0x4000);\n\n    if (mirroring === this.nes.rom.HORIZONTAL_MIRRORING) {\n      // Horizontal mirroring.\n\n      this.ntable1[0] = 0;\n      this.ntable1[1] = 0;\n      this.ntable1[2] = 1;\n      this.ntable1[3] = 1;\n\n      this.defineMirrorRegion(0x2400, 0x2000, 0x400);\n      this.defineMirrorRegion(0x2c00, 0x2800, 0x400);\n    } else if (mirroring === this.nes.rom.VERTICAL_MIRRORING) {\n      // Vertical mirroring.\n\n      this.ntable1[0] = 0;\n      this.ntable1[1] = 1;\n      this.ntable1[2] = 0;\n      this.ntable1[3] = 1;\n\n      this.defineMirrorRegion(0x2800, 0x2000, 0x400);\n      this.defineMirrorRegion(0x2c00, 0x2400, 0x400);\n    } else if (mirroring === this.nes.rom.SINGLESCREEN_MIRRORING) {\n      // Single Screen mirroring\n\n      this.ntable1[0] = 0;\n      this.ntable1[1] = 0;\n      this.ntable1[2] = 0;\n      this.ntable1[3] = 0;\n\n      this.defineMirrorRegion(0x2400, 0x2000, 0x400);\n      this.defineMirrorRegion(0x2800, 0x2000, 0x400);\n      this.defineMirrorRegion(0x2c00, 0x2000, 0x400);\n    } else if (mirroring === this.nes.rom.SINGLESCREEN_MIRRORING2) {\n      this.ntable1[0] = 1;\n      this.ntable1[1] = 1;\n      this.ntable1[2] = 1;\n      this.ntable1[3] = 1;\n\n      this.defineMirrorRegion(0x2400, 0x2400, 0x400);\n      this.defineMirrorRegion(0x2800, 0x2400, 0x400);\n      this.defineMirrorRegion(0x2c00, 0x2400, 0x400);\n    } else {\n      // Assume Four-screen mirroring.\n\n      this.ntable1[0] = 0;\n      this.ntable1[1] = 1;\n      this.ntable1[2] = 2;\n      this.ntable1[3] = 3;\n    }\n  },\n\n  // Define a mirrored area in the address lookup table.\n  // Assumes the regions don't overlap.\n  // The 'to' region is the region that is physically in memory.\n  defineMirrorRegion: function(fromStart, toStart, size) {\n    for (var i = 0; i < size; i++) {\n      this.vramMirrorTable[fromStart + i] = toStart + i;\n    }\n  },\n\n  startVBlank: function() {\n    // Do NMI:\n    this.nes.cpu.requestIrq(this.nes.cpu.IRQ_NMI);\n\n    // Make sure everything is rendered:\n    if (this.lastRenderedScanline < 239) {\n      this.renderFramePartially(\n        this.lastRenderedScanline + 1,\n        240 - this.lastRenderedScanline\n      );\n    }\n\n    // End frame:\n    this.endFrame();\n\n    // Reset scanline counter:\n    this.lastRenderedScanline = -1;\n  },\n\n  endScanline: function() {\n    switch (this.scanline) {\n      case 19:\n        // Dummy scanline.\n        // May be variable length:\n        if (this.dummyCycleToggle) {\n          // Remove dead cycle at end of scanline,\n          // for next scanline:\n          this.curX = 1;\n          this.dummyCycleToggle = !this.dummyCycleToggle;\n        }\n        break;\n\n      case 20:\n        // Clear VBlank flag:\n        this.setStatusFlag(this.STATUS_VBLANK, false);\n\n        // Clear Sprite #0 hit flag:\n        this.setStatusFlag(this.STATUS_SPRITE0HIT, false);\n        this.hitSpr0 = false;\n        this.spr0HitX = -1;\n        this.spr0HitY = -1;\n\n        if (this.f_bgVisibility === 1 || this.f_spVisibility === 1) {\n          // Update counters:\n          this.cntFV = this.regFV;\n          this.cntV = this.regV;\n          this.cntH = this.regH;\n          this.cntVT = this.regVT;\n          this.cntHT = this.regHT;\n\n          if (this.f_bgVisibility === 1) {\n            // Render dummy scanline:\n            this.renderBgScanline(false, 0);\n          }\n        }\n\n        if (this.f_bgVisibility === 1 && this.f_spVisibility === 1) {\n          // Check sprite 0 hit for first scanline:\n          this.checkSprite0(0);\n        }\n\n        if (this.f_bgVisibility === 1 || this.f_spVisibility === 1) {\n          // Clock mapper IRQ Counter:\n          this.nes.mmap.clockIrqCounter();\n        }\n        break;\n\n      case 261:\n        // Dead scanline, no rendering.\n        // Set VINT:\n        this.setStatusFlag(this.STATUS_VBLANK, true);\n        this.requestEndFrame = true;\n        this.nmiCounter = 9;\n\n        // Wrap around:\n        this.scanline = -1; // will be incremented to 0\n\n        break;\n\n      default:\n        if (this.scanline >= 21 && this.scanline <= 260) {\n          // Render normally:\n          if (this.f_bgVisibility === 1) {\n            if (!this.scanlineAlreadyRendered) {\n              // update scroll:\n              this.cntHT = this.regHT;\n              this.cntH = this.regH;\n              this.renderBgScanline(true, this.scanline + 1 - 21);\n            }\n            this.scanlineAlreadyRendered = false;\n\n            // Check for sprite 0 (next scanline):\n            if (!this.hitSpr0 && this.f_spVisibility === 1) {\n              if (\n                this.sprX[0] >= -7 &&\n                this.sprX[0] < 256 &&\n                this.sprY[0] + 1 <= this.scanline - 20 &&\n                this.sprY[0] + 1 + (this.f_spriteSize === 0 ? 8 : 16) >=\n                  this.scanline - 20\n              ) {\n                if (this.checkSprite0(this.scanline - 20)) {\n                  this.hitSpr0 = true;\n                }\n              }\n            }\n          }\n\n          if (this.f_bgVisibility === 1 || this.f_spVisibility === 1) {\n            // Clock mapper IRQ Counter:\n            this.nes.mmap.clockIrqCounter();\n          }\n        }\n    }\n\n    this.scanline++;\n    this.regsToAddress();\n    this.cntsToAddress();\n  },\n\n  startFrame: function() {\n    // Set background color:\n    var bgColor = 0;\n\n    if (this.f_dispType === 0) {\n      // Color display.\n      // f_color determines color emphasis.\n      // Use first entry of image palette as BG color.\n      bgColor = this.imgPalette[0];\n    } else {\n      // Monochrome display.\n      // f_color determines the bg color.\n      switch (this.f_color) {\n        case 0:\n          // Black\n          bgColor = 0x00000;\n          break;\n        case 1:\n          // Green\n          bgColor = 0x00ff00;\n          break;\n        case 2:\n          // Blue\n          bgColor = 0xff0000;\n          break;\n        case 3:\n          // Invalid. Use black.\n          bgColor = 0x000000;\n          break;\n        case 4:\n          // Red\n          bgColor = 0x0000ff;\n          break;\n        default:\n          // Invalid. Use black.\n          bgColor = 0x0;\n      }\n    }\n\n    var buffer = this.buffer;\n    var i;\n    for (i = 0; i < 256 * 240; i++) {\n      buffer[i] = bgColor;\n    }\n    var pixrendered = this.pixrendered;\n    for (i = 0; i < pixrendered.length; i++) {\n      pixrendered[i] = 65;\n    }\n  },\n\n  endFrame: function() {\n    var i, x, y;\n    var buffer = this.buffer;\n\n    // Draw spr#0 hit coordinates:\n    if (this.showSpr0Hit) {\n      // Spr 0 position:\n      if (\n        this.sprX[0] >= 0 &&\n        this.sprX[0] < 256 &&\n        this.sprY[0] >= 0 &&\n        this.sprY[0] < 240\n      ) {\n        for (i = 0; i < 256; i++) {\n          buffer[(this.sprY[0] << 8) + i] = 0xff5555;\n        }\n        for (i = 0; i < 240; i++) {\n          buffer[(i << 8) + this.sprX[0]] = 0xff5555;\n        }\n      }\n      // Hit position:\n      if (\n        this.spr0HitX >= 0 &&\n        this.spr0HitX < 256 &&\n        this.spr0HitY >= 0 &&\n        this.spr0HitY < 240\n      ) {\n        for (i = 0; i < 256; i++) {\n          buffer[(this.spr0HitY << 8) + i] = 0x55ff55;\n        }\n        for (i = 0; i < 240; i++) {\n          buffer[(i << 8) + this.spr0HitX] = 0x55ff55;\n        }\n      }\n    }\n\n    // This is a bit lazy..\n    // if either the sprites or the background should be clipped,\n    // both are clipped after rendering is finished.\n    if (\n      this.clipToTvSize ||\n      this.f_bgClipping === 0 ||\n      this.f_spClipping === 0\n    ) {\n      // Clip left 8-pixels column:\n      for (y = 0; y < 240; y++) {\n        for (x = 0; x < 8; x++) {\n          buffer[(y << 8) + x] = 0;\n        }\n      }\n    }\n\n    if (this.clipToTvSize) {\n      // Clip right 8-pixels column too:\n      for (y = 0; y < 240; y++) {\n        for (x = 0; x < 8; x++) {\n          buffer[(y << 8) + 255 - x] = 0;\n        }\n      }\n    }\n\n    // Clip top and bottom 8 pixels:\n    if (this.clipToTvSize) {\n      for (y = 0; y < 8; y++) {\n        for (x = 0; x < 256; x++) {\n          buffer[(y << 8) + x] = 0;\n          buffer[((239 - y) << 8) + x] = 0;\n        }\n      }\n    }\n\n    this.nes.ui.writeFrame(buffer);\n  },\n\n  updateControlReg1: function(value) {\n    this.triggerRendering();\n\n    this.f_nmiOnVblank = (value >> 7) & 1;\n    this.f_spriteSize = (value >> 5) & 1;\n    this.f_bgPatternTable = (value >> 4) & 1;\n    this.f_spPatternTable = (value >> 3) & 1;\n    this.f_addrInc = (value >> 2) & 1;\n    this.f_nTblAddress = value & 3;\n\n    this.regV = (value >> 1) & 1;\n    this.regH = value & 1;\n    this.regS = (value >> 4) & 1;\n  },\n\n  updateControlReg2: function(value) {\n    this.triggerRendering();\n\n    this.f_color = (value >> 5) & 7;\n    this.f_spVisibility = (value >> 4) & 1;\n    this.f_bgVisibility = (value >> 3) & 1;\n    this.f_spClipping = (value >> 2) & 1;\n    this.f_bgClipping = (value >> 1) & 1;\n    this.f_dispType = value & 1;\n\n    if (this.f_dispType === 0) {\n      this.palTable.setEmphasis(this.f_color);\n    }\n    this.updatePalettes();\n  },\n\n  setStatusFlag: function(flag, value) {\n    var n = 1 << flag;\n    this.nes.cpu.mem[0x2002] =\n      (this.nes.cpu.mem[0x2002] & (255 - n)) | (value ? n : 0);\n  },\n\n  // CPU Register $2002:\n  // Read the Status Register.\n  readStatusRegister: function() {\n    var tmp = this.nes.cpu.mem[0x2002];\n\n    // Reset scroll & VRAM Address toggle:\n    this.firstWrite = true;\n\n    // Clear VBlank flag:\n    this.setStatusFlag(this.STATUS_VBLANK, false);\n\n    // Fetch status data:\n    return tmp;\n  },\n\n  // CPU Register $2003:\n  // Write the SPR-RAM address that is used for sramWrite (Register 0x2004 in CPU memory map)\n  writeSRAMAddress: function(address) {\n    this.sramAddress = address;\n  },\n\n  // CPU Register $2004 (R):\n  // Read from SPR-RAM (Sprite RAM).\n  // The address should be set first.\n  sramLoad: function() {\n    /*short tmp = sprMem.load(sramAddress);\n        sramAddress++; // Increment address\n        sramAddress%=0x100;\n        return tmp;*/\n    return this.spriteMem[this.sramAddress];\n  },\n\n  // CPU Register $2004 (W):\n  // Write to SPR-RAM (Sprite RAM).\n  // The address should be set first.\n  sramWrite: function(value) {\n    this.spriteMem[this.sramAddress] = value;\n    this.spriteRamWriteUpdate(this.sramAddress, value);\n    this.sramAddress++; // Increment address\n    this.sramAddress %= 0x100;\n  },\n\n  // CPU Register $2005:\n  // Write to scroll registers.\n  // The first write is the vertical offset, the second is the\n  // horizontal offset:\n  scrollWrite: function(value) {\n    this.triggerRendering();\n\n    if (this.firstWrite) {\n      // First write, horizontal scroll:\n      this.regHT = (value >> 3) & 31;\n      this.regFH = value & 7;\n    } else {\n      // Second write, vertical scroll:\n      this.regFV = value & 7;\n      this.regVT = (value >> 3) & 31;\n    }\n    this.firstWrite = !this.firstWrite;\n  },\n\n  // CPU Register $2006:\n  // Sets the adress used when reading/writing from/to VRAM.\n  // The first write sets the high byte, the second the low byte.\n  writeVRAMAddress: function(address) {\n    if (this.firstWrite) {\n      this.regFV = (address >> 4) & 3;\n      this.regV = (address >> 3) & 1;\n      this.regH = (address >> 2) & 1;\n      this.regVT = (this.regVT & 7) | ((address & 3) << 3);\n    } else {\n      this.triggerRendering();\n\n      this.regVT = (this.regVT & 24) | ((address >> 5) & 7);\n      this.regHT = address & 31;\n\n      this.cntFV = this.regFV;\n      this.cntV = this.regV;\n      this.cntH = this.regH;\n      this.cntVT = this.regVT;\n      this.cntHT = this.regHT;\n\n      this.checkSprite0(this.scanline - 20);\n    }\n\n    this.firstWrite = !this.firstWrite;\n\n    // Invoke mapper latch:\n    this.cntsToAddress();\n    if (this.vramAddress < 0x2000) {\n      this.nes.mmap.latchAccess(this.vramAddress);\n    }\n  },\n\n  // CPU Register $2007(R):\n  // Read from PPU memory. The address should be set first.\n  vramLoad: function() {\n    var tmp;\n\n    this.cntsToAddress();\n    this.regsToAddress();\n\n    // If address is in range 0x0000-0x3EFF, return buffered values:\n    if (this.vramAddress <= 0x3eff) {\n      tmp = this.vramBufferedReadValue;\n\n      // Update buffered value:\n      if (this.vramAddress < 0x2000) {\n        this.vramBufferedReadValue = this.vramMem[this.vramAddress];\n      } else {\n        this.vramBufferedReadValue = this.mirroredLoad(this.vramAddress);\n      }\n\n      // Mapper latch access:\n      if (this.vramAddress < 0x2000) {\n        this.nes.mmap.latchAccess(this.vramAddress);\n      }\n\n      // Increment by either 1 or 32, depending on d2 of Control Register 1:\n      this.vramAddress += this.f_addrInc === 1 ? 32 : 1;\n\n      this.cntsFromAddress();\n      this.regsFromAddress();\n\n      return tmp; // Return the previous buffered value.\n    }\n\n    // No buffering in this mem range. Read normally.\n    tmp = this.mirroredLoad(this.vramAddress);\n\n    // Increment by either 1 or 32, depending on d2 of Control Register 1:\n    this.vramAddress += this.f_addrInc === 1 ? 32 : 1;\n\n    this.cntsFromAddress();\n    this.regsFromAddress();\n\n    return tmp;\n  },\n\n  // CPU Register $2007(W):\n  // Write to PPU memory. The address should be set first.\n  vramWrite: function(value) {\n    this.triggerRendering();\n    this.cntsToAddress();\n    this.regsToAddress();\n\n    if (this.vramAddress >= 0x2000) {\n      // Mirroring is used.\n      this.mirroredWrite(this.vramAddress, value);\n    } else {\n      // Write normally.\n      this.writeMem(this.vramAddress, value);\n\n      // Invoke mapper latch:\n      this.nes.mmap.latchAccess(this.vramAddress);\n    }\n\n    // Increment by either 1 or 32, depending on d2 of Control Register 1:\n    this.vramAddress += this.f_addrInc === 1 ? 32 : 1;\n    this.regsFromAddress();\n    this.cntsFromAddress();\n  },\n\n  // CPU Register $4014:\n  // Write 256 bytes of main memory\n  // into Sprite RAM.\n  sramDMA: function(value) {\n    var baseAddress = value * 0x100;\n    var data;\n    for (var i = this.sramAddress; i < 256; i++) {\n      data = this.nes.cpu.mem[baseAddress + i];\n      this.spriteMem[i] = data;\n      this.spriteRamWriteUpdate(i, data);\n    }\n\n    this.nes.cpu.haltCycles(513);\n  },\n\n  // Updates the scroll registers from a new VRAM address.\n  regsFromAddress: function() {\n    var address = (this.vramTmpAddress >> 8) & 0xff;\n    this.regFV = (address >> 4) & 7;\n    this.regV = (address >> 3) & 1;\n    this.regH = (address >> 2) & 1;\n    this.regVT = (this.regVT & 7) | ((address & 3) << 3);\n\n    address = this.vramTmpAddress & 0xff;\n    this.regVT = (this.regVT & 24) | ((address >> 5) & 7);\n    this.regHT = address & 31;\n  },\n\n  // Updates the scroll registers from a new VRAM address.\n  cntsFromAddress: function() {\n    var address = (this.vramAddress >> 8) & 0xff;\n    this.cntFV = (address >> 4) & 3;\n    this.cntV = (address >> 3) & 1;\n    this.cntH = (address >> 2) & 1;\n    this.cntVT = (this.cntVT & 7) | ((address & 3) << 3);\n\n    address = this.vramAddress & 0xff;\n    this.cntVT = (this.cntVT & 24) | ((address >> 5) & 7);\n    this.cntHT = address & 31;\n  },\n\n  regsToAddress: function() {\n    var b1 = (this.regFV & 7) << 4;\n    b1 |= (this.regV & 1) << 3;\n    b1 |= (this.regH & 1) << 2;\n    b1 |= (this.regVT >> 3) & 3;\n\n    var b2 = (this.regVT & 7) << 5;\n    b2 |= this.regHT & 31;\n\n    this.vramTmpAddress = ((b1 << 8) | b2) & 0x7fff;\n  },\n\n  cntsToAddress: function() {\n    var b1 = (this.cntFV & 7) << 4;\n    b1 |= (this.cntV & 1) << 3;\n    b1 |= (this.cntH & 1) << 2;\n    b1 |= (this.cntVT >> 3) & 3;\n\n    var b2 = (this.cntVT & 7) << 5;\n    b2 |= this.cntHT & 31;\n\n    this.vramAddress = ((b1 << 8) | b2) & 0x7fff;\n  },\n\n  incTileCounter: function(count) {\n    for (var i = count; i !== 0; i--) {\n      this.cntHT++;\n      if (this.cntHT === 32) {\n        this.cntHT = 0;\n        this.cntVT++;\n        if (this.cntVT >= 30) {\n          this.cntH++;\n          if (this.cntH === 2) {\n            this.cntH = 0;\n            this.cntV++;\n            if (this.cntV === 2) {\n              this.cntV = 0;\n              this.cntFV++;\n              this.cntFV &= 0x7;\n            }\n          }\n        }\n      }\n    }\n  },\n\n  // Reads from memory, taking into account\n  // mirroring/mapping of address ranges.\n  mirroredLoad: function(address) {\n    return this.vramMem[this.vramMirrorTable[address]];\n  },\n\n  // Writes to memory, taking into account\n  // mirroring/mapping of address ranges.\n  mirroredWrite: function(address, value) {\n    if (address >= 0x3f00 && address < 0x3f20) {\n      // Palette write mirroring.\n      if (address === 0x3f00 || address === 0x3f10) {\n        this.writeMem(0x3f00, value);\n        this.writeMem(0x3f10, value);\n      } else if (address === 0x3f04 || address === 0x3f14) {\n        this.writeMem(0x3f04, value);\n        this.writeMem(0x3f14, value);\n      } else if (address === 0x3f08 || address === 0x3f18) {\n        this.writeMem(0x3f08, value);\n        this.writeMem(0x3f18, value);\n      } else if (address === 0x3f0c || address === 0x3f1c) {\n        this.writeMem(0x3f0c, value);\n        this.writeMem(0x3f1c, value);\n      } else {\n        this.writeMem(address, value);\n      }\n    } else {\n      // Use lookup table for mirrored address:\n      if (address < this.vramMirrorTable.length) {\n        this.writeMem(this.vramMirrorTable[address], value);\n      } else {\n        throw new Error(\"Invalid VRAM address: \" + address.toString(16));\n      }\n    }\n  },\n\n  triggerRendering: function() {\n    if (this.scanline >= 21 && this.scanline <= 260) {\n      // Render sprites, and combine:\n      this.renderFramePartially(\n        this.lastRenderedScanline + 1,\n        this.scanline - 21 - this.lastRenderedScanline\n      );\n\n      // Set last rendered scanline:\n      this.lastRenderedScanline = this.scanline - 21;\n    }\n  },\n\n  renderFramePartially: function(startScan, scanCount) {\n    if (this.f_spVisibility === 1) {\n      this.renderSpritesPartially(startScan, scanCount, true);\n    }\n\n    if (this.f_bgVisibility === 1) {\n      var si = startScan << 8;\n      var ei = (startScan + scanCount) << 8;\n      if (ei > 0xf000) {\n        ei = 0xf000;\n      }\n      var buffer = this.buffer;\n      var bgbuffer = this.bgbuffer;\n      var pixrendered = this.pixrendered;\n      for (var destIndex = si; destIndex < ei; destIndex++) {\n        if (pixrendered[destIndex] > 0xff) {\n          buffer[destIndex] = bgbuffer[destIndex];\n        }\n      }\n    }\n\n    if (this.f_spVisibility === 1) {\n      this.renderSpritesPartially(startScan, scanCount, false);\n    }\n\n    this.validTileData = false;\n  },\n\n  renderBgScanline: function(bgbuffer, scan) {\n    var baseTile = this.regS === 0 ? 0 : 256;\n    var destIndex = (scan << 8) - this.regFH;\n\n    this.curNt = this.ntable1[this.cntV + this.cntV + this.cntH];\n\n    this.cntHT = this.regHT;\n    this.cntH = this.regH;\n    this.curNt = this.ntable1[this.cntV + this.cntV + this.cntH];\n\n    if (scan < 240 && scan - this.cntFV >= 0) {\n      var tscanoffset = this.cntFV << 3;\n      var scantile = this.scantile;\n      var attrib = this.attrib;\n      var ptTile = this.ptTile;\n      var nameTable = this.nameTable;\n      var imgPalette = this.imgPalette;\n      var pixrendered = this.pixrendered;\n      var targetBuffer = bgbuffer ? this.bgbuffer : this.buffer;\n\n      var t, tpix, att, col;\n\n      for (var tile = 0; tile < 32; tile++) {\n        if (scan >= 0) {\n          // Fetch tile & attrib data:\n          if (this.validTileData) {\n            // Get data from array:\n            t = scantile[tile];\n            if (typeof t === \"undefined\") {\n              continue;\n            }\n            tpix = t.pix;\n            att = attrib[tile];\n          } else {\n            // Fetch data:\n            t =\n              ptTile[\n                baseTile +\n                  nameTable[this.curNt].getTileIndex(this.cntHT, this.cntVT)\n              ];\n            if (typeof t === \"undefined\") {\n              continue;\n            }\n            tpix = t.pix;\n            att = nameTable[this.curNt].getAttrib(this.cntHT, this.cntVT);\n            scantile[tile] = t;\n            attrib[tile] = att;\n          }\n\n          // Render tile scanline:\n          var sx = 0;\n          var x = (tile << 3) - this.regFH;\n\n          if (x > -8) {\n            if (x < 0) {\n              destIndex -= x;\n              sx = -x;\n            }\n            if (t.opaque[this.cntFV]) {\n              for (; sx < 8; sx++) {\n                targetBuffer[destIndex] =\n                  imgPalette[tpix[tscanoffset + sx] + att];\n                pixrendered[destIndex] |= 256;\n                destIndex++;\n              }\n            } else {\n              for (; sx < 8; sx++) {\n                col = tpix[tscanoffset + sx];\n                if (col !== 0) {\n                  targetBuffer[destIndex] = imgPalette[col + att];\n                  pixrendered[destIndex] |= 256;\n                }\n                destIndex++;\n              }\n            }\n          }\n        }\n\n        // Increase Horizontal Tile Counter:\n        if (++this.cntHT === 32) {\n          this.cntHT = 0;\n          this.cntH++;\n          this.cntH %= 2;\n          this.curNt = this.ntable1[(this.cntV << 1) + this.cntH];\n        }\n      }\n\n      // Tile data for one row should now have been fetched,\n      // so the data in the array is valid.\n      this.validTileData = true;\n    }\n\n    // update vertical scroll:\n    this.cntFV++;\n    if (this.cntFV === 8) {\n      this.cntFV = 0;\n      this.cntVT++;\n      if (this.cntVT === 30) {\n        this.cntVT = 0;\n        this.cntV++;\n        this.cntV %= 2;\n        this.curNt = this.ntable1[(this.cntV << 1) + this.cntH];\n      } else if (this.cntVT === 32) {\n        this.cntVT = 0;\n      }\n\n      // Invalidate fetched data:\n      this.validTileData = false;\n    }\n  },\n\n  renderSpritesPartially: function(startscan, scancount, bgPri) {\n    if (this.f_spVisibility === 1) {\n      for (var i = 0; i < 64; i++) {\n        if (\n          this.bgPriority[i] === bgPri &&\n          this.sprX[i] >= 0 &&\n          this.sprX[i] < 256 &&\n          this.sprY[i] + 8 >= startscan &&\n          this.sprY[i] < startscan + scancount\n        ) {\n          // Show sprite.\n          if (this.f_spriteSize === 0) {\n            // 8x8 sprites\n\n            this.srcy1 = 0;\n            this.srcy2 = 8;\n\n            if (this.sprY[i] < startscan) {\n              this.srcy1 = startscan - this.sprY[i] - 1;\n            }\n\n            if (this.sprY[i] + 8 > startscan + scancount) {\n              this.srcy2 = startscan + scancount - this.sprY[i] + 1;\n            }\n\n            if (this.f_spPatternTable === 0) {\n              this.ptTile[this.sprTile[i]].render(\n                this.buffer,\n                0,\n                this.srcy1,\n                8,\n                this.srcy2,\n                this.sprX[i],\n                this.sprY[i] + 1,\n                this.sprCol[i],\n                this.sprPalette,\n                this.horiFlip[i],\n                this.vertFlip[i],\n                i,\n                this.pixrendered\n              );\n            } else {\n              this.ptTile[this.sprTile[i] + 256].render(\n                this.buffer,\n                0,\n                this.srcy1,\n                8,\n                this.srcy2,\n                this.sprX[i],\n                this.sprY[i] + 1,\n                this.sprCol[i],\n                this.sprPalette,\n                this.horiFlip[i],\n                this.vertFlip[i],\n                i,\n                this.pixrendered\n              );\n            }\n          } else {\n            // 8x16 sprites\n            var top = this.sprTile[i];\n            if ((top & 1) !== 0) {\n              top = this.sprTile[i] - 1 + 256;\n            }\n\n            var srcy1 = 0;\n            var srcy2 = 8;\n\n            if (this.sprY[i] < startscan) {\n              srcy1 = startscan - this.sprY[i] - 1;\n            }\n\n            if (this.sprY[i] + 8 > startscan + scancount) {\n              srcy2 = startscan + scancount - this.sprY[i];\n            }\n\n            this.ptTile[top + (this.vertFlip[i] ? 1 : 0)].render(\n              this.buffer,\n              0,\n              srcy1,\n              8,\n              srcy2,\n              this.sprX[i],\n              this.sprY[i] + 1,\n              this.sprCol[i],\n              this.sprPalette,\n              this.horiFlip[i],\n              this.vertFlip[i],\n              i,\n              this.pixrendered\n            );\n\n            srcy1 = 0;\n            srcy2 = 8;\n\n            if (this.sprY[i] + 8 < startscan) {\n              srcy1 = startscan - (this.sprY[i] + 8 + 1);\n            }\n\n            if (this.sprY[i] + 16 > startscan + scancount) {\n              srcy2 = startscan + scancount - (this.sprY[i] + 8);\n            }\n\n            this.ptTile[top + (this.vertFlip[i] ? 0 : 1)].render(\n              this.buffer,\n              0,\n              srcy1,\n              8,\n              srcy2,\n              this.sprX[i],\n              this.sprY[i] + 1 + 8,\n              this.sprCol[i],\n              this.sprPalette,\n              this.horiFlip[i],\n              this.vertFlip[i],\n              i,\n              this.pixrendered\n            );\n          }\n        }\n      }\n    }\n  },\n\n  checkSprite0: function(scan) {\n    this.spr0HitX = -1;\n    this.spr0HitY = -1;\n\n    var toffset;\n    var tIndexAdd = this.f_spPatternTable === 0 ? 0 : 256;\n    var x, y, t, i;\n    var bufferIndex;\n    var col;\n    var bgPri;\n\n    x = this.sprX[0];\n    y = this.sprY[0] + 1;\n\n    if (this.f_spriteSize === 0) {\n      // 8x8 sprites.\n\n      // Check range:\n      if (y <= scan && y + 8 > scan && x >= -7 && x < 256) {\n        // Sprite is in range.\n        // Draw scanline:\n        t = this.ptTile[this.sprTile[0] + tIndexAdd];\n        col = this.sprCol[0];\n        bgPri = this.bgPriority[0];\n\n        if (this.vertFlip[0]) {\n          toffset = 7 - (scan - y);\n        } else {\n          toffset = scan - y;\n        }\n        toffset *= 8;\n\n        bufferIndex = scan * 256 + x;\n        if (this.horiFlip[0]) {\n          for (i = 7; i >= 0; i--) {\n            if (x >= 0 && x < 256) {\n              if (\n                bufferIndex >= 0 &&\n                bufferIndex < 61440 &&\n                this.pixrendered[bufferIndex] !== 0\n              ) {\n                if (t.pix[toffset + i] !== 0) {\n                  this.spr0HitX = bufferIndex % 256;\n                  this.spr0HitY = scan;\n                  return true;\n                }\n              }\n            }\n            x++;\n            bufferIndex++;\n          }\n        } else {\n          for (i = 0; i < 8; i++) {\n            if (x >= 0 && x < 256) {\n              if (\n                bufferIndex >= 0 &&\n                bufferIndex < 61440 &&\n                this.pixrendered[bufferIndex] !== 0\n              ) {\n                if (t.pix[toffset + i] !== 0) {\n                  this.spr0HitX = bufferIndex % 256;\n                  this.spr0HitY = scan;\n                  return true;\n                }\n              }\n            }\n            x++;\n            bufferIndex++;\n          }\n        }\n      }\n    } else {\n      // 8x16 sprites:\n\n      // Check range:\n      if (y <= scan && y + 16 > scan && x >= -7 && x < 256) {\n        // Sprite is in range.\n        // Draw scanline:\n\n        if (this.vertFlip[0]) {\n          toffset = 15 - (scan - y);\n        } else {\n          toffset = scan - y;\n        }\n\n        if (toffset < 8) {\n          // first half of sprite.\n          t = this.ptTile[\n            this.sprTile[0] +\n              (this.vertFlip[0] ? 1 : 0) +\n              ((this.sprTile[0] & 1) !== 0 ? 255 : 0)\n          ];\n        } else {\n          // second half of sprite.\n          t = this.ptTile[\n            this.sprTile[0] +\n              (this.vertFlip[0] ? 0 : 1) +\n              ((this.sprTile[0] & 1) !== 0 ? 255 : 0)\n          ];\n          if (this.vertFlip[0]) {\n            toffset = 15 - toffset;\n          } else {\n            toffset -= 8;\n          }\n        }\n        toffset *= 8;\n        col = this.sprCol[0];\n        bgPri = this.bgPriority[0];\n\n        bufferIndex = scan * 256 + x;\n        if (this.horiFlip[0]) {\n          for (i = 7; i >= 0; i--) {\n            if (x >= 0 && x < 256) {\n              if (\n                bufferIndex >= 0 &&\n                bufferIndex < 61440 &&\n                this.pixrendered[bufferIndex] !== 0\n              ) {\n                if (t.pix[toffset + i] !== 0) {\n                  this.spr0HitX = bufferIndex % 256;\n                  this.spr0HitY = scan;\n                  return true;\n                }\n              }\n            }\n            x++;\n            bufferIndex++;\n          }\n        } else {\n          for (i = 0; i < 8; i++) {\n            if (x >= 0 && x < 256) {\n              if (\n                bufferIndex >= 0 &&\n                bufferIndex < 61440 &&\n                this.pixrendered[bufferIndex] !== 0\n              ) {\n                if (t.pix[toffset + i] !== 0) {\n                  this.spr0HitX = bufferIndex % 256;\n                  this.spr0HitY = scan;\n                  return true;\n                }\n              }\n            }\n            x++;\n            bufferIndex++;\n          }\n        }\n      }\n    }\n\n    return false;\n  },\n\n  // This will write to PPU memory, and\n  // update internally buffered data\n  // appropriately.\n  writeMem: function(address, value) {\n    this.vramMem[address] = value;\n\n    // Update internally buffered data:\n    if (address < 0x2000) {\n      this.vramMem[address] = value;\n      this.patternWrite(address, value);\n    } else if (address >= 0x2000 && address < 0x23c0) {\n      this.nameTableWrite(this.ntable1[0], address - 0x2000, value);\n    } else if (address >= 0x23c0 && address < 0x2400) {\n      this.attribTableWrite(this.ntable1[0], address - 0x23c0, value);\n    } else if (address >= 0x2400 && address < 0x27c0) {\n      this.nameTableWrite(this.ntable1[1], address - 0x2400, value);\n    } else if (address >= 0x27c0 && address < 0x2800) {\n      this.attribTableWrite(this.ntable1[1], address - 0x27c0, value);\n    } else if (address >= 0x2800 && address < 0x2bc0) {\n      this.nameTableWrite(this.ntable1[2], address - 0x2800, value);\n    } else if (address >= 0x2bc0 && address < 0x2c00) {\n      this.attribTableWrite(this.ntable1[2], address - 0x2bc0, value);\n    } else if (address >= 0x2c00 && address < 0x2fc0) {\n      this.nameTableWrite(this.ntable1[3], address - 0x2c00, value);\n    } else if (address >= 0x2fc0 && address < 0x3000) {\n      this.attribTableWrite(this.ntable1[3], address - 0x2fc0, value);\n    } else if (address >= 0x3f00 && address < 0x3f20) {\n      this.updatePalettes();\n    }\n  },\n\n  // Reads data from $3f00 to $f20\n  // into the two buffered palettes.\n  updatePalettes: function() {\n    var i;\n\n    for (i = 0; i < 16; i++) {\n      if (this.f_dispType === 0) {\n        this.imgPalette[i] = this.palTable.getEntry(\n          this.vramMem[0x3f00 + i] & 63\n        );\n      } else {\n        this.imgPalette[i] = this.palTable.getEntry(\n          this.vramMem[0x3f00 + i] & 32\n        );\n      }\n    }\n    for (i = 0; i < 16; i++) {\n      if (this.f_dispType === 0) {\n        this.sprPalette[i] = this.palTable.getEntry(\n          this.vramMem[0x3f10 + i] & 63\n        );\n      } else {\n        this.sprPalette[i] = this.palTable.getEntry(\n          this.vramMem[0x3f10 + i] & 32\n        );\n      }\n    }\n  },\n\n  // Updates the internal pattern\n  // table buffers with this new byte.\n  // In vNES, there is a version of this with 4 arguments which isn't used.\n  patternWrite: function(address, value) {\n    var tileIndex = Math.floor(address / 16);\n    var leftOver = address % 16;\n    if (leftOver < 8) {\n      this.ptTile[tileIndex].setScanline(\n        leftOver,\n        value,\n        this.vramMem[address + 8]\n      );\n    } else {\n      this.ptTile[tileIndex].setScanline(\n        leftOver - 8,\n        this.vramMem[address - 8],\n        value\n      );\n    }\n  },\n\n  // Updates the internal name table buffers\n  // with this new byte.\n  nameTableWrite: function(index, address, value) {\n    this.nameTable[index].tile[address] = value;\n\n    // Update Sprite #0 hit:\n    //updateSpr0Hit();\n    this.checkSprite0(this.scanline - 20);\n  },\n\n  // Updates the internal pattern\n  // table buffers with this new attribute\n  // table byte.\n  attribTableWrite: function(index, address, value) {\n    this.nameTable[index].writeAttrib(address, value);\n  },\n\n  // Updates the internally buffered sprite\n  // data with this new byte of info.\n  spriteRamWriteUpdate: function(address, value) {\n    var tIndex = Math.floor(address / 4);\n\n    if (tIndex === 0) {\n      //updateSpr0Hit();\n      this.checkSprite0(this.scanline - 20);\n    }\n\n    if (address % 4 === 0) {\n      // Y coordinate\n      this.sprY[tIndex] = value;\n    } else if (address % 4 === 1) {\n      // Tile index\n      this.sprTile[tIndex] = value;\n    } else if (address % 4 === 2) {\n      // Attributes\n      this.vertFlip[tIndex] = (value & 0x80) !== 0;\n      this.horiFlip[tIndex] = (value & 0x40) !== 0;\n      this.bgPriority[tIndex] = (value & 0x20) !== 0;\n      this.sprCol[tIndex] = (value & 3) << 2;\n    } else if (address % 4 === 3) {\n      // X coordinate\n      this.sprX[tIndex] = value;\n    }\n  },\n\n  doNMI: function() {\n    // Set VBlank flag:\n    this.setStatusFlag(this.STATUS_VBLANK, true);\n    //nes.getCpu().doNonMaskableInterrupt();\n    this.nes.cpu.requestIrq(this.nes.cpu.IRQ_NMI);\n  },\n\n  isPixelWhite: function(x, y) {\n    this.triggerRendering();\n    return this.nes.ppu.buffer[(y << 8) + x] === 0xffffff;\n  },\n\n  JSON_PROPERTIES: [\n    // Memory\n    \"vramMem\",\n    \"spriteMem\",\n    // Counters\n    \"cntFV\",\n    \"cntV\",\n    \"cntH\",\n    \"cntVT\",\n    \"cntHT\",\n    // Registers\n    \"regFV\",\n    \"regV\",\n    \"regH\",\n    \"regVT\",\n    \"regHT\",\n    \"regFH\",\n    \"regS\",\n    // VRAM addr\n    \"vramAddress\",\n    \"vramTmpAddress\",\n    // Control/Status registers\n    \"f_nmiOnVblank\",\n    \"f_spriteSize\",\n    \"f_bgPatternTable\",\n    \"f_spPatternTable\",\n    \"f_addrInc\",\n    \"f_nTblAddress\",\n    \"f_color\",\n    \"f_spVisibility\",\n    \"f_bgVisibility\",\n    \"f_spClipping\",\n    \"f_bgClipping\",\n    \"f_dispType\",\n    // VRAM I/O\n    \"vramBufferedReadValue\",\n    \"firstWrite\",\n    // Mirroring\n    \"currentMirroring\",\n    \"vramMirrorTable\",\n    \"ntable1\",\n    // SPR-RAM I/O\n    \"sramAddress\",\n    // Sprites. Most sprite data is rebuilt from spriteMem\n    \"hitSpr0\",\n    // Palettes\n    \"sprPalette\",\n    \"imgPalette\",\n    // Rendering progression\n    \"curX\",\n    \"scanline\",\n    \"lastRenderedScanline\",\n    \"curNt\",\n    \"scantile\",\n    // Used during rendering\n    \"attrib\",\n    \"buffer\",\n    \"bgbuffer\",\n    \"pixrendered\",\n    // Misc\n    \"requestEndFrame\",\n    \"nmiOk\",\n    \"dummyCycleToggle\",\n    \"nmiCounter\",\n    \"validTileData\",\n    \"scanlineAlreadyRendered\"\n  ],\n\n  toJSON: function() {\n    var i;\n    var state = utils.toJSON(this);\n\n    state.nameTable = [];\n    for (i = 0; i < this.nameTable.length; i++) {\n      state.nameTable[i] = this.nameTable[i].toJSON();\n    }\n\n    state.ptTile = [];\n    for (i = 0; i < this.ptTile.length; i++) {\n      state.ptTile[i] = this.ptTile[i].toJSON();\n    }\n\n    return state;\n  },\n\n  fromJSON: function(state) {\n    var i;\n\n    utils.fromJSON(this, state);\n\n    for (i = 0; i < this.nameTable.length; i++) {\n      this.nameTable[i].fromJSON(state.nameTable[i]);\n    }\n\n    for (i = 0; i < this.ptTile.length; i++) {\n      this.ptTile[i].fromJSON(state.ptTile[i]);\n    }\n\n    // Sprite data:\n    for (i = 0; i < this.spriteMem.length; i++) {\n      this.spriteRamWriteUpdate(i, this.spriteMem[i]);\n    }\n  }\n};\n\nvar NameTable = function(width, height, name) {\n  this.width = width;\n  this.height = height;\n  this.name = name;\n\n  this.tile = new Array(width * height);\n  this.attrib = new Array(width * height);\n  for (var i = 0; i < width * height; i++) {\n    this.tile[i] = 0;\n    this.attrib[i] = 0;\n  }\n};\n\nNameTable.prototype = {\n  getTileIndex: function(x, y) {\n    return this.tile[y * this.width + x];\n  },\n\n  getAttrib: function(x, y) {\n    return this.attrib[y * this.width + x];\n  },\n\n  writeAttrib: function(index, value) {\n    var basex = (index % 8) * 4;\n    var basey = Math.floor(index / 8) * 4;\n    var add;\n    var tx, ty;\n    var attindex;\n\n    for (var sqy = 0; sqy < 2; sqy++) {\n      for (var sqx = 0; sqx < 2; sqx++) {\n        add = (value >> (2 * (sqy * 2 + sqx))) & 3;\n        for (var y = 0; y < 2; y++) {\n          for (var x = 0; x < 2; x++) {\n            tx = basex + sqx * 2 + x;\n            ty = basey + sqy * 2 + y;\n            attindex = ty * this.width + tx;\n            this.attrib[ty * this.width + tx] = (add << 2) & 12;\n          }\n        }\n      }\n    }\n  },\n\n  toJSON: function() {\n    return {\n      tile: this.tile,\n      attrib: this.attrib\n    };\n  },\n\n  fromJSON: function(s) {\n    this.tile = s.tile;\n    this.attrib = s.attrib;\n  }\n};\n\nvar PaletteTable = function() {\n  this.curTable = new Array(64);\n  this.emphTable = new Array(8);\n  this.currentEmph = -1;\n};\n\nPaletteTable.prototype = {\n  reset: function() {\n    this.setEmphasis(0);\n  },\n\n  loadNTSCPalette: function() {\n    // prettier-ignore\n    this.curTable = [0x525252, 0xB40000, 0xA00000, 0xB1003D, 0x740069, 0x00005B, 0x00005F, 0x001840, 0x002F10, 0x084A08, 0x006700, 0x124200, 0x6D2800, 0x000000, 0x000000, 0x000000, 0xC4D5E7, 0xFF4000, 0xDC0E22, 0xFF476B, 0xD7009F, 0x680AD7, 0x0019BC, 0x0054B1, 0x006A5B, 0x008C03, 0x00AB00, 0x2C8800, 0xA47200, 0x000000, 0x000000, 0x000000, 0xF8F8F8, 0xFFAB3C, 0xFF7981, 0xFF5BC5, 0xFF48F2, 0xDF49FF, 0x476DFF, 0x00B4F7, 0x00E0FF, 0x00E375, 0x03F42B, 0x78B82E, 0xE5E218, 0x787878, 0x000000, 0x000000, 0xFFFFFF, 0xFFF2BE, 0xF8B8B8, 0xF8B8D8, 0xFFB6FF, 0xFFC3FF, 0xC7D1FF, 0x9ADAFF, 0x88EDF8, 0x83FFDD, 0xB8F8B8, 0xF5F8AC, 0xFFFFB0, 0xF8D8F8, 0x000000, 0x000000];\n    this.makeTables();\n    this.setEmphasis(0);\n  },\n\n  loadPALPalette: function() {\n    // prettier-ignore\n    this.curTable = [0x525252, 0xB40000, 0xA00000, 0xB1003D, 0x740069, 0x00005B, 0x00005F, 0x001840, 0x002F10, 0x084A08, 0x006700, 0x124200, 0x6D2800, 0x000000, 0x000000, 0x000000, 0xC4D5E7, 0xFF4000, 0xDC0E22, 0xFF476B, 0xD7009F, 0x680AD7, 0x0019BC, 0x0054B1, 0x006A5B, 0x008C03, 0x00AB00, 0x2C8800, 0xA47200, 0x000000, 0x000000, 0x000000, 0xF8F8F8, 0xFFAB3C, 0xFF7981, 0xFF5BC5, 0xFF48F2, 0xDF49FF, 0x476DFF, 0x00B4F7, 0x00E0FF, 0x00E375, 0x03F42B, 0x78B82E, 0xE5E218, 0x787878, 0x000000, 0x000000, 0xFFFFFF, 0xFFF2BE, 0xF8B8B8, 0xF8B8D8, 0xFFB6FF, 0xFFC3FF, 0xC7D1FF, 0x9ADAFF, 0x88EDF8, 0x83FFDD, 0xB8F8B8, 0xF5F8AC, 0xFFFFB0, 0xF8D8F8, 0x000000, 0x000000];\n    this.makeTables();\n    this.setEmphasis(0);\n  },\n\n  makeTables: function() {\n    var r, g, b, col, i, rFactor, gFactor, bFactor;\n\n    // Calculate a table for each possible emphasis setting:\n    for (var emph = 0; emph < 8; emph++) {\n      // Determine color component factors:\n      rFactor = 1.0;\n      gFactor = 1.0;\n      bFactor = 1.0;\n\n      if ((emph & 1) !== 0) {\n        rFactor = 0.75;\n        bFactor = 0.75;\n      }\n      if ((emph & 2) !== 0) {\n        rFactor = 0.75;\n        gFactor = 0.75;\n      }\n      if ((emph & 4) !== 0) {\n        gFactor = 0.75;\n        bFactor = 0.75;\n      }\n\n      this.emphTable[emph] = new Array(64);\n\n      // Calculate table:\n      for (i = 0; i < 64; i++) {\n        col = this.curTable[i];\n        r = Math.floor(this.getRed(col) * rFactor);\n        g = Math.floor(this.getGreen(col) * gFactor);\n        b = Math.floor(this.getBlue(col) * bFactor);\n        this.emphTable[emph][i] = this.getRgb(r, g, b);\n      }\n    }\n  },\n\n  setEmphasis: function(emph) {\n    if (emph !== this.currentEmph) {\n      this.currentEmph = emph;\n      for (var i = 0; i < 64; i++) {\n        this.curTable[i] = this.emphTable[emph][i];\n      }\n    }\n  },\n\n  getEntry: function(yiq) {\n    return this.curTable[yiq];\n  },\n\n  getRed: function(rgb) {\n    return (rgb >> 16) & 0xff;\n  },\n\n  getGreen: function(rgb) {\n    return (rgb >> 8) & 0xff;\n  },\n\n  getBlue: function(rgb) {\n    return rgb & 0xff;\n  },\n\n  getRgb: function(r, g, b) {\n    return (r << 16) | (g << 8) | b;\n  },\n\n  loadDefaultPalette: function() {\n    this.curTable[0] = this.getRgb(117, 117, 117);\n    this.curTable[1] = this.getRgb(39, 27, 143);\n    this.curTable[2] = this.getRgb(0, 0, 171);\n    this.curTable[3] = this.getRgb(71, 0, 159);\n    this.curTable[4] = this.getRgb(143, 0, 119);\n    this.curTable[5] = this.getRgb(171, 0, 19);\n    this.curTable[6] = this.getRgb(167, 0, 0);\n    this.curTable[7] = this.getRgb(127, 11, 0);\n    this.curTable[8] = this.getRgb(67, 47, 0);\n    this.curTable[9] = this.getRgb(0, 71, 0);\n    this.curTable[10] = this.getRgb(0, 81, 0);\n    this.curTable[11] = this.getRgb(0, 63, 23);\n    this.curTable[12] = this.getRgb(27, 63, 95);\n    this.curTable[13] = this.getRgb(0, 0, 0);\n    this.curTable[14] = this.getRgb(0, 0, 0);\n    this.curTable[15] = this.getRgb(0, 0, 0);\n    this.curTable[16] = this.getRgb(188, 188, 188);\n    this.curTable[17] = this.getRgb(0, 115, 239);\n    this.curTable[18] = this.getRgb(35, 59, 239);\n    this.curTable[19] = this.getRgb(131, 0, 243);\n    this.curTable[20] = this.getRgb(191, 0, 191);\n    this.curTable[21] = this.getRgb(231, 0, 91);\n    this.curTable[22] = this.getRgb(219, 43, 0);\n    this.curTable[23] = this.getRgb(203, 79, 15);\n    this.curTable[24] = this.getRgb(139, 115, 0);\n    this.curTable[25] = this.getRgb(0, 151, 0);\n    this.curTable[26] = this.getRgb(0, 171, 0);\n    this.curTable[27] = this.getRgb(0, 147, 59);\n    this.curTable[28] = this.getRgb(0, 131, 139);\n    this.curTable[29] = this.getRgb(0, 0, 0);\n    this.curTable[30] = this.getRgb(0, 0, 0);\n    this.curTable[31] = this.getRgb(0, 0, 0);\n    this.curTable[32] = this.getRgb(255, 255, 255);\n    this.curTable[33] = this.getRgb(63, 191, 255);\n    this.curTable[34] = this.getRgb(95, 151, 255);\n    this.curTable[35] = this.getRgb(167, 139, 253);\n    this.curTable[36] = this.getRgb(247, 123, 255);\n    this.curTable[37] = this.getRgb(255, 119, 183);\n    this.curTable[38] = this.getRgb(255, 119, 99);\n    this.curTable[39] = this.getRgb(255, 155, 59);\n    this.curTable[40] = this.getRgb(243, 191, 63);\n    this.curTable[41] = this.getRgb(131, 211, 19);\n    this.curTable[42] = this.getRgb(79, 223, 75);\n    this.curTable[43] = this.getRgb(88, 248, 152);\n    this.curTable[44] = this.getRgb(0, 235, 219);\n    this.curTable[45] = this.getRgb(0, 0, 0);\n    this.curTable[46] = this.getRgb(0, 0, 0);\n    this.curTable[47] = this.getRgb(0, 0, 0);\n    this.curTable[48] = this.getRgb(255, 255, 255);\n    this.curTable[49] = this.getRgb(171, 231, 255);\n    this.curTable[50] = this.getRgb(199, 215, 255);\n    this.curTable[51] = this.getRgb(215, 203, 255);\n    this.curTable[52] = this.getRgb(255, 199, 255);\n    this.curTable[53] = this.getRgb(255, 199, 219);\n    this.curTable[54] = this.getRgb(255, 191, 179);\n    this.curTable[55] = this.getRgb(255, 219, 171);\n    this.curTable[56] = this.getRgb(255, 231, 163);\n    this.curTable[57] = this.getRgb(227, 255, 163);\n    this.curTable[58] = this.getRgb(171, 243, 191);\n    this.curTable[59] = this.getRgb(179, 255, 207);\n    this.curTable[60] = this.getRgb(159, 255, 243);\n    this.curTable[61] = this.getRgb(0, 0, 0);\n    this.curTable[62] = this.getRgb(0, 0, 0);\n    this.curTable[63] = this.getRgb(0, 0, 0);\n\n    this.makeTables();\n    this.setEmphasis(0);\n  }\n};\n\nmodule.exports = PPU;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ppu.js\n// module id = 6\n// module chunks = 0 1","var CPU_FREQ_NTSC = 1789772.5; //1789772.72727272d;\n// var CPU_FREQ_PAL = 1773447.4;\n\nvar PAPU = function(nes) {\n  this.nes = nes;\n\n  this.square1 = new ChannelSquare(this, true);\n  this.square2 = new ChannelSquare(this, false);\n  this.triangle = new ChannelTriangle(this);\n  this.noise = new ChannelNoise(this);\n  this.dmc = new ChannelDM(this);\n\n  this.frameIrqCounter = null;\n  this.frameIrqCounterMax = 4;\n  this.initCounter = 2048;\n  this.channelEnableValue = null;\n\n  this.sampleRate = 44100;\n\n  this.lengthLookup = null;\n  this.dmcFreqLookup = null;\n  this.noiseWavelengthLookup = null;\n  this.square_table = null;\n  this.tnd_table = null;\n\n  this.frameIrqEnabled = false;\n  this.frameIrqActive = null;\n  this.frameClockNow = null;\n  this.startedPlaying = false;\n  this.recordOutput = false;\n  this.initingHardware = false;\n\n  this.masterFrameCounter = null;\n  this.derivedFrameCounter = null;\n  this.countSequence = null;\n  this.sampleTimer = null;\n  this.frameTime = null;\n  this.sampleTimerMax = null;\n  this.sampleCount = null;\n  this.triValue = 0;\n\n  this.smpSquare1 = null;\n  this.smpSquare2 = null;\n  this.smpTriangle = null;\n  this.smpDmc = null;\n  this.accCount = null;\n\n  // DC removal vars:\n  this.prevSampleL = 0;\n  this.prevSampleR = 0;\n  this.smpAccumL = 0;\n  this.smpAccumR = 0;\n\n  // DAC range:\n  this.dacRange = 0;\n  this.dcValue = 0;\n\n  // Master volume:\n  this.masterVolume = 256;\n\n  // Stereo positioning:\n  this.stereoPosLSquare1 = null;\n  this.stereoPosLSquare2 = null;\n  this.stereoPosLTriangle = null;\n  this.stereoPosLNoise = null;\n  this.stereoPosLDMC = null;\n  this.stereoPosRSquare1 = null;\n  this.stereoPosRSquare2 = null;\n  this.stereoPosRTriangle = null;\n  this.stereoPosRNoise = null;\n  this.stereoPosRDMC = null;\n\n  this.extraCycles = null;\n\n  this.maxSample = null;\n  this.minSample = null;\n\n  // Panning:\n  this.panning = [80, 170, 100, 150, 128];\n  this.setPanning(this.panning);\n\n  // Initialize lookup tables:\n  this.initLengthLookup();\n  this.initDmcFrequencyLookup();\n  this.initNoiseWavelengthLookup();\n  this.initDACtables();\n\n  // Init sound registers:\n  for (var i = 0; i < 0x14; i++) {\n    if (i === 0x10) {\n      this.writeReg(0x4010, 0x10);\n    } else {\n      this.writeReg(0x4000 + i, 0);\n    }\n  }\n\n  this.reset();\n};\n\nPAPU.prototype = {\n  reset: function() {\n    this.sampleRate = this.nes.opts.sampleRate;\n    this.sampleTimerMax = Math.floor(\n      1024.0 *\n        CPU_FREQ_NTSC *\n        this.nes.opts.preferredFrameRate /\n        (this.sampleRate * 60.0)\n    );\n\n    this.frameTime = Math.floor(\n      14915.0 * this.nes.opts.preferredFrameRate / 60.0\n    );\n\n    this.sampleTimer = 0;\n\n    this.updateChannelEnable(0);\n    this.masterFrameCounter = 0;\n    this.derivedFrameCounter = 0;\n    this.countSequence = 0;\n    this.sampleCount = 0;\n    this.initCounter = 2048;\n    this.frameIrqEnabled = false;\n    this.initingHardware = false;\n\n    this.resetCounter();\n\n    this.square1.reset();\n    this.square2.reset();\n    this.triangle.reset();\n    this.noise.reset();\n    this.dmc.reset();\n\n    this.accCount = 0;\n    this.smpSquare1 = 0;\n    this.smpSquare2 = 0;\n    this.smpTriangle = 0;\n    this.smpDmc = 0;\n\n    this.frameIrqEnabled = false;\n    this.frameIrqCounterMax = 4;\n\n    this.channelEnableValue = 0xff;\n    this.startedPlaying = false;\n    this.prevSampleL = 0;\n    this.prevSampleR = 0;\n    this.smpAccumL = 0;\n    this.smpAccumR = 0;\n\n    this.maxSample = -500000;\n    this.minSample = 500000;\n  },\n\n  readReg: function(address) {\n    // Read 0x4015:\n    var tmp = 0;\n    tmp |= this.square1.getLengthStatus();\n    tmp |= this.square2.getLengthStatus() << 1;\n    tmp |= this.triangle.getLengthStatus() << 2;\n    tmp |= this.noise.getLengthStatus() << 3;\n    tmp |= this.dmc.getLengthStatus() << 4;\n    tmp |= (this.frameIrqActive && this.frameIrqEnabled ? 1 : 0) << 6;\n    tmp |= this.dmc.getIrqStatus() << 7;\n\n    this.frameIrqActive = false;\n    this.dmc.irqGenerated = false;\n\n    return tmp & 0xffff;\n  },\n\n  writeReg: function(address, value) {\n    if (address >= 0x4000 && address < 0x4004) {\n      // Square Wave 1 Control\n      this.square1.writeReg(address, value);\n      // console.log(\"Square Write\");\n    } else if (address >= 0x4004 && address < 0x4008) {\n      // Square 2 Control\n      this.square2.writeReg(address, value);\n    } else if (address >= 0x4008 && address < 0x400c) {\n      // Triangle Control\n      this.triangle.writeReg(address, value);\n    } else if (address >= 0x400c && address <= 0x400f) {\n      // Noise Control\n      this.noise.writeReg(address, value);\n    } else if (address === 0x4010) {\n      // DMC Play mode & DMA frequency\n      this.dmc.writeReg(address, value);\n    } else if (address === 0x4011) {\n      // DMC Delta Counter\n      this.dmc.writeReg(address, value);\n    } else if (address === 0x4012) {\n      // DMC Play code starting address\n      this.dmc.writeReg(address, value);\n    } else if (address === 0x4013) {\n      // DMC Play code length\n      this.dmc.writeReg(address, value);\n    } else if (address === 0x4015) {\n      // Channel enable\n      this.updateChannelEnable(value);\n\n      if (value !== 0 && this.initCounter > 0) {\n        // Start hardware initialization\n        this.initingHardware = true;\n      }\n\n      // DMC/IRQ Status\n      this.dmc.writeReg(address, value);\n    } else if (address === 0x4017) {\n      // Frame counter control\n      this.countSequence = (value >> 7) & 1;\n      this.masterFrameCounter = 0;\n      this.frameIrqActive = false;\n\n      if (((value >> 6) & 0x1) === 0) {\n        this.frameIrqEnabled = true;\n      } else {\n        this.frameIrqEnabled = false;\n      }\n\n      if (this.countSequence === 0) {\n        // NTSC:\n        this.frameIrqCounterMax = 4;\n        this.derivedFrameCounter = 4;\n      } else {\n        // PAL:\n        this.frameIrqCounterMax = 5;\n        this.derivedFrameCounter = 0;\n        this.frameCounterTick();\n      }\n    }\n  },\n\n  resetCounter: function() {\n    if (this.countSequence === 0) {\n      this.derivedFrameCounter = 4;\n    } else {\n      this.derivedFrameCounter = 0;\n    }\n  },\n\n  // Updates channel enable status.\n  // This is done on writes to the\n  // channel enable register (0x4015),\n  // and when the user enables/disables channels\n  // in the GUI.\n  updateChannelEnable: function(value) {\n    this.channelEnableValue = value & 0xffff;\n    this.square1.setEnabled((value & 1) !== 0);\n    this.square2.setEnabled((value & 2) !== 0);\n    this.triangle.setEnabled((value & 4) !== 0);\n    this.noise.setEnabled((value & 8) !== 0);\n    this.dmc.setEnabled((value & 16) !== 0);\n  },\n\n  // Clocks the frame counter. It should be clocked at\n  // twice the cpu speed, so the cycles will be\n  // divided by 2 for those counters that are\n  // clocked at cpu speed.\n  clockFrameCounter: function(nCycles) {\n    if (this.initCounter > 0) {\n      if (this.initingHardware) {\n        this.initCounter -= nCycles;\n        if (this.initCounter <= 0) {\n          this.initingHardware = false;\n        }\n        return;\n      }\n    }\n\n    // Don't process ticks beyond next sampling:\n    nCycles += this.extraCycles;\n    var maxCycles = this.sampleTimerMax - this.sampleTimer;\n    if (nCycles << 10 > maxCycles) {\n      this.extraCycles = ((nCycles << 10) - maxCycles) >> 10;\n      nCycles -= this.extraCycles;\n    } else {\n      this.extraCycles = 0;\n    }\n\n    var dmc = this.dmc;\n    var triangle = this.triangle;\n    var square1 = this.square1;\n    var square2 = this.square2;\n    var noise = this.noise;\n\n    // Clock DMC:\n    if (dmc.isEnabled) {\n      dmc.shiftCounter -= nCycles << 3;\n      while (dmc.shiftCounter <= 0 && dmc.dmaFrequency > 0) {\n        dmc.shiftCounter += dmc.dmaFrequency;\n        dmc.clockDmc();\n      }\n    }\n\n    // Clock Triangle channel Prog timer:\n    if (triangle.progTimerMax > 0) {\n      triangle.progTimerCount -= nCycles;\n      while (triangle.progTimerCount <= 0) {\n        triangle.progTimerCount += triangle.progTimerMax + 1;\n        if (triangle.linearCounter > 0 && triangle.lengthCounter > 0) {\n          triangle.triangleCounter++;\n          triangle.triangleCounter &= 0x1f;\n\n          if (triangle.isEnabled) {\n            if (triangle.triangleCounter >= 0x10) {\n              // Normal value.\n              triangle.sampleValue = triangle.triangleCounter & 0xf;\n            } else {\n              // Inverted value.\n              triangle.sampleValue = 0xf - (triangle.triangleCounter & 0xf);\n            }\n            triangle.sampleValue <<= 4;\n          }\n        }\n      }\n    }\n\n    // Clock Square channel 1 Prog timer:\n    square1.progTimerCount -= nCycles;\n    if (square1.progTimerCount <= 0) {\n      square1.progTimerCount += (square1.progTimerMax + 1) << 1;\n\n      square1.squareCounter++;\n      square1.squareCounter &= 0x7;\n      square1.updateSampleValue();\n    }\n\n    // Clock Square channel 2 Prog timer:\n    square2.progTimerCount -= nCycles;\n    if (square2.progTimerCount <= 0) {\n      square2.progTimerCount += (square2.progTimerMax + 1) << 1;\n\n      square2.squareCounter++;\n      square2.squareCounter &= 0x7;\n      square2.updateSampleValue();\n    }\n\n    // Clock noise channel Prog timer:\n    var acc_c = nCycles;\n    if (noise.progTimerCount - acc_c > 0) {\n      // Do all cycles at once:\n      noise.progTimerCount -= acc_c;\n      noise.accCount += acc_c;\n      noise.accValue += acc_c * noise.sampleValue;\n    } else {\n      // Slow-step:\n      while (acc_c-- > 0) {\n        if (--noise.progTimerCount <= 0 && noise.progTimerMax > 0) {\n          // Update noise shift register:\n          noise.shiftReg <<= 1;\n          noise.tmp =\n            ((noise.shiftReg << (noise.randomMode === 0 ? 1 : 6)) ^\n              noise.shiftReg) &\n            0x8000;\n          if (noise.tmp !== 0) {\n            // Sample value must be 0.\n            noise.shiftReg |= 0x01;\n            noise.randomBit = 0;\n            noise.sampleValue = 0;\n          } else {\n            // Find sample value:\n            noise.randomBit = 1;\n            if (noise.isEnabled && noise.lengthCounter > 0) {\n              noise.sampleValue = noise.masterVolume;\n            } else {\n              noise.sampleValue = 0;\n            }\n          }\n\n          noise.progTimerCount += noise.progTimerMax;\n        }\n\n        noise.accValue += noise.sampleValue;\n        noise.accCount++;\n      }\n    }\n\n    // Frame IRQ handling:\n    if (this.frameIrqEnabled && this.frameIrqActive) {\n      this.nes.cpu.requestIrq(this.nes.cpu.IRQ_NORMAL);\n    }\n\n    // Clock frame counter at double CPU speed:\n    this.masterFrameCounter += nCycles << 1;\n    if (this.masterFrameCounter >= this.frameTime) {\n      // 240Hz tick:\n      this.masterFrameCounter -= this.frameTime;\n      this.frameCounterTick();\n    }\n\n    // Accumulate sample value:\n    this.accSample(nCycles);\n\n    // Clock sample timer:\n    this.sampleTimer += nCycles << 10;\n    if (this.sampleTimer >= this.sampleTimerMax) {\n      // Sample channels:\n      this.sample();\n      this.sampleTimer -= this.sampleTimerMax;\n    }\n  },\n\n  accSample: function(cycles) {\n    // Special treatment for triangle channel - need to interpolate.\n    if (this.triangle.sampleCondition) {\n      this.triValue = Math.floor(\n        (this.triangle.progTimerCount << 4) / (this.triangle.progTimerMax + 1)\n      );\n      if (this.triValue > 16) {\n        this.triValue = 16;\n      }\n      if (this.triangle.triangleCounter >= 16) {\n        this.triValue = 16 - this.triValue;\n      }\n\n      // Add non-interpolated sample value:\n      this.triValue += this.triangle.sampleValue;\n    }\n\n    // Now sample normally:\n    if (cycles === 2) {\n      this.smpTriangle += this.triValue << 1;\n      this.smpDmc += this.dmc.sample << 1;\n      this.smpSquare1 += this.square1.sampleValue << 1;\n      this.smpSquare2 += this.square2.sampleValue << 1;\n      this.accCount += 2;\n    } else if (cycles === 4) {\n      this.smpTriangle += this.triValue << 2;\n      this.smpDmc += this.dmc.sample << 2;\n      this.smpSquare1 += this.square1.sampleValue << 2;\n      this.smpSquare2 += this.square2.sampleValue << 2;\n      this.accCount += 4;\n    } else {\n      this.smpTriangle += cycles * this.triValue;\n      this.smpDmc += cycles * this.dmc.sample;\n      this.smpSquare1 += cycles * this.square1.sampleValue;\n      this.smpSquare2 += cycles * this.square2.sampleValue;\n      this.accCount += cycles;\n    }\n  },\n\n  frameCounterTick: function() {\n    this.derivedFrameCounter++;\n    if (this.derivedFrameCounter >= this.frameIrqCounterMax) {\n      this.derivedFrameCounter = 0;\n    }\n\n    if (this.derivedFrameCounter === 1 || this.derivedFrameCounter === 3) {\n      // Clock length & sweep:\n      this.triangle.clockLengthCounter();\n      this.square1.clockLengthCounter();\n      this.square2.clockLengthCounter();\n      this.noise.clockLengthCounter();\n      this.square1.clockSweep();\n      this.square2.clockSweep();\n    }\n\n    if (this.derivedFrameCounter >= 0 && this.derivedFrameCounter < 4) {\n      // Clock linear & decay:\n      this.square1.clockEnvDecay();\n      this.square2.clockEnvDecay();\n      this.noise.clockEnvDecay();\n      this.triangle.clockLinearCounter();\n    }\n\n    if (this.derivedFrameCounter === 3 && this.countSequence === 0) {\n      // Enable IRQ:\n      this.frameIrqActive = true;\n    }\n\n    // End of 240Hz tick\n  },\n\n  // Samples the channels, mixes the output together, then writes to buffer.\n  sample: function() {\n    var sq_index, tnd_index;\n\n    if (this.accCount > 0) {\n      this.smpSquare1 <<= 4;\n      this.smpSquare1 = Math.floor(this.smpSquare1 / this.accCount);\n\n      this.smpSquare2 <<= 4;\n      this.smpSquare2 = Math.floor(this.smpSquare2 / this.accCount);\n\n      this.smpTriangle = Math.floor(this.smpTriangle / this.accCount);\n\n      this.smpDmc <<= 4;\n      this.smpDmc = Math.floor(this.smpDmc / this.accCount);\n\n      this.accCount = 0;\n    } else {\n      this.smpSquare1 = this.square1.sampleValue << 4;\n      this.smpSquare2 = this.square2.sampleValue << 4;\n      this.smpTriangle = this.triangle.sampleValue;\n      this.smpDmc = this.dmc.sample << 4;\n    }\n\n    var smpNoise = Math.floor((this.noise.accValue << 4) / this.noise.accCount);\n    this.noise.accValue = smpNoise >> 4;\n    this.noise.accCount = 1;\n\n    // Stereo sound.\n\n    // Left channel:\n    sq_index =\n      (this.smpSquare1 * this.stereoPosLSquare1 +\n        this.smpSquare2 * this.stereoPosLSquare2) >>\n      8;\n    tnd_index =\n      (3 * this.smpTriangle * this.stereoPosLTriangle +\n        (smpNoise << 1) * this.stereoPosLNoise +\n        this.smpDmc * this.stereoPosLDMC) >>\n      8;\n    if (sq_index >= this.square_table.length) {\n      sq_index = this.square_table.length - 1;\n    }\n    if (tnd_index >= this.tnd_table.length) {\n      tnd_index = this.tnd_table.length - 1;\n    }\n    var sampleValueL =\n      this.square_table[sq_index] + this.tnd_table[tnd_index] - this.dcValue;\n\n    // Right channel:\n    sq_index =\n      (this.smpSquare1 * this.stereoPosRSquare1 +\n        this.smpSquare2 * this.stereoPosRSquare2) >>\n      8;\n    tnd_index =\n      (3 * this.smpTriangle * this.stereoPosRTriangle +\n        (smpNoise << 1) * this.stereoPosRNoise +\n        this.smpDmc * this.stereoPosRDMC) >>\n      8;\n    if (sq_index >= this.square_table.length) {\n      sq_index = this.square_table.length - 1;\n    }\n    if (tnd_index >= this.tnd_table.length) {\n      tnd_index = this.tnd_table.length - 1;\n    }\n    var sampleValueR =\n      this.square_table[sq_index] + this.tnd_table[tnd_index] - this.dcValue;\n\n    // Remove DC from left channel:\n    var smpDiffL = sampleValueL - this.prevSampleL;\n    this.prevSampleL += smpDiffL;\n    this.smpAccumL += smpDiffL - (this.smpAccumL >> 10);\n    sampleValueL = this.smpAccumL;\n\n    // Remove DC from right channel:\n    var smpDiffR = sampleValueR - this.prevSampleR;\n    this.prevSampleR += smpDiffR;\n    this.smpAccumR += smpDiffR - (this.smpAccumR >> 10);\n    sampleValueR = this.smpAccumR;\n\n    // Write:\n    if (sampleValueL > this.maxSample) {\n      this.maxSample = sampleValueL;\n    }\n    if (sampleValueL < this.minSample) {\n      this.minSample = sampleValueL;\n    }\n\n    if (this.nes.opts.onAudioSample) {\n      this.nes.opts.onAudioSample(sampleValueL / 32768, sampleValueR / 32768);\n    }\n\n    // Reset sampled values:\n    this.smpSquare1 = 0;\n    this.smpSquare2 = 0;\n    this.smpTriangle = 0;\n    this.smpDmc = 0;\n  },\n\n  getLengthMax: function(value) {\n    return this.lengthLookup[value >> 3];\n  },\n\n  getDmcFrequency: function(value) {\n    if (value >= 0 && value < 0x10) {\n      return this.dmcFreqLookup[value];\n    }\n    return 0;\n  },\n\n  getNoiseWaveLength: function(value) {\n    if (value >= 0 && value < 0x10) {\n      return this.noiseWavelengthLookup[value];\n    }\n    return 0;\n  },\n\n  setPanning: function(pos) {\n    for (var i = 0; i < 5; i++) {\n      this.panning[i] = pos[i];\n    }\n    this.updateStereoPos();\n  },\n\n  setMasterVolume: function(value) {\n    if (value < 0) {\n      value = 0;\n    }\n    if (value > 256) {\n      value = 256;\n    }\n    this.masterVolume = value;\n    this.updateStereoPos();\n  },\n\n  updateStereoPos: function() {\n    this.stereoPosLSquare1 = (this.panning[0] * this.masterVolume) >> 8;\n    this.stereoPosLSquare2 = (this.panning[1] * this.masterVolume) >> 8;\n    this.stereoPosLTriangle = (this.panning[2] * this.masterVolume) >> 8;\n    this.stereoPosLNoise = (this.panning[3] * this.masterVolume) >> 8;\n    this.stereoPosLDMC = (this.panning[4] * this.masterVolume) >> 8;\n\n    this.stereoPosRSquare1 = this.masterVolume - this.stereoPosLSquare1;\n    this.stereoPosRSquare2 = this.masterVolume - this.stereoPosLSquare2;\n    this.stereoPosRTriangle = this.masterVolume - this.stereoPosLTriangle;\n    this.stereoPosRNoise = this.masterVolume - this.stereoPosLNoise;\n    this.stereoPosRDMC = this.masterVolume - this.stereoPosLDMC;\n  },\n\n  initLengthLookup: function() {\n    // prettier-ignore\n    this.lengthLookup = [\n            0x0A, 0xFE,\n            0x14, 0x02,\n            0x28, 0x04,\n            0x50, 0x06,\n            0xA0, 0x08,\n            0x3C, 0x0A,\n            0x0E, 0x0C,\n            0x1A, 0x0E,\n            0x0C, 0x10,\n            0x18, 0x12,\n            0x30, 0x14,\n            0x60, 0x16,\n            0xC0, 0x18,\n            0x48, 0x1A,\n            0x10, 0x1C,\n            0x20, 0x1E\n        ];\n  },\n\n  initDmcFrequencyLookup: function() {\n    this.dmcFreqLookup = new Array(16);\n\n    this.dmcFreqLookup[0x0] = 0xd60;\n    this.dmcFreqLookup[0x1] = 0xbe0;\n    this.dmcFreqLookup[0x2] = 0xaa0;\n    this.dmcFreqLookup[0x3] = 0xa00;\n    this.dmcFreqLookup[0x4] = 0x8f0;\n    this.dmcFreqLookup[0x5] = 0x7f0;\n    this.dmcFreqLookup[0x6] = 0x710;\n    this.dmcFreqLookup[0x7] = 0x6b0;\n    this.dmcFreqLookup[0x8] = 0x5f0;\n    this.dmcFreqLookup[0x9] = 0x500;\n    this.dmcFreqLookup[0xa] = 0x470;\n    this.dmcFreqLookup[0xb] = 0x400;\n    this.dmcFreqLookup[0xc] = 0x350;\n    this.dmcFreqLookup[0xd] = 0x2a0;\n    this.dmcFreqLookup[0xe] = 0x240;\n    this.dmcFreqLookup[0xf] = 0x1b0;\n    //for(int i=0;i<16;i++)dmcFreqLookup[i]/=8;\n  },\n\n  initNoiseWavelengthLookup: function() {\n    this.noiseWavelengthLookup = new Array(16);\n\n    this.noiseWavelengthLookup[0x0] = 0x004;\n    this.noiseWavelengthLookup[0x1] = 0x008;\n    this.noiseWavelengthLookup[0x2] = 0x010;\n    this.noiseWavelengthLookup[0x3] = 0x020;\n    this.noiseWavelengthLookup[0x4] = 0x040;\n    this.noiseWavelengthLookup[0x5] = 0x060;\n    this.noiseWavelengthLookup[0x6] = 0x080;\n    this.noiseWavelengthLookup[0x7] = 0x0a0;\n    this.noiseWavelengthLookup[0x8] = 0x0ca;\n    this.noiseWavelengthLookup[0x9] = 0x0fe;\n    this.noiseWavelengthLookup[0xa] = 0x17c;\n    this.noiseWavelengthLookup[0xb] = 0x1fc;\n    this.noiseWavelengthLookup[0xc] = 0x2fa;\n    this.noiseWavelengthLookup[0xd] = 0x3f8;\n    this.noiseWavelengthLookup[0xe] = 0x7f2;\n    this.noiseWavelengthLookup[0xf] = 0xfe4;\n  },\n\n  initDACtables: function() {\n    var value, ival, i;\n    var max_sqr = 0;\n    var max_tnd = 0;\n\n    this.square_table = new Array(32 * 16);\n    this.tnd_table = new Array(204 * 16);\n\n    for (i = 0; i < 32 * 16; i++) {\n      value = 95.52 / (8128.0 / (i / 16.0) + 100.0);\n      value *= 0.98411;\n      value *= 50000.0;\n      ival = Math.floor(value);\n\n      this.square_table[i] = ival;\n      if (ival > max_sqr) {\n        max_sqr = ival;\n      }\n    }\n\n    for (i = 0; i < 204 * 16; i++) {\n      value = 163.67 / (24329.0 / (i / 16.0) + 100.0);\n      value *= 0.98411;\n      value *= 50000.0;\n      ival = Math.floor(value);\n\n      this.tnd_table[i] = ival;\n      if (ival > max_tnd) {\n        max_tnd = ival;\n      }\n    }\n\n    this.dacRange = max_sqr + max_tnd;\n    this.dcValue = this.dacRange / 2;\n  }\n};\n\nvar ChannelDM = function(papu) {\n  this.papu = papu;\n\n  this.MODE_NORMAL = 0;\n  this.MODE_LOOP = 1;\n  this.MODE_IRQ = 2;\n\n  this.isEnabled = null;\n  this.hasSample = null;\n  this.irqGenerated = false;\n\n  this.playMode = null;\n  this.dmaFrequency = null;\n  this.dmaCounter = null;\n  this.deltaCounter = null;\n  this.playStartAddress = null;\n  this.playAddress = null;\n  this.playLength = null;\n  this.playLengthCounter = null;\n  this.shiftCounter = null;\n  this.reg4012 = null;\n  this.reg4013 = null;\n  this.sample = null;\n  this.dacLsb = null;\n  this.data = null;\n\n  this.reset();\n};\n\nChannelDM.prototype = {\n  clockDmc: function() {\n    // Only alter DAC value if the sample buffer has data:\n    if (this.hasSample) {\n      if ((this.data & 1) === 0) {\n        // Decrement delta:\n        if (this.deltaCounter > 0) {\n          this.deltaCounter--;\n        }\n      } else {\n        // Increment delta:\n        if (this.deltaCounter < 63) {\n          this.deltaCounter++;\n        }\n      }\n\n      // Update sample value:\n      this.sample = this.isEnabled ? (this.deltaCounter << 1) + this.dacLsb : 0;\n\n      // Update shift register:\n      this.data >>= 1;\n    }\n\n    this.dmaCounter--;\n    if (this.dmaCounter <= 0) {\n      // No more sample bits.\n      this.hasSample = false;\n      this.endOfSample();\n      this.dmaCounter = 8;\n    }\n\n    if (this.irqGenerated) {\n      this.papu.nes.cpu.requestIrq(this.papu.nes.cpu.IRQ_NORMAL);\n    }\n  },\n\n  endOfSample: function() {\n    if (this.playLengthCounter === 0 && this.playMode === this.MODE_LOOP) {\n      // Start from beginning of sample:\n      this.playAddress = this.playStartAddress;\n      this.playLengthCounter = this.playLength;\n    }\n\n    if (this.playLengthCounter > 0) {\n      // Fetch next sample:\n      this.nextSample();\n\n      if (this.playLengthCounter === 0) {\n        // Last byte of sample fetched, generate IRQ:\n        if (this.playMode === this.MODE_IRQ) {\n          // Generate IRQ:\n          this.irqGenerated = true;\n        }\n      }\n    }\n  },\n\n  nextSample: function() {\n    // Fetch byte:\n    this.data = this.papu.nes.mmap.load(this.playAddress);\n    this.papu.nes.cpu.haltCycles(4);\n\n    this.playLengthCounter--;\n    this.playAddress++;\n    if (this.playAddress > 0xffff) {\n      this.playAddress = 0x8000;\n    }\n\n    this.hasSample = true;\n  },\n\n  writeReg: function(address, value) {\n    if (address === 0x4010) {\n      // Play mode, DMA Frequency\n      if (value >> 6 === 0) {\n        this.playMode = this.MODE_NORMAL;\n      } else if (((value >> 6) & 1) === 1) {\n        this.playMode = this.MODE_LOOP;\n      } else if (value >> 6 === 2) {\n        this.playMode = this.MODE_IRQ;\n      }\n\n      if ((value & 0x80) === 0) {\n        this.irqGenerated = false;\n      }\n\n      this.dmaFrequency = this.papu.getDmcFrequency(value & 0xf);\n    } else if (address === 0x4011) {\n      // Delta counter load register:\n      this.deltaCounter = (value >> 1) & 63;\n      this.dacLsb = value & 1;\n      this.sample = (this.deltaCounter << 1) + this.dacLsb; // update sample value\n    } else if (address === 0x4012) {\n      // DMA address load register\n      this.playStartAddress = (value << 6) | 0x0c000;\n      this.playAddress = this.playStartAddress;\n      this.reg4012 = value;\n    } else if (address === 0x4013) {\n      // Length of play code\n      this.playLength = (value << 4) + 1;\n      this.playLengthCounter = this.playLength;\n      this.reg4013 = value;\n    } else if (address === 0x4015) {\n      // DMC/IRQ Status\n      if (((value >> 4) & 1) === 0) {\n        // Disable:\n        this.playLengthCounter = 0;\n      } else {\n        // Restart:\n        this.playAddress = this.playStartAddress;\n        this.playLengthCounter = this.playLength;\n      }\n      this.irqGenerated = false;\n    }\n  },\n\n  setEnabled: function(value) {\n    if (!this.isEnabled && value) {\n      this.playLengthCounter = this.playLength;\n    }\n    this.isEnabled = value;\n  },\n\n  getLengthStatus: function() {\n    return this.playLengthCounter === 0 || !this.isEnabled ? 0 : 1;\n  },\n\n  getIrqStatus: function() {\n    return this.irqGenerated ? 1 : 0;\n  },\n\n  reset: function() {\n    this.isEnabled = false;\n    this.irqGenerated = false;\n    this.playMode = this.MODE_NORMAL;\n    this.dmaFrequency = 0;\n    this.dmaCounter = 0;\n    this.deltaCounter = 0;\n    this.playStartAddress = 0;\n    this.playAddress = 0;\n    this.playLength = 0;\n    this.playLengthCounter = 0;\n    this.sample = 0;\n    this.dacLsb = 0;\n    this.shiftCounter = 0;\n    this.reg4012 = 0;\n    this.reg4013 = 0;\n    this.data = 0;\n  }\n};\n\nvar ChannelNoise = function(papu) {\n  this.papu = papu;\n\n  this.isEnabled = null;\n  this.envDecayDisable = null;\n  this.envDecayLoopEnable = null;\n  this.lengthCounterEnable = null;\n  this.envReset = null;\n  this.shiftNow = null;\n\n  this.lengthCounter = null;\n  this.progTimerCount = null;\n  this.progTimerMax = null;\n  this.envDecayRate = null;\n  this.envDecayCounter = null;\n  this.envVolume = null;\n  this.masterVolume = null;\n  this.shiftReg = 1 << 14;\n  this.randomBit = null;\n  this.randomMode = null;\n  this.sampleValue = null;\n  this.accValue = 0;\n  this.accCount = 1;\n  this.tmp = null;\n\n  this.reset();\n};\n\nChannelNoise.prototype = {\n  reset: function() {\n    this.progTimerCount = 0;\n    this.progTimerMax = 0;\n    this.isEnabled = false;\n    this.lengthCounter = 0;\n    this.lengthCounterEnable = false;\n    this.envDecayDisable = false;\n    this.envDecayLoopEnable = false;\n    this.shiftNow = false;\n    this.envDecayRate = 0;\n    this.envDecayCounter = 0;\n    this.envVolume = 0;\n    this.masterVolume = 0;\n    this.shiftReg = 1;\n    this.randomBit = 0;\n    this.randomMode = 0;\n    this.sampleValue = 0;\n    this.tmp = 0;\n  },\n\n  clockLengthCounter: function() {\n    if (this.lengthCounterEnable && this.lengthCounter > 0) {\n      this.lengthCounter--;\n      if (this.lengthCounter === 0) {\n        this.updateSampleValue();\n      }\n    }\n  },\n\n  clockEnvDecay: function() {\n    if (this.envReset) {\n      // Reset envelope:\n      this.envReset = false;\n      this.envDecayCounter = this.envDecayRate + 1;\n      this.envVolume = 0xf;\n    } else if (--this.envDecayCounter <= 0) {\n      // Normal handling:\n      this.envDecayCounter = this.envDecayRate + 1;\n      if (this.envVolume > 0) {\n        this.envVolume--;\n      } else {\n        this.envVolume = this.envDecayLoopEnable ? 0xf : 0;\n      }\n    }\n    if (this.envDecayDisable) {\n      this.masterVolume = this.envDecayRate;\n    } else {\n      this.masterVolume = this.envVolume;\n    }\n    this.updateSampleValue();\n  },\n\n  updateSampleValue: function() {\n    if (this.isEnabled && this.lengthCounter > 0) {\n      this.sampleValue = this.randomBit * this.masterVolume;\n    }\n  },\n\n  writeReg: function(address, value) {\n    if (address === 0x400c) {\n      // Volume/Envelope decay:\n      this.envDecayDisable = (value & 0x10) !== 0;\n      this.envDecayRate = value & 0xf;\n      this.envDecayLoopEnable = (value & 0x20) !== 0;\n      this.lengthCounterEnable = (value & 0x20) === 0;\n      if (this.envDecayDisable) {\n        this.masterVolume = this.envDecayRate;\n      } else {\n        this.masterVolume = this.envVolume;\n      }\n    } else if (address === 0x400e) {\n      // Programmable timer:\n      this.progTimerMax = this.papu.getNoiseWaveLength(value & 0xf);\n      this.randomMode = value >> 7;\n    } else if (address === 0x400f) {\n      // Length counter\n      this.lengthCounter = this.papu.getLengthMax(value & 248);\n      this.envReset = true;\n    }\n    // Update:\n    //updateSampleValue();\n  },\n\n  setEnabled: function(value) {\n    this.isEnabled = value;\n    if (!value) {\n      this.lengthCounter = 0;\n    }\n    this.updateSampleValue();\n  },\n\n  getLengthStatus: function() {\n    return this.lengthCounter === 0 || !this.isEnabled ? 0 : 1;\n  }\n};\n\nvar ChannelSquare = function(papu, square1) {\n  this.papu = papu;\n\n  // prettier-ignore\n  this.dutyLookup = [\n         0, 1, 0, 0, 0, 0, 0, 0,\n         0, 1, 1, 0, 0, 0, 0, 0,\n         0, 1, 1, 1, 1, 0, 0, 0,\n         1, 0, 0, 1, 1, 1, 1, 1\n    ];\n  // prettier-ignore\n  this.impLookup = [\n         1,-1, 0, 0, 0, 0, 0, 0,\n         1, 0,-1, 0, 0, 0, 0, 0,\n         1, 0, 0, 0,-1, 0, 0, 0,\n        -1, 0, 1, 0, 0, 0, 0, 0\n    ];\n\n  this.sqr1 = square1;\n  this.isEnabled = null;\n  this.lengthCounterEnable = null;\n  this.sweepActive = null;\n  this.envDecayDisable = null;\n  this.envDecayLoopEnable = null;\n  this.envReset = null;\n  this.sweepCarry = null;\n  this.updateSweepPeriod = null;\n\n  this.progTimerCount = null;\n  this.progTimerMax = null;\n  this.lengthCounter = null;\n  this.squareCounter = null;\n  this.sweepCounter = null;\n  this.sweepCounterMax = null;\n  this.sweepMode = null;\n  this.sweepShiftAmount = null;\n  this.envDecayRate = null;\n  this.envDecayCounter = null;\n  this.envVolume = null;\n  this.masterVolume = null;\n  this.dutyMode = null;\n  this.sweepResult = null;\n  this.sampleValue = null;\n  this.vol = null;\n\n  this.reset();\n};\n\nChannelSquare.prototype = {\n  reset: function() {\n    this.progTimerCount = 0;\n    this.progTimerMax = 0;\n    this.lengthCounter = 0;\n    this.squareCounter = 0;\n    this.sweepCounter = 0;\n    this.sweepCounterMax = 0;\n    this.sweepMode = 0;\n    this.sweepShiftAmount = 0;\n    this.envDecayRate = 0;\n    this.envDecayCounter = 0;\n    this.envVolume = 0;\n    this.masterVolume = 0;\n    this.dutyMode = 0;\n    this.vol = 0;\n\n    this.isEnabled = false;\n    this.lengthCounterEnable = false;\n    this.sweepActive = false;\n    this.sweepCarry = false;\n    this.envDecayDisable = false;\n    this.envDecayLoopEnable = false;\n  },\n\n  clockLengthCounter: function() {\n    if (this.lengthCounterEnable && this.lengthCounter > 0) {\n      this.lengthCounter--;\n      if (this.lengthCounter === 0) {\n        this.updateSampleValue();\n      }\n    }\n  },\n\n  clockEnvDecay: function() {\n    if (this.envReset) {\n      // Reset envelope:\n      this.envReset = false;\n      this.envDecayCounter = this.envDecayRate + 1;\n      this.envVolume = 0xf;\n    } else if (--this.envDecayCounter <= 0) {\n      // Normal handling:\n      this.envDecayCounter = this.envDecayRate + 1;\n      if (this.envVolume > 0) {\n        this.envVolume--;\n      } else {\n        this.envVolume = this.envDecayLoopEnable ? 0xf : 0;\n      }\n    }\n\n    if (this.envDecayDisable) {\n      this.masterVolume = this.envDecayRate;\n    } else {\n      this.masterVolume = this.envVolume;\n    }\n    this.updateSampleValue();\n  },\n\n  clockSweep: function() {\n    if (--this.sweepCounter <= 0) {\n      this.sweepCounter = this.sweepCounterMax + 1;\n      if (\n        this.sweepActive &&\n        this.sweepShiftAmount > 0 &&\n        this.progTimerMax > 7\n      ) {\n        // Calculate result from shifter:\n        this.sweepCarry = false;\n        if (this.sweepMode === 0) {\n          this.progTimerMax += this.progTimerMax >> this.sweepShiftAmount;\n          if (this.progTimerMax > 4095) {\n            this.progTimerMax = 4095;\n            this.sweepCarry = true;\n          }\n        } else {\n          this.progTimerMax =\n            this.progTimerMax -\n            ((this.progTimerMax >> this.sweepShiftAmount) -\n              (this.sqr1 ? 1 : 0));\n        }\n      }\n    }\n\n    if (this.updateSweepPeriod) {\n      this.updateSweepPeriod = false;\n      this.sweepCounter = this.sweepCounterMax + 1;\n    }\n  },\n\n  updateSampleValue: function() {\n    if (this.isEnabled && this.lengthCounter > 0 && this.progTimerMax > 7) {\n      if (\n        this.sweepMode === 0 &&\n        this.progTimerMax + (this.progTimerMax >> this.sweepShiftAmount) > 4095\n      ) {\n        //if (this.sweepCarry) {\n        this.sampleValue = 0;\n      } else {\n        this.sampleValue =\n          this.masterVolume *\n          this.dutyLookup[(this.dutyMode << 3) + this.squareCounter];\n      }\n    } else {\n      this.sampleValue = 0;\n    }\n  },\n\n  writeReg: function(address, value) {\n    var addrAdd = this.sqr1 ? 0 : 4;\n    if (address === 0x4000 + addrAdd) {\n      // Volume/Envelope decay:\n      this.envDecayDisable = (value & 0x10) !== 0;\n      this.envDecayRate = value & 0xf;\n      this.envDecayLoopEnable = (value & 0x20) !== 0;\n      this.dutyMode = (value >> 6) & 0x3;\n      this.lengthCounterEnable = (value & 0x20) === 0;\n      if (this.envDecayDisable) {\n        this.masterVolume = this.envDecayRate;\n      } else {\n        this.masterVolume = this.envVolume;\n      }\n      this.updateSampleValue();\n    } else if (address === 0x4001 + addrAdd) {\n      // Sweep:\n      this.sweepActive = (value & 0x80) !== 0;\n      this.sweepCounterMax = (value >> 4) & 7;\n      this.sweepMode = (value >> 3) & 1;\n      this.sweepShiftAmount = value & 7;\n      this.updateSweepPeriod = true;\n    } else if (address === 0x4002 + addrAdd) {\n      // Programmable timer:\n      this.progTimerMax &= 0x700;\n      this.progTimerMax |= value;\n    } else if (address === 0x4003 + addrAdd) {\n      // Programmable timer, length counter\n      this.progTimerMax &= 0xff;\n      this.progTimerMax |= (value & 0x7) << 8;\n\n      if (this.isEnabled) {\n        this.lengthCounter = this.papu.getLengthMax(value & 0xf8);\n      }\n\n      this.envReset = true;\n    }\n  },\n\n  setEnabled: function(value) {\n    this.isEnabled = value;\n    if (!value) {\n      this.lengthCounter = 0;\n    }\n    this.updateSampleValue();\n  },\n\n  getLengthStatus: function() {\n    return this.lengthCounter === 0 || !this.isEnabled ? 0 : 1;\n  }\n};\n\nvar ChannelTriangle = function(papu) {\n  this.papu = papu;\n\n  this.isEnabled = null;\n  this.sampleCondition = null;\n  this.lengthCounterEnable = null;\n  this.lcHalt = null;\n  this.lcControl = null;\n\n  this.progTimerCount = null;\n  this.progTimerMax = null;\n  this.triangleCounter = null;\n  this.lengthCounter = null;\n  this.linearCounter = null;\n  this.lcLoadValue = null;\n  this.sampleValue = null;\n  this.tmp = null;\n\n  this.reset();\n};\n\nChannelTriangle.prototype = {\n  reset: function() {\n    this.progTimerCount = 0;\n    this.progTimerMax = 0;\n    this.triangleCounter = 0;\n    this.isEnabled = false;\n    this.sampleCondition = false;\n    this.lengthCounter = 0;\n    this.lengthCounterEnable = false;\n    this.linearCounter = 0;\n    this.lcLoadValue = 0;\n    this.lcHalt = true;\n    this.lcControl = false;\n    this.tmp = 0;\n    this.sampleValue = 0xf;\n  },\n\n  clockLengthCounter: function() {\n    if (this.lengthCounterEnable && this.lengthCounter > 0) {\n      this.lengthCounter--;\n      if (this.lengthCounter === 0) {\n        this.updateSampleCondition();\n      }\n    }\n  },\n\n  clockLinearCounter: function() {\n    if (this.lcHalt) {\n      // Load:\n      this.linearCounter = this.lcLoadValue;\n      this.updateSampleCondition();\n    } else if (this.linearCounter > 0) {\n      // Decrement:\n      this.linearCounter--;\n      this.updateSampleCondition();\n    }\n    if (!this.lcControl) {\n      // Clear halt flag:\n      this.lcHalt = false;\n    }\n  },\n\n  getLengthStatus: function() {\n    return this.lengthCounter === 0 || !this.isEnabled ? 0 : 1;\n  },\n\n  readReg: function(address) {\n    return 0;\n  },\n\n  writeReg: function(address, value) {\n    if (address === 0x4008) {\n      // New values for linear counter:\n      this.lcControl = (value & 0x80) !== 0;\n      this.lcLoadValue = value & 0x7f;\n\n      // Length counter enable:\n      this.lengthCounterEnable = !this.lcControl;\n    } else if (address === 0x400a) {\n      // Programmable timer:\n      this.progTimerMax &= 0x700;\n      this.progTimerMax |= value;\n    } else if (address === 0x400b) {\n      // Programmable timer, length counter\n      this.progTimerMax &= 0xff;\n      this.progTimerMax |= (value & 0x07) << 8;\n      this.lengthCounter = this.papu.getLengthMax(value & 0xf8);\n      this.lcHalt = true;\n    }\n\n    this.updateSampleCondition();\n  },\n\n  clockProgrammableTimer: function(nCycles) {\n    if (this.progTimerMax > 0) {\n      this.progTimerCount += nCycles;\n      while (\n        this.progTimerMax > 0 &&\n        this.progTimerCount >= this.progTimerMax\n      ) {\n        this.progTimerCount -= this.progTimerMax;\n        if (\n          this.isEnabled &&\n          this.lengthCounter > 0 &&\n          this.linearCounter > 0\n        ) {\n          this.clockTriangleGenerator();\n        }\n      }\n    }\n  },\n\n  clockTriangleGenerator: function() {\n    this.triangleCounter++;\n    this.triangleCounter &= 0x1f;\n  },\n\n  setEnabled: function(value) {\n    this.isEnabled = value;\n    if (!value) {\n      this.lengthCounter = 0;\n    }\n    this.updateSampleCondition();\n  },\n\n  updateSampleCondition: function() {\n    this.sampleCondition =\n      this.isEnabled &&\n      this.progTimerMax > 7 &&\n      this.linearCounter > 0 &&\n      this.lengthCounter > 0;\n  }\n};\n\nmodule.exports = PAPU;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/papu.js\n// module id = 7\n// module chunks = 0 1","\nvar GG = function() {\n  this.patches = [];\n  this.enabled = true;\n};\n\nvar LETTER_VALUES = 'APZLGITYEOXUKSVN';\n\nfunction toDigit(letter) {\n  return LETTER_VALUES.indexOf(letter);\n}\n\nfunction toLetter(digit) {\n  return LETTER_VALUES.substr(digit, 1);\n}\n\nfunction toHex(n, width) {\n  var s = n.toString(16);\n  return '0000'.substring(0, width - s.length) + s;\n}\n\n\nGG.prototype = {\n  setEnabled: function(enabled) {\n    this.enabled = enabled;\n  },\n\n  addCode: function(code) {\n    this.patches.push(this.decode(code));\n  },\n\n  addPatch: function(addr, value, key) {\n    this.patches.push({addr: addr, value: value, key: key});\n  },\n\n  applyCodes: function(addr, value) {\n    if (!this.enabled) return value;\n\n    for (var i = 0; i < this.patches.length; ++i) { // TODO: optimize data structure?\n      if (this.patches[i].addr === (addr & 0x7fff)) {\n        if (this.patches[i].key === undefined || this.patches[i].key === value) {\n          return this.patches[i].value;\n        }\n      }\n    }\n    return value;\n  },\n\n  decode: function(code) {\n    if (code.indexOf(':') !== -1) return this.decodeHex(code);\n\n    var digits = code.toUpperCase().split('').map(toDigit);\n\n    var value = ((digits[0] & 8) << 4) + ((digits[1] & 7) << 4) + (digits[0] & 7);\n    var addr = ((digits[3] & 7) << 12) + ((digits[4] & 8) << 8) + ((digits[5] & 7) << 8) +\n        ((digits[1] & 8) << 4) + ((digits[2] & 7) << 4) + (digits[3] & 8) + (digits[4] & 7);\n    var key;\n\n    if (digits.length === 8) {\n      value += (digits[7] & 8);\n      key = ((digits[6] & 8) << 4) + ((digits[7] & 7) << 4) + (digits[5] & 8) + (digits[6] & 7);\n    } else {\n      value += (digits[5] & 8);\n    }\n\n    var wantskey = !!(digits[2] >> 3);\n\n    return { value: value, addr: addr, wantskey: wantskey, key: key };\n  },\n\n  encodeHex: function(addr, value, key, wantskey) {\n    var s = toHex(addr, 4) + ':' + toHex(value, 2);\n\n    if (key !== undefined || wantskey) {\n      s += '?';\n    }\n\n    if (key !== undefined) {\n      s += toHex(key, 2);\n    }\n\n    return s;\n  },\n\n  decodeHex: function(s) {\n    var match = s.match(/([0-9a-fA-F]+):([0-9a-fA-F]+)(\\?[0-9a-fA-F]*)?/);\n    if (!match) return null;\n\n    var addr = parseInt(match[1], 16);\n    var value = parseInt(match[2], 16);\n    var wantskey = match[3] !== undefined;\n    var key = (match[3] !== undefined && match[3].length > 1) ? parseInt(match[3].substring(1), 16) : undefined;\n\n    return { value: value, addr: addr, wantskey: wantskey, key: key };\n  },\n\n  encode: function(addr, value, key, wantskey) {\n    var digits = Array(6);\n\n    digits[0] = (value & 7) + ((value >> 4) & 8);\n    digits[1] = ((value >> 4) & 7) + ((addr >> 4) & 8);\n    digits[2] = ((addr >> 4) & 7);\n    digits[3] = (addr >> 12) + (addr & 8);\n    digits[4] = (addr & 7) + ((addr >> 8) & 8);\n    digits[5] = ((addr >> 8) & 7);\n\n    if (key === undefined) {\n      digits[5] += value & 8;\n      if (wantskey) digits[2] += 8;\n    } else {\n      digits[2] += 8;\n      digits[5] += key & 8;\n      digits[6] = (key & 7) + ((key >> 4) & 8);\n      digits[7] = ((key >> 4) & 7) + (value & 8);\n    }\n\n    var code = digits.map(toLetter).join('');\n\n    return code;\n  },\n};\n\nmodule.exports = GG;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/gg.js\n// module id = 8\n// module chunks = 0 1","var Mappers = require(\"./mappers\");\nvar Tile = require(\"./tile\");\n\nvar ROM = function(nes) {\n  this.nes = nes;\n\n  this.mapperName = new Array(92);\n\n  for (var i = 0; i < 92; i++) {\n    this.mapperName[i] = \"Unknown Mapper\";\n  }\n  this.mapperName[0] = \"Direct Access\";\n  this.mapperName[1] = \"Nintendo MMC1\";\n  this.mapperName[2] = \"UNROM\";\n  this.mapperName[3] = \"CNROM\";\n  this.mapperName[4] = \"Nintendo MMC3\";\n  this.mapperName[5] = \"Nintendo MMC5\";\n  this.mapperName[6] = \"FFE F4xxx\";\n  this.mapperName[7] = \"AOROM\";\n  this.mapperName[8] = \"FFE F3xxx\";\n  this.mapperName[9] = \"Nintendo MMC2\";\n  this.mapperName[10] = \"Nintendo MMC4\";\n  this.mapperName[11] = \"Color Dreams Chip\";\n  this.mapperName[12] = \"FFE F6xxx\";\n  this.mapperName[15] = \"100-in-1 switch\";\n  this.mapperName[16] = \"Bandai chip\";\n  this.mapperName[17] = \"FFE F8xxx\";\n  this.mapperName[18] = \"Jaleco SS8806 chip\";\n  this.mapperName[19] = \"Namcot 106 chip\";\n  this.mapperName[20] = \"Famicom Disk System\";\n  this.mapperName[21] = \"Konami VRC4a\";\n  this.mapperName[22] = \"Konami VRC2a\";\n  this.mapperName[23] = \"Konami VRC2a\";\n  this.mapperName[24] = \"Konami VRC6\";\n  this.mapperName[25] = \"Konami VRC4b\";\n  this.mapperName[32] = \"Irem G-101 chip\";\n  this.mapperName[33] = \"Taito TC0190/TC0350\";\n  this.mapperName[34] = \"32kB ROM switch\";\n\n  this.mapperName[64] = \"Tengen RAMBO-1 chip\";\n  this.mapperName[65] = \"Irem H-3001 chip\";\n  this.mapperName[66] = \"GNROM switch\";\n  this.mapperName[67] = \"SunSoft3 chip\";\n  this.mapperName[68] = \"SunSoft4 chip\";\n  this.mapperName[69] = \"SunSoft5 FME-7 chip\";\n  this.mapperName[71] = \"Camerica chip\";\n  this.mapperName[78] = \"Irem 74HC161/32-based\";\n  this.mapperName[91] = \"Pirate HK-SF3 chip\";\n};\n\nROM.prototype = {\n  // Mirroring types:\n  VERTICAL_MIRRORING: 0,\n  HORIZONTAL_MIRRORING: 1,\n  FOURSCREEN_MIRRORING: 2,\n  SINGLESCREEN_MIRRORING: 3,\n  SINGLESCREEN_MIRRORING2: 4,\n  SINGLESCREEN_MIRRORING3: 5,\n  SINGLESCREEN_MIRRORING4: 6,\n  CHRROM_MIRRORING: 7,\n\n  header: null,\n  rom: null,\n  vrom: null,\n  vromTile: null,\n\n  romCount: null,\n  vromCount: null,\n  mirroring: null,\n  batteryRam: null,\n  trainer: null,\n  fourScreen: null,\n  mapperType: null,\n  valid: false,\n\n  load: function(data) {\n    var i, j, v;\n\n    if (data.indexOf(\"NES\\x1a\") === -1) {\n      throw new Error(\"Not a valid NES ROM.\");\n    }\n    this.header = new Array(16);\n    for (i = 0; i < 16; i++) {\n      this.header[i] = data.charCodeAt(i) & 0xff;\n    }\n    this.romCount = this.header[4];\n    this.vromCount = this.header[5] * 2; // Get the number of 4kB banks, not 8kB\n    this.mirroring = (this.header[6] & 1) !== 0 ? 1 : 0;\n    this.batteryRam = (this.header[6] & 2) !== 0;\n    this.trainer = (this.header[6] & 4) !== 0;\n    this.fourScreen = (this.header[6] & 8) !== 0;\n    this.mapperType = (this.header[6] >> 4) | (this.header[7] & 0xf0);\n    /* TODO\n        if (this.batteryRam)\n            this.loadBatteryRam();*/\n    // Check whether byte 8-15 are zero's:\n    var foundError = false;\n    for (i = 8; i < 16; i++) {\n      if (this.header[i] !== 0) {\n        foundError = true;\n        break;\n      }\n    }\n    if (foundError) {\n      this.mapperType &= 0xf; // Ignore byte 7\n    }\n    // Load PRG-ROM banks:\n    this.rom = new Array(this.romCount);\n    var offset = 16;\n    for (i = 0; i < this.romCount; i++) {\n      this.rom[i] = new Array(16384);\n      for (j = 0; j < 16384; j++) {\n        if (offset + j >= data.length) {\n          break;\n        }\n        this.rom[i][j] = data.charCodeAt(offset + j) & 0xff;\n      }\n      offset += 16384;\n    }\n    // Load CHR-ROM banks:\n    this.vrom = new Array(this.vromCount);\n    for (i = 0; i < this.vromCount; i++) {\n      this.vrom[i] = new Array(4096);\n      for (j = 0; j < 4096; j++) {\n        if (offset + j >= data.length) {\n          break;\n        }\n        this.vrom[i][j] = data.charCodeAt(offset + j) & 0xff;\n      }\n      offset += 4096;\n    }\n\n    // Create VROM tiles:\n    this.vromTile = new Array(this.vromCount);\n    for (i = 0; i < this.vromCount; i++) {\n      this.vromTile[i] = new Array(256);\n      for (j = 0; j < 256; j++) {\n        this.vromTile[i][j] = new Tile();\n      }\n    }\n\n    // Convert CHR-ROM banks to tiles:\n    var tileIndex;\n    var leftOver;\n    for (v = 0; v < this.vromCount; v++) {\n      for (i = 0; i < 4096; i++) {\n        tileIndex = i >> 4;\n        leftOver = i % 16;\n        if (leftOver < 8) {\n          this.vromTile[v][tileIndex].setScanline(\n            leftOver,\n            this.vrom[v][i],\n            this.vrom[v][i + 8]\n          );\n        } else {\n          this.vromTile[v][tileIndex].setScanline(\n            leftOver - 8,\n            this.vrom[v][i - 8],\n            this.vrom[v][i]\n          );\n        }\n      }\n    }\n\n    this.valid = true;\n  },\n\n  getMirroringType: function() {\n    if (this.fourScreen) {\n      return this.FOURSCREEN_MIRRORING;\n    }\n    if (this.mirroring === 0) {\n      return this.HORIZONTAL_MIRRORING;\n    }\n    return this.VERTICAL_MIRRORING;\n  },\n\n  getMapperName: function() {\n    if (this.mapperType >= 0 && this.mapperType < this.mapperName.length) {\n      return this.mapperName[this.mapperType];\n    }\n    return \"Unknown Mapper, \" + this.mapperType;\n  },\n\n  mapperSupported: function() {\n    return typeof Mappers[this.mapperType] !== \"undefined\";\n  },\n\n  createMapper: function() {\n    if (this.mapperSupported()) {\n      return new Mappers[this.mapperType](this.nes);\n    } else {\n      throw new Error(\n        \"This ROM uses a mapper not supported by JSNES: \" +\n          this.getMapperName() +\n          \"(\" +\n          this.mapperType +\n          \")\"\n      );\n    }\n  }\n};\n\nmodule.exports = ROM;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/rom.js\n// module id = 9\n// module chunks = 0 1","var utils = require(\"./utils\");\n\nvar Mappers = {};\n\nMappers[0] = function(nes) {\n  this.nes = nes;\n};\n\nMappers[0].prototype = {\n  reset: function() {\n    this.joy1StrobeState = 0;\n    this.joy2StrobeState = 0;\n    this.joypadLastWrite = 0;\n\n    this.zapperFired = false;\n    this.zapperX = null;\n    this.zapperY = null;\n  },\n\n  write: function(address, value) {\n    if (address < 0x2000) {\n      // Mirroring of RAM:\n      this.nes.cpu.mem[address & 0x7ff] = value;\n    } else if (address > 0x4017) {\n      this.nes.cpu.mem[address] = value;\n      if (address >= 0x6000 && address < 0x8000) {\n        // Write to SaveRAM. Store in file:\n        // TODO: not yet\n        //if(this.nes.rom!=null)\n        //    this.nes.rom.writeBatteryRam(address,value);\n      }\n    } else if (address > 0x2007 && address < 0x4000) {\n      this.regWrite(0x2000 + (address & 0x7), value);\n    } else {\n      this.regWrite(address, value);\n    }\n  },\n\n  writelow: function(address, value) {\n    if (address < 0x2000) {\n      // Mirroring of RAM:\n      this.nes.cpu.mem[address & 0x7ff] = value;\n    } else if (address > 0x4017) {\n      this.nes.cpu.mem[address] = value;\n    } else if (address > 0x2007 && address < 0x4000) {\n      this.regWrite(0x2000 + (address & 0x7), value);\n    } else {\n      this.regWrite(address, value);\n    }\n  },\n\n  load: function(address) {\n    // Wrap around:\n    address &= 0xffff;\n\n    // Check address range:\n    if (address > 0x4017) {\n      // ROM:\n      return this.nes.cpu.mem[address];\n    } else if (address >= 0x2000) {\n      // I/O Ports.\n      return this.regLoad(address);\n    } else {\n      // RAM (mirrored)\n      return this.nes.cpu.mem[address & 0x7ff];\n    }\n  },\n\n  regLoad: function(address) {\n    switch (address >> 12) { // use fourth nibble (0xF000)\n      case 0:\n        break;\n\n      case 1:\n        break;\n\n      case 2:\n      // Fall through to case 3\n      case 3:\n        // PPU Registers\n        switch (address & 0x7) {\n          case 0x0:\n            // 0x2000:\n            // PPU Control Register 1.\n            // (the value is stored both\n            // in main memory and in the\n            // PPU as flags):\n            // (not in the real NES)\n            return this.nes.cpu.mem[0x2000];\n\n          case 0x1:\n            // 0x2001:\n            // PPU Control Register 2.\n            // (the value is stored both\n            // in main memory and in the\n            // PPU as flags):\n            // (not in the real NES)\n            return this.nes.cpu.mem[0x2001];\n\n          case 0x2:\n            // 0x2002:\n            // PPU Status Register.\n            // The value is stored in\n            // main memory in addition\n            // to as flags in the PPU.\n            // (not in the real NES)\n            return this.nes.ppu.readStatusRegister();\n\n          case 0x3:\n            return 0;\n\n          case 0x4:\n            // 0x2004:\n            // Sprite Memory read.\n            return this.nes.ppu.sramLoad();\n          case 0x5:\n            return 0;\n\n          case 0x6:\n            return 0;\n\n          case 0x7:\n            // 0x2007:\n            // VRAM read:\n            return this.nes.ppu.vramLoad();\n        }\n        break;\n      case 4:\n        // Sound+Joypad registers\n        switch (address - 0x4015) {\n          case 0:\n            // 0x4015:\n            // Sound channel enable, DMC Status\n            return this.nes.papu.readReg(address);\n\n          case 1:\n            // 0x4016:\n            // Joystick 1 + Strobe\n            return this.joy1Read();\n\n          case 2:\n            // 0x4017:\n            // Joystick 2 + Strobe\n            // https://wiki.nesdev.com/w/index.php/Zapper\n            var w;\n\n            if (\n              this.zapperX !== null &&\n              this.zapperY !== null &&\n              this.nes.ppu.isPixelWhite(this.zapperX, this.zapperY)\n            ) {\n              w = 0;\n            } else {\n              w = 0x1 << 3;\n            }\n\n            if (this.zapperFired) {\n              w |= 0x1 << 4;\n            }\n            return (this.joy2Read() | w) & 0xffff;\n        }\n        break;\n    }\n    return 0;\n  },\n\n  regWrite: function(address, value) {\n    switch (address) {\n      case 0x2000:\n        // PPU Control register 1\n        this.nes.cpu.mem[address] = value;\n        this.nes.ppu.updateControlReg1(value);\n        break;\n\n      case 0x2001:\n        // PPU Control register 2\n        this.nes.cpu.mem[address] = value;\n        this.nes.ppu.updateControlReg2(value);\n        break;\n\n      case 0x2003:\n        // Set Sprite RAM address:\n        this.nes.ppu.writeSRAMAddress(value);\n        break;\n\n      case 0x2004:\n        // Write to Sprite RAM:\n        this.nes.ppu.sramWrite(value);\n        break;\n\n      case 0x2005:\n        // Screen Scroll offsets:\n        this.nes.ppu.scrollWrite(value);\n        break;\n\n      case 0x2006:\n        // Set VRAM address:\n        this.nes.ppu.writeVRAMAddress(value);\n        break;\n\n      case 0x2007:\n        // Write to VRAM:\n        this.nes.ppu.vramWrite(value);\n        break;\n\n      case 0x4014:\n        // Sprite Memory DMA Access\n        this.nes.ppu.sramDMA(value);\n        break;\n\n      case 0x4015:\n        // Sound Channel Switch, DMC Status\n        this.nes.papu.writeReg(address, value);\n        break;\n\n      case 0x4016:\n        // Joystick 1 + Strobe\n        if ((value & 1) === 0 && (this.joypadLastWrite & 1) === 1) {\n          this.joy1StrobeState = 0;\n          this.joy2StrobeState = 0;\n        }\n        this.joypadLastWrite = value;\n        break;\n\n      case 0x4017:\n        // Sound channel frame sequencer:\n        this.nes.papu.writeReg(address, value);\n        break;\n\n      default:\n        // Sound registers\n        // console.log(\"write to sound reg\");\n        if (address >= 0x4000 && address <= 0x4017) {\n          this.nes.papu.writeReg(address, value);\n        }\n    }\n  },\n\n  joy1Read: function() {\n    var ret;\n\n    switch (this.joy1StrobeState) {\n      case 0:\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n        ret = this.nes.controllers[1].state[this.joy1StrobeState];\n        break;\n      case 8:\n      case 9:\n      case 10:\n      case 11:\n      case 12:\n      case 13:\n      case 14:\n      case 15:\n      case 16:\n      case 17:\n      case 18:\n        ret = 0;\n        break;\n      case 19:\n        ret = 1;\n        break;\n      default:\n        ret = 0;\n    }\n\n    this.joy1StrobeState++;\n    if (this.joy1StrobeState === 24) {\n      this.joy1StrobeState = 0;\n    }\n\n    return ret;\n  },\n\n  joy2Read: function() {\n    var ret;\n\n    switch (this.joy2StrobeState) {\n      case 0:\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n        ret = this.nes.controllers[2].state[this.joy2StrobeState];\n        break;\n      case 8:\n      case 9:\n      case 10:\n      case 11:\n      case 12:\n      case 13:\n      case 14:\n      case 15:\n      case 16:\n      case 17:\n      case 18:\n        ret = 0;\n        break;\n      case 19:\n        ret = 1;\n        break;\n      default:\n        ret = 0;\n    }\n\n    this.joy2StrobeState++;\n    if (this.joy2StrobeState === 24) {\n      this.joy2StrobeState = 0;\n    }\n\n    return ret;\n  },\n\n  loadROM: function() {\n    if (!this.nes.rom.valid || this.nes.rom.romCount < 1) {\n      throw new Error(\"NoMapper: Invalid ROM! Unable to load.\");\n    }\n\n    // Load ROM into memory:\n    this.loadPRGROM();\n\n    // Load CHR-ROM:\n    this.loadCHRROM();\n\n    // Load Battery RAM (if present):\n    this.loadBatteryRam();\n\n    // Reset IRQ:\n    //nes.getCpu().doResetInterrupt();\n    this.nes.cpu.requestIrq(this.nes.cpu.IRQ_RESET);\n  },\n\n  loadPRGROM: function() {\n    if (this.nes.rom.romCount > 1) {\n      // Load the two first banks into memory.\n      this.loadRomBank(0, 0x8000);\n      this.loadRomBank(1, 0xc000);\n    } else {\n      // Load the one bank into both memory locations:\n      this.loadRomBank(0, 0x8000);\n      this.loadRomBank(0, 0xc000);\n    }\n  },\n\n  loadCHRROM: function() {\n    // console.log(\"Loading CHR ROM..\");\n    if (this.nes.rom.vromCount > 0) {\n      if (this.nes.rom.vromCount === 1) {\n        this.loadVromBank(0, 0x0000);\n        this.loadVromBank(0, 0x1000);\n      } else {\n        this.loadVromBank(0, 0x0000);\n        this.loadVromBank(1, 0x1000);\n      }\n    } else {\n      //System.out.println(\"There aren't any CHR-ROM banks..\");\n    }\n  },\n\n  loadBatteryRam: function() {\n    if (this.nes.rom.batteryRam) {\n      var ram = this.nes.rom.batteryRam;\n      if (ram !== null && ram.length === 0x2000) {\n        // Load Battery RAM into memory:\n        utils.copyArrayElements(ram, 0, this.nes.cpu.mem, 0x6000, 0x2000);\n      }\n    }\n  },\n\n  loadRomBank: function(bank, address) {\n    // Loads a ROM bank into the specified address.\n    bank %= this.nes.rom.romCount;\n    //var data = this.nes.rom.rom[bank];\n    //cpuMem.write(address,data,data.length);\n    utils.copyArrayElements(\n      this.nes.rom.rom[bank],\n      0,\n      this.nes.cpu.mem,\n      address,\n      16384\n    );\n  },\n\n  loadVromBank: function(bank, address) {\n    if (this.nes.rom.vromCount === 0) {\n      return;\n    }\n    this.nes.ppu.triggerRendering();\n\n    utils.copyArrayElements(\n      this.nes.rom.vrom[bank % this.nes.rom.vromCount],\n      0,\n      this.nes.ppu.vramMem,\n      address,\n      4096\n    );\n\n    var vromTile = this.nes.rom.vromTile[bank % this.nes.rom.vromCount];\n    utils.copyArrayElements(\n      vromTile,\n      0,\n      this.nes.ppu.ptTile,\n      address >> 4,\n      256\n    );\n  },\n\n  load32kRomBank: function(bank, address) {\n    this.loadRomBank((bank * 2) % this.nes.rom.romCount, address);\n    this.loadRomBank((bank * 2 + 1) % this.nes.rom.romCount, address + 16384);\n  },\n\n  load8kVromBank: function(bank4kStart, address) {\n    if (this.nes.rom.vromCount === 0) {\n      return;\n    }\n    this.nes.ppu.triggerRendering();\n\n    this.loadVromBank(bank4kStart % this.nes.rom.vromCount, address);\n    this.loadVromBank(\n      (bank4kStart + 1) % this.nes.rom.vromCount,\n      address + 4096\n    );\n  },\n\n  load1kVromBank: function(bank1k, address) {\n    if (this.nes.rom.vromCount === 0) {\n      return;\n    }\n    this.nes.ppu.triggerRendering();\n\n    var bank4k = Math.floor(bank1k / 4) % this.nes.rom.vromCount;\n    var bankoffset = (bank1k % 4) * 1024;\n    utils.copyArrayElements(\n      this.nes.rom.vrom[bank4k],\n      0,\n      this.nes.ppu.vramMem,\n      bankoffset,\n      1024\n    );\n\n    // Update tiles:\n    var vromTile = this.nes.rom.vromTile[bank4k];\n    var baseIndex = address >> 4;\n    for (var i = 0; i < 64; i++) {\n      this.nes.ppu.ptTile[baseIndex + i] = vromTile[((bank1k % 4) << 6) + i];\n    }\n  },\n\n  load2kVromBank: function(bank2k, address) {\n    if (this.nes.rom.vromCount === 0) {\n      return;\n    }\n    this.nes.ppu.triggerRendering();\n\n    var bank4k = Math.floor(bank2k / 2) % this.nes.rom.vromCount;\n    var bankoffset = (bank2k % 2) * 2048;\n    utils.copyArrayElements(\n      this.nes.rom.vrom[bank4k],\n      bankoffset,\n      this.nes.ppu.vramMem,\n      address,\n      2048\n    );\n\n    // Update tiles:\n    var vromTile = this.nes.rom.vromTile[bank4k];\n    var baseIndex = address >> 4;\n    for (var i = 0; i < 128; i++) {\n      this.nes.ppu.ptTile[baseIndex + i] = vromTile[((bank2k % 2) << 7) + i];\n    }\n  },\n\n  load8kRomBank: function(bank8k, address) {\n    var bank16k = Math.floor(bank8k / 2) % this.nes.rom.romCount;\n    var offset = (bank8k % 2) * 8192;\n\n    //this.nes.cpu.mem.write(address,this.nes.rom.rom[bank16k],offset,8192);\n    utils.copyArrayElements(\n      this.nes.rom.rom[bank16k],\n      offset,\n      this.nes.cpu.mem,\n      address,\n      8192\n    );\n  },\n\n  clockIrqCounter: function() {\n    // Does nothing. This is used by the MMC3 mapper.\n  },\n\n  latchAccess: function(address) {\n    // Does nothing. This is used by MMC2.\n  },\n\n  toJSON: function() {\n    return {\n      joy1StrobeState: this.joy1StrobeState,\n      joy2StrobeState: this.joy2StrobeState,\n      joypadLastWrite: this.joypadLastWrite\n    };\n  },\n\n  fromJSON: function(s) {\n    this.joy1StrobeState = s.joy1StrobeState;\n    this.joy2StrobeState = s.joy2StrobeState;\n    this.joypadLastWrite = s.joypadLastWrite;\n  }\n};\n\nMappers[1] = function(nes) {\n  this.nes = nes;\n};\n\nMappers[1].prototype = new Mappers[0]();\n\nMappers[1].prototype.reset = function() {\n  Mappers[0].prototype.reset.apply(this);\n\n  // 5-bit buffer:\n  this.regBuffer = 0;\n  this.regBufferCounter = 0;\n\n  // Register 0:\n  this.mirroring = 0;\n  this.oneScreenMirroring = 0;\n  this.prgSwitchingArea = 1;\n  this.prgSwitchingSize = 1;\n  this.vromSwitchingSize = 0;\n\n  // Register 1:\n  this.romSelectionReg0 = 0;\n\n  // Register 2:\n  this.romSelectionReg1 = 0;\n\n  // Register 3:\n  this.romBankSelect = 0;\n};\n\nMappers[1].prototype.write = function(address, value) {\n  // Writes to addresses other than MMC registers are handled by NoMapper.\n  if (address < 0x8000) {\n    Mappers[0].prototype.write.apply(this, arguments);\n    return;\n  }\n\n  // See what should be done with the written value:\n  if ((value & 128) !== 0) {\n    // Reset buffering:\n    this.regBufferCounter = 0;\n    this.regBuffer = 0;\n\n    // Reset register:\n    if (this.getRegNumber(address) === 0) {\n      this.prgSwitchingArea = 1;\n      this.prgSwitchingSize = 1;\n    }\n  } else {\n    // Continue buffering:\n    //regBuffer = (regBuffer & (0xFF-(1<<regBufferCounter))) | ((value & (1<<regBufferCounter))<<regBufferCounter);\n    this.regBuffer =\n      (this.regBuffer & (0xff - (1 << this.regBufferCounter))) |\n      ((value & 1) << this.regBufferCounter);\n    this.regBufferCounter++;\n\n    if (this.regBufferCounter === 5) {\n      // Use the buffered value:\n      this.setReg(this.getRegNumber(address), this.regBuffer);\n\n      // Reset buffer:\n      this.regBuffer = 0;\n      this.regBufferCounter = 0;\n    }\n  }\n};\n\nMappers[1].prototype.setReg = function(reg, value) {\n  var tmp;\n\n  switch (reg) {\n    case 0:\n      // Mirroring:\n      tmp = value & 3;\n      if (tmp !== this.mirroring) {\n        // Set mirroring:\n        this.mirroring = tmp;\n        if ((this.mirroring & 2) === 0) {\n          // SingleScreen mirroring overrides the other setting:\n          this.nes.ppu.setMirroring(this.nes.rom.SINGLESCREEN_MIRRORING);\n        } else if ((this.mirroring & 1) !== 0) {\n          // Not overridden by SingleScreen mirroring.\n          this.nes.ppu.setMirroring(this.nes.rom.HORIZONTAL_MIRRORING);\n        } else {\n          this.nes.ppu.setMirroring(this.nes.rom.VERTICAL_MIRRORING);\n        }\n      }\n\n      // PRG Switching Area;\n      this.prgSwitchingArea = (value >> 2) & 1;\n\n      // PRG Switching Size:\n      this.prgSwitchingSize = (value >> 3) & 1;\n\n      // VROM Switching Size:\n      this.vromSwitchingSize = (value >> 4) & 1;\n\n      break;\n\n    case 1:\n      // ROM selection:\n      this.romSelectionReg0 = (value >> 4) & 1;\n\n      // Check whether the cart has VROM:\n      if (this.nes.rom.vromCount > 0) {\n        // Select VROM bank at 0x0000:\n        if (this.vromSwitchingSize === 0) {\n          // Swap 8kB VROM:\n          if (this.romSelectionReg0 === 0) {\n            this.load8kVromBank(value & 0xf, 0x0000);\n          } else {\n            this.load8kVromBank(\n              Math.floor(this.nes.rom.vromCount / 2) + (value & 0xf),\n              0x0000\n            );\n          }\n        } else {\n          // Swap 4kB VROM:\n          if (this.romSelectionReg0 === 0) {\n            this.loadVromBank(value & 0xf, 0x0000);\n          } else {\n            this.loadVromBank(\n              Math.floor(this.nes.rom.vromCount / 2) + (value & 0xf),\n              0x0000\n            );\n          }\n        }\n      }\n\n      break;\n\n    case 2:\n      // ROM selection:\n      this.romSelectionReg1 = (value >> 4) & 1;\n\n      // Check whether the cart has VROM:\n      if (this.nes.rom.vromCount > 0) {\n        // Select VROM bank at 0x1000:\n        if (this.vromSwitchingSize === 1) {\n          // Swap 4kB of VROM:\n          if (this.romSelectionReg1 === 0) {\n            this.loadVromBank(value & 0xf, 0x1000);\n          } else {\n            this.loadVromBank(\n              Math.floor(this.nes.rom.vromCount / 2) + (value & 0xf),\n              0x1000\n            );\n          }\n        }\n      }\n      break;\n\n    default:\n      // Select ROM bank:\n      // -------------------------\n      tmp = value & 0xf;\n      var bank;\n      var baseBank = 0;\n\n      if (this.nes.rom.romCount >= 32) {\n        // 1024 kB cart\n        if (this.vromSwitchingSize === 0) {\n          if (this.romSelectionReg0 === 1) {\n            baseBank = 16;\n          }\n        } else {\n          baseBank =\n            (this.romSelectionReg0 | (this.romSelectionReg1 << 1)) << 3;\n        }\n      } else if (this.nes.rom.romCount >= 16) {\n        // 512 kB cart\n        if (this.romSelectionReg0 === 1) {\n          baseBank = 8;\n        }\n      }\n\n      if (this.prgSwitchingSize === 0) {\n        // 32kB\n        bank = baseBank + (value & 0xf);\n        this.load32kRomBank(bank, 0x8000);\n      } else {\n        // 16kB\n        bank = baseBank * 2 + (value & 0xf);\n        if (this.prgSwitchingArea === 0) {\n          this.loadRomBank(bank, 0xc000);\n        } else {\n          this.loadRomBank(bank, 0x8000);\n        }\n      }\n  }\n};\n\n// Returns the register number from the address written to:\nMappers[1].prototype.getRegNumber = function(address) {\n  if (address >= 0x8000 && address <= 0x9fff) {\n    return 0;\n  } else if (address >= 0xa000 && address <= 0xbfff) {\n    return 1;\n  } else if (address >= 0xc000 && address <= 0xdfff) {\n    return 2;\n  } else {\n    return 3;\n  }\n};\n\nMappers[1].prototype.loadROM = function() {\n  if (!this.nes.rom.valid) {\n    throw new Error(\"MMC1: Invalid ROM! Unable to load.\");\n  }\n\n  // Load PRG-ROM:\n  this.loadRomBank(0, 0x8000); //   First ROM bank..\n  this.loadRomBank(this.nes.rom.romCount - 1, 0xc000); // ..and last ROM bank.\n\n  // Load CHR-ROM:\n  this.loadCHRROM();\n\n  // Load Battery RAM (if present):\n  this.loadBatteryRam();\n\n  // Do Reset-Interrupt:\n  this.nes.cpu.requestIrq(this.nes.cpu.IRQ_RESET);\n};\n\nMappers[1].prototype.switchLowHighPrgRom = function(oldSetting) {\n  // not yet.\n};\n\nMappers[1].prototype.switch16to32 = function() {\n  // not yet.\n};\n\nMappers[1].prototype.switch32to16 = function() {\n  // not yet.\n};\n\nMappers[1].prototype.toJSON = function() {\n  var s = Mappers[0].prototype.toJSON.apply(this);\n  s.mirroring = this.mirroring;\n  s.oneScreenMirroring = this.oneScreenMirroring;\n  s.prgSwitchingArea = this.prgSwitchingArea;\n  s.prgSwitchingSize = this.prgSwitchingSize;\n  s.vromSwitchingSize = this.vromSwitchingSize;\n  s.romSelectionReg0 = this.romSelectionReg0;\n  s.romSelectionReg1 = this.romSelectionReg1;\n  s.romBankSelect = this.romBankSelect;\n  s.regBuffer = this.regBuffer;\n  s.regBufferCounter = this.regBufferCounter;\n  return s;\n};\n\nMappers[1].prototype.fromJSON = function(s) {\n  Mappers[0].prototype.fromJSON.apply(this, arguments);\n  this.mirroring = s.mirroring;\n  this.oneScreenMirroring = s.oneScreenMirroring;\n  this.prgSwitchingArea = s.prgSwitchingArea;\n  this.prgSwitchingSize = s.prgSwitchingSize;\n  this.vromSwitchingSize = s.vromSwitchingSize;\n  this.romSelectionReg0 = s.romSelectionReg0;\n  this.romSelectionReg1 = s.romSelectionReg1;\n  this.romBankSelect = s.romBankSelect;\n  this.regBuffer = s.regBuffer;\n  this.regBufferCounter = s.regBufferCounter;\n};\n\nMappers[2] = function(nes) {\n  this.nes = nes;\n};\n\nMappers[2].prototype = new Mappers[0]();\n\nMappers[2].prototype.write = function(address, value) {\n  // Writes to addresses other than MMC registers are handled by NoMapper.\n  if (address < 0x8000) {\n    Mappers[0].prototype.write.apply(this, arguments);\n    return;\n  } else {\n    // This is a ROM bank select command.\n    // Swap in the given ROM bank at 0x8000:\n    this.loadRomBank(value, 0x8000);\n  }\n};\n\nMappers[2].prototype.loadROM = function() {\n  if (!this.nes.rom.valid) {\n    throw new Error(\"UNROM: Invalid ROM! Unable to load.\");\n  }\n\n  // Load PRG-ROM:\n  this.loadRomBank(0, 0x8000);\n  this.loadRomBank(this.nes.rom.romCount - 1, 0xc000);\n\n  // Load CHR-ROM:\n  this.loadCHRROM();\n\n  // Do Reset-Interrupt:\n  this.nes.cpu.requestIrq(this.nes.cpu.IRQ_RESET);\n};\n\n/**\n * Mapper 003 (CNROM)\n *\n * @constructor\n * @example Solomon's Key, Arkanoid, Arkista's Ring, Bump 'n' Jump, Cybernoid\n * @description http://wiki.nesdev.com/w/index.php/INES_Mapper_003\n */\nMappers[3] = function(nes) {\n  this.nes = nes;\n};\n\nMappers[3].prototype = new Mappers[0]();\n\nMappers[3].prototype.write = function(address, value) {\n  // Writes to addresses other than MMC registers are handled by NoMapper.\n  if (address < 0x8000) {\n    Mappers[0].prototype.write.apply(this, arguments);\n    return;\n  } else {\n    // This is a ROM bank select command.\n    // Swap in the given ROM bank at 0x8000:\n    // This is a VROM bank select command.\n    // Swap in the given VROM bank at 0x0000:\n    var bank = (value % (this.nes.rom.vromCount / 2)) * 2;\n    this.loadVromBank(bank, 0x0000);\n    this.loadVromBank(bank + 1, 0x1000);\n    this.load8kVromBank(value * 2, 0x0000);\n  }\n};\n\nMappers[4] = function(nes) {\n  this.nes = nes;\n\n  this.CMD_SEL_2_1K_VROM_0000 = 0;\n  this.CMD_SEL_2_1K_VROM_0800 = 1;\n  this.CMD_SEL_1K_VROM_1000 = 2;\n  this.CMD_SEL_1K_VROM_1400 = 3;\n  this.CMD_SEL_1K_VROM_1800 = 4;\n  this.CMD_SEL_1K_VROM_1C00 = 5;\n  this.CMD_SEL_ROM_PAGE1 = 6;\n  this.CMD_SEL_ROM_PAGE2 = 7;\n\n  this.command = null;\n  this.prgAddressSelect = null;\n  this.chrAddressSelect = null;\n  this.pageNumber = null;\n  this.irqCounter = null;\n  this.irqLatchValue = null;\n  this.irqEnable = null;\n  this.prgAddressChanged = false;\n};\n\nMappers[4].prototype = new Mappers[0]();\n\nMappers[4].prototype.write = function(address, value) {\n  // Writes to addresses other than MMC registers are handled by NoMapper.\n  if (address < 0x8000) {\n    Mappers[0].prototype.write.apply(this, arguments);\n    return;\n  }\n\n  switch (address) {\n    case 0x8000:\n      // Command/Address Select register\n      this.command = value & 7;\n      var tmp = (value >> 6) & 1;\n      if (tmp !== this.prgAddressSelect) {\n        this.prgAddressChanged = true;\n      }\n      this.prgAddressSelect = tmp;\n      this.chrAddressSelect = (value >> 7) & 1;\n      break;\n\n    case 0x8001:\n      // Page number for command\n      this.executeCommand(this.command, value);\n      break;\n\n    case 0xa000:\n      // Mirroring select\n      if ((value & 1) !== 0) {\n        this.nes.ppu.setMirroring(this.nes.rom.HORIZONTAL_MIRRORING);\n      } else {\n        this.nes.ppu.setMirroring(this.nes.rom.VERTICAL_MIRRORING);\n      }\n      break;\n\n    case 0xa001:\n      // SaveRAM Toggle\n      // TODO\n      //nes.getRom().setSaveState((value&1)!=0);\n      break;\n\n    case 0xc000:\n      // IRQ Counter register\n      this.irqCounter = value;\n      //nes.ppu.mapperIrqCounter = 0;\n      break;\n\n    case 0xc001:\n      // IRQ Latch register\n      this.irqLatchValue = value;\n      break;\n\n    case 0xe000:\n      // IRQ Control Reg 0 (disable)\n      //irqCounter = irqLatchValue;\n      this.irqEnable = 0;\n      break;\n\n    case 0xe001:\n      // IRQ Control Reg 1 (enable)\n      this.irqEnable = 1;\n      break;\n\n    default:\n    // Not a MMC3 register.\n    // The game has probably crashed,\n    // since it tries to write to ROM..\n    // IGNORE.\n  }\n};\n\nMappers[4].prototype.executeCommand = function(cmd, arg) {\n  switch (cmd) {\n    case this.CMD_SEL_2_1K_VROM_0000:\n      // Select 2 1KB VROM pages at 0x0000:\n      if (this.chrAddressSelect === 0) {\n        this.load1kVromBank(arg, 0x0000);\n        this.load1kVromBank(arg + 1, 0x0400);\n      } else {\n        this.load1kVromBank(arg, 0x1000);\n        this.load1kVromBank(arg + 1, 0x1400);\n      }\n      break;\n\n    case this.CMD_SEL_2_1K_VROM_0800:\n      // Select 2 1KB VROM pages at 0x0800:\n      if (this.chrAddressSelect === 0) {\n        this.load1kVromBank(arg, 0x0800);\n        this.load1kVromBank(arg + 1, 0x0c00);\n      } else {\n        this.load1kVromBank(arg, 0x1800);\n        this.load1kVromBank(arg + 1, 0x1c00);\n      }\n      break;\n\n    case this.CMD_SEL_1K_VROM_1000:\n      // Select 1K VROM Page at 0x1000:\n      if (this.chrAddressSelect === 0) {\n        this.load1kVromBank(arg, 0x1000);\n      } else {\n        this.load1kVromBank(arg, 0x0000);\n      }\n      break;\n\n    case this.CMD_SEL_1K_VROM_1400:\n      // Select 1K VROM Page at 0x1400:\n      if (this.chrAddressSelect === 0) {\n        this.load1kVromBank(arg, 0x1400);\n      } else {\n        this.load1kVromBank(arg, 0x0400);\n      }\n      break;\n\n    case this.CMD_SEL_1K_VROM_1800:\n      // Select 1K VROM Page at 0x1800:\n      if (this.chrAddressSelect === 0) {\n        this.load1kVromBank(arg, 0x1800);\n      } else {\n        this.load1kVromBank(arg, 0x0800);\n      }\n      break;\n\n    case this.CMD_SEL_1K_VROM_1C00:\n      // Select 1K VROM Page at 0x1C00:\n      if (this.chrAddressSelect === 0) {\n        this.load1kVromBank(arg, 0x1c00);\n      } else {\n        this.load1kVromBank(arg, 0x0c00);\n      }\n      break;\n\n    case this.CMD_SEL_ROM_PAGE1:\n      if (this.prgAddressChanged) {\n        // Load the two hardwired banks:\n        if (this.prgAddressSelect === 0) {\n          this.load8kRomBank((this.nes.rom.romCount - 1) * 2, 0xc000);\n        } else {\n          this.load8kRomBank((this.nes.rom.romCount - 1) * 2, 0x8000);\n        }\n        this.prgAddressChanged = false;\n      }\n\n      // Select first switchable ROM page:\n      if (this.prgAddressSelect === 0) {\n        this.load8kRomBank(arg, 0x8000);\n      } else {\n        this.load8kRomBank(arg, 0xc000);\n      }\n      break;\n\n    case this.CMD_SEL_ROM_PAGE2:\n      // Select second switchable ROM page:\n      this.load8kRomBank(arg, 0xa000);\n\n      // hardwire appropriate bank:\n      if (this.prgAddressChanged) {\n        // Load the two hardwired banks:\n        if (this.prgAddressSelect === 0) {\n          this.load8kRomBank((this.nes.rom.romCount - 1) * 2, 0xc000);\n        } else {\n          this.load8kRomBank((this.nes.rom.romCount - 1) * 2, 0x8000);\n        }\n        this.prgAddressChanged = false;\n      }\n  }\n};\n\nMappers[4].prototype.loadROM = function() {\n  if (!this.nes.rom.valid) {\n    throw new Error(\"MMC3: Invalid ROM! Unable to load.\");\n  }\n\n  // Load hardwired PRG banks (0xC000 and 0xE000):\n  this.load8kRomBank((this.nes.rom.romCount - 1) * 2, 0xc000);\n  this.load8kRomBank((this.nes.rom.romCount - 1) * 2 + 1, 0xe000);\n\n  // Load swappable PRG banks (0x8000 and 0xA000):\n  this.load8kRomBank(0, 0x8000);\n  this.load8kRomBank(1, 0xa000);\n\n  // Load CHR-ROM:\n  this.loadCHRROM();\n\n  // Load Battery RAM (if present):\n  this.loadBatteryRam();\n\n  // Do Reset-Interrupt:\n  this.nes.cpu.requestIrq(this.nes.cpu.IRQ_RESET);\n};\n\nMappers[4].prototype.clockIrqCounter = function() {\n  if (this.irqEnable === 1) {\n    this.irqCounter--;\n    if (this.irqCounter < 0) {\n      // Trigger IRQ:\n      //nes.getCpu().doIrq();\n      this.nes.cpu.requestIrq(this.nes.cpu.IRQ_NORMAL);\n      this.irqCounter = this.irqLatchValue;\n    }\n  }\n};\n\nMappers[4].prototype.toJSON = function() {\n  var s = Mappers[0].prototype.toJSON.apply(this);\n  s.command = this.command;\n  s.prgAddressSelect = this.prgAddressSelect;\n  s.chrAddressSelect = this.chrAddressSelect;\n  s.pageNumber = this.pageNumber;\n  s.irqCounter = this.irqCounter;\n  s.irqLatchValue = this.irqLatchValue;\n  s.irqEnable = this.irqEnable;\n  s.prgAddressChanged = this.prgAddressChanged;\n  return s;\n};\n\nMappers[4].prototype.fromJSON = function(s) {\n  Mappers[0].prototype.fromJSON.apply(this, arguments);\n  this.command = s.command;\n  this.prgAddressSelect = s.prgAddressSelect;\n  this.chrAddressSelect = s.chrAddressSelect;\n  this.pageNumber = s.pageNumber;\n  this.irqCounter = s.irqCounter;\n  this.irqLatchValue = s.irqLatchValue;\n  this.irqEnable = s.irqEnable;\n  this.prgAddressChanged = s.prgAddressChanged;\n};\n\n/**\n * Mapper005 (MMC5,ExROM)\n *\n * @example Castlevania 3, Just Breed, Uncharted Waters, Romance of the 3 Kingdoms 2, Laser Invasion, Metal Slader Glory, Uchuu Keibitai SDF, Shin 4 Nin Uchi Mahjong - Yakuman Tengoku\n * @description http://wiki.nesdev.com/w/index.php/INES_Mapper_005\n * @constructor\n */\nMappers[5] = function(nes) {\n  this.nes = nes;\n};\n\nMappers[5].prototype = new Mappers[0]();\n\nMappers[5].prototype.write = function(address, value) {\n  // Writes to addresses other than MMC registers are handled by NoMapper.\n  if (address < 0x8000) {\n    Mappers[0].prototype.write.apply(this, arguments);\n  } else {\n    this.load8kVromBank(value, 0x0000);\n  }\n};\n\nMappers[5].prototype.write = function(address, value) {\n  // Writes to addresses other than MMC registers are handled by NoMapper.\n  if (address < 0x5000) {\n    Mappers[0].prototype.write.apply(this, arguments);\n    return;\n  }\n\n  switch (address) {\n    case 0x5100:\n      this.prg_size = value & 3;\n      break;\n    case 0x5101:\n      this.chr_size = value & 3;\n      break;\n    case 0x5102:\n      this.sram_we_a = value & 3;\n      break;\n    case 0x5103:\n      this.sram_we_b = value & 3;\n      break;\n    case 0x5104:\n      this.graphic_mode = value & 3;\n      break;\n    case 0x5105:\n      this.nametable_mode = value;\n      this.nametable_type[0] = value & 3;\n      this.load1kVromBank(value & 3, 0x2000);\n      value >>= 2;\n      this.nametable_type[1] = value & 3;\n      this.load1kVromBank(value & 3, 0x2400);\n      value >>= 2;\n      this.nametable_type[2] = value & 3;\n      this.load1kVromBank(value & 3, 0x2800);\n      value >>= 2;\n      this.nametable_type[3] = value & 3;\n      this.load1kVromBank(value & 3, 0x2c00);\n      break;\n    case 0x5106:\n      this.fill_chr = value;\n      break;\n    case 0x5107:\n      this.fill_pal = value & 3;\n      break;\n    case 0x5113:\n      this.SetBank_SRAM(3, value & 3);\n      break;\n    case 0x5114:\n    case 0x5115:\n    case 0x5116:\n    case 0x5117:\n      this.SetBank_CPU(address, value);\n      break;\n    case 0x5120:\n    case 0x5121:\n    case 0x5122:\n    case 0x5123:\n    case 0x5124:\n    case 0x5125:\n    case 0x5126:\n    case 0x5127:\n      this.chr_mode = 0;\n      this.chr_page[0][address & 7] = value;\n      this.SetBank_PPU();\n      break;\n    case 0x5128:\n    case 0x5129:\n    case 0x512a:\n    case 0x512b:\n      this.chr_mode = 1;\n      this.chr_page[1][(address & 3) + 0] = value;\n      this.chr_page[1][(address & 3) + 4] = value;\n      this.SetBank_PPU();\n      break;\n    case 0x5200:\n      this.split_control = value;\n      break;\n    case 0x5201:\n      this.split_scroll = value;\n      break;\n    case 0x5202:\n      this.split_page = value & 0x3f;\n      break;\n    case 0x5203:\n      this.irq_line = value;\n      this.nes.cpu.ClearIRQ();\n      break;\n    case 0x5204:\n      this.irq_enable = value;\n      this.nes.cpu.ClearIRQ();\n      break;\n    case 0x5205:\n      this.mult_a = value;\n      break;\n    case 0x5206:\n      this.mult_b = value;\n      break;\n    default:\n      if (address >= 0x5000 && address <= 0x5015) {\n        this.nes.papu.exWrite(address, value);\n      } else if (address >= 0x5c00 && address <= 0x5fff) {\n        if (this.graphic_mode === 2) {\n          // ExRAM\n          // vram write\n        } else if (this.graphic_mode !== 3) {\n          // Split,ExGraphic\n          if (this.irq_status & 0x40) {\n            // vram write\n          } else {\n            // vram write\n          }\n        }\n      } else if (address >= 0x6000 && address <= 0x7fff) {\n        if (this.sram_we_a === 2 && this.sram_we_b === 1) {\n          // additional ram write\n        }\n      }\n      break;\n  }\n};\n\nMappers[5].prototype.loadROM = function() {\n  if (!this.nes.rom.valid) {\n    throw new Error(\"UNROM: Invalid ROM! Unable to load.\");\n  }\n\n  // Load PRG-ROM:\n  this.load8kRomBank(this.nes.rom.romCount * 2 - 1, 0x8000);\n  this.load8kRomBank(this.nes.rom.romCount * 2 - 1, 0xa000);\n  this.load8kRomBank(this.nes.rom.romCount * 2 - 1, 0xc000);\n  this.load8kRomBank(this.nes.rom.romCount * 2 - 1, 0xe000);\n\n  // Load CHR-ROM:\n  this.loadCHRROM();\n\n  // Do Reset-Interrupt:\n  this.nes.cpu.requestIrq(this.nes.cpu.IRQ_RESET);\n};\n\n/**\n * Mapper007 (AxROM)\n * @example Battletoads, Time Lord, Marble Madness\n * @description http://wiki.nesdev.com/w/index.php/INES_Mapper_007\n * @constructor\n */\nMappers[7] = function(nes) {\n  this.nes = nes;\n};\n\nMappers[7].prototype = new Mappers[0]();\n\nMappers[7].prototype.write = function(address, value) {\n  // Writes to addresses other than MMC registers are handled by NoMapper.\n  if (address < 0x8000) {\n    Mappers[0].prototype.write.apply(this, arguments);\n  } else {\n    this.load32kRomBank(value & 0x7, 0x8000);\n    if (value & 0x10) {\n      this.nes.ppu.setMirroring(this.nes.rom.SINGLESCREEN_MIRRORING2);\n    } else {\n      this.nes.ppu.setMirroring(this.nes.rom.SINGLESCREEN_MIRRORING);\n    }\n  }\n};\n\nMappers[7].prototype.loadROM = function() {\n  if (!this.nes.rom.valid) {\n    throw new Error(\"AOROM: Invalid ROM! Unable to load.\");\n  }\n\n  // Load PRG-ROM:\n  this.loadPRGROM();\n\n  // Load CHR-ROM:\n  this.loadCHRROM();\n\n  // Do Reset-Interrupt:\n  this.nes.cpu.requestIrq(this.nes.cpu.IRQ_RESET);\n};\n\n/**\n * Mapper 011 (Color Dreams)\n *\n * @description http://wiki.nesdev.com/w/index.php/Color_Dreams\n * @example Crystal Mines, Metal Fighter\n * @constructor\n */\nMappers[11] = function(nes) {\n  this.nes = nes;\n};\n\nMappers[11].prototype = new Mappers[0]();\n\nMappers[11].prototype.write = function(address, value) {\n  if (address < 0x8000) {\n    Mappers[0].prototype.write.apply(this, arguments);\n    return;\n  } else {\n    // Swap in the given PRG-ROM bank:\n    var prgbank1 = ((value & 0xf) * 2) % this.nes.rom.romCount;\n    var prgbank2 = ((value & 0xf) * 2 + 1) % this.nes.rom.romCount;\n\n    this.loadRomBank(prgbank1, 0x8000);\n    this.loadRomBank(prgbank2, 0xc000);\n\n    if (this.nes.rom.vromCount > 0) {\n      // Swap in the given VROM bank at 0x0000:\n      var bank = ((value >> 4) * 2) % this.nes.rom.vromCount;\n      this.loadVromBank(bank, 0x0000);\n      this.loadVromBank(bank + 1, 0x1000);\n    }\n  }\n};\n\n/**\n * Mapper 034 (BNROM, NINA-01)\n *\n * @description http://wiki.nesdev.com/w/index.php/INES_Mapper_034\n * @example Darkseed, Mashou, Mission Impossible 2\n * @constructor\n */\nMappers[34] = function(nes) {\n  this.nes = nes;\n};\n\nMappers[34].prototype = new Mappers[0]();\n\nMappers[34].prototype.write = function(address, value) {\n  if (address < 0x8000) {\n    Mappers[0].prototype.write.apply(this, arguments);\n    return;\n  } else {\n    this.load32kRomBank(value, 0x8000);\n  }\n};\n\n/**\n * Mapper 066 (GxROM)\n *\n * @description http://wiki.nesdev.com/w/index.php/INES_Mapper_066\n * @example Doraemon, Dragon Power, Gumshoe, Thunder & Lightning,\n * Super Mario Bros. + Duck Hunt\n * @constructor\n */\nMappers[66] = function(nes) {\n  this.nes = nes;\n  console.log(\"Mapper 66\");\n};\n\nMappers[66].prototype = new Mappers[0]();\n\nMappers[66].prototype.write = function(address, value) {\n  if (address < 0x8000) {\n    Mappers[0].prototype.write.apply(this, arguments);\n    return;\n  } else {\n    // Swap in the given PRG-ROM bank at 0x8000:\n    this.load32kRomBank((value >> 4) & 3, 0x8000);\n\n    // Swap in the given VROM bank at 0x0000:\n    this.load8kVromBank((value & 3) * 2, 0x0000);\n  }\n};\n\nmodule.exports = Mappers;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/mappers.js\n// module id = 10\n// module chunks = 0 1"],"sourceRoot":""}